% Minimal Runtime System Execution Engine
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{xr}
\externaldocument{mex}

\input{mex-macros}

\begin{document}
        
\title{MEX Assembler (MEXAS)\\[2ex]
       (Version 3)}

\author{Robert L. Walton}

\date{January 25, 2025}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

\key{MEXAS} is an assembly language for MEX.  The \ttkey{mexas}
assembler can be use as a MEX compiler.

MEXAS serves as a prototype for more advanced MEX compilers
and as a tool for debugging MEX and the {\tt mexcom} and
{\tt mexstack} compiler components.

\section{MEXAS Syntax}
\label{MEXAS-SYNTAX}

MEXAS programs are written in ASCII.
Non-ASCII bytes and
control characters other than whitespace
are illegal and are
replaced by `\#'.

A MEXAS program consists of statements which are instructions
or declarations, each encoded as a sequence of lexemes.

If a lexeme begins with `\ttkey{//}', it and the rest of the
line are a \key{comment} and are ignored (except for detecting
illegal characters).  A line containing only a comment is a
\key{comment line}.  Blank lines have no effect.

If the last lexeme on a line is `\ttkey{\textbackslash}',
the current statement
is \key{continued} on the next line (the `\TT{\textbackslash}' is
discarded).

A \key{statement} is a sequence of lines beginning with the first
line after the previous statement (or the first line of a file)
and ending with a non-blank, non-comment line that is
\underline{not} continued.  Statements are either instructions or
declarations.

Instructions begin with an op code lexeme, and the program syntax
of all the instructions taken together
is that of a code vector: see Code Vectors,
\mexref{CODE-VECTORS}.

Declarations define jump instruction targets or print assembly
information.

When `\ttkey{::=}' is used in a syntax equation, the
items of the equation are lexemes and \underline{not}
characters.
When `\ttkey{:::=}' is used, the
items of the equation are characters and \underline{not}
lexemes.

\section{Lexemes}

A MEXAS \key{lexeme} is a sequence of non-whitespace characters
surrounded by whitespace, or a single quote (\TT{'}) followed
by a sequence of non-single-quote characters followed by a
single quote, or a double quote (\TT{"}) followed by a 
sequence of non-double-quote characters followed by a
double quote.

A \key{number}\label{NUMBER} is a lexeme acceptable as an IEEE floating point
number to the POSIX \TT{strtod} function.

A \key{name}\label{NAME} is a lexeme beginning with a letter that is
\underline{not} a number (\TT{nan}, \TT{InF}, etc. are numbers
and not names) and is not longer than 32 characters.

A \key{string}\label{STRING} is a lexeme beginning with quote and ending
with the same kind of quote.

All lexemes must be on a single line: they cannot be continued to the
next line.  Strings not terminated by an end of line are automatically
terminated with an error message.

A comment beginning lexeme (\TT{//\ldots}) and a continuation
lexeme (\TT{\textbackslash}) must be lexemes surrounded by whitespace.

Illegal characters are replaced by \TT{\#} and become part of the
current lexeme or comment.  An error message accompanies such replacement.

\section{Interface with MEX Compiler Components}
\label{INTERFACE-WITH-MEX-COMPILER-COMPONENTS}

{\tt MEXAS} uses the concepts, data, and functions of the
{\tt mexcom} and {\tt mexstack} MEX compiler components

Specifically {\tt MEXAS} implements a variable stack that serves
as the variable symbol table and a separate function stack that serves
as the function symbol table.

Unlike a typical compiler symbol table, the {\tt MEXAS} variable stack has
one entry for every location in the range {\tt [0, mexstack::stack\_length)}.
Many of these entries are \skey{dummy variable}s, indicated by
giving them the `name' {\tt "*"}, which is not a variable name,
and these correspond to locations that are not assigned to any
real variable.

Between {\tt MEXAS} statements, the length of the variable stack
is equal to {\tt mexstack::\EOL stack\_\EOL length}.

A typical {\tt MEXAS} instruction, which during run-time pops a few
values from the process run-time stack and pushes a value, at assembly
time pops the variable stack a few times and then pushes an entry,
often a dummy variable, into the variable stack.

This differs from the typical compiler, which pushes variables into
the symbol table only for assignment statements and
at the beginning of blocks (arguments and next variables).

More explicitly, {\tt MEXAS} assembles most instructions by first
setting {\tt mexstack::stack\_length} to the value it will have
at the end of the instruction, second pushing the instruction into
the {\tt mexcom::output\_module} code vector, and third, popping
and pushing the variable stack.


The location of a {\tt MEXAS} variable is its index in the
variable stack when that stack is viewed as a vector.
The location of a {\tt MEXAS} function
is the index of its {\tt BEGF} instruction in the current module
code vector.
After a module is assembled,
it is executed, and then the variable and function stacks are
encoded in the module interface that maps variable and function names
to locations.


\section{MEXAS Instructions}
\label{MEXAS-INSTRUCTIONS}

In the following description of MEXAS instruction syntax and
assembly actions:

\begin{enumerate}
\item When an instruction pushes an
element into the variable or function stacks, the element is given
the lexical level and depth of the instruction.
\item A \emkey{variable-name} is a name of a variable stack element.
If two elements have the same {\em variable-name}, the element nearer
the top of the stack hides the element lower down.
\item A \emkey{function-name} is a name of a function stack element.
If two elements have the same {\em function-name}, the element nearer
the top of the stack hides the element lower down.
\item Stack searches always proceed from a higher stack element
to the bottom-most stack element,
and accept the first element found with the desired name.
Most searches start at the top of the stack, but searches restricted
to level 0 variables or functions start with the upper-most level
0 variable or function.
\item Modules are named by the name of the file assembled to produce
the module, with the suffix \TT{.mex} deleted.  Such a name is
a \emkey{module-name}.
\item Some instructions have an optional \emkey{new-variable-name} argument
that names an element being pushed to the variables stack.
The {\em new-variable-name}
must \underline{not} be the same as the name of any variable of
less lexical level or depth than the instruction, or the same name
as that of an argument of a function,
or the same name as a \TT{next-} variable of a loop\mexnote{NEXT-VARIABLE}
(specifically, must not have the same
name as a variable whose index is
{\tt < mexstack::stack\_limit}\mexnote{STACK-LIMIT}).

If {\em new-variable-name} is missing or `\TT{*}',
the element just gets the name `\TT{*}' to indicate that the
variable stack element has no name.

\item A variable cannot be written if it has a lexical level less than
that of the writing instruction, or is a function argument variable,
or has depth equal to the writing instruction and is not
a loop `{\tt next-\ldots}' variable.

\item A stack location cannot be popped or moved in the stack unless
it has the current lexical level and depth and is not a function argument
or loop \TT{next-} variable.  Only \TT{CALL\ldots} and \TT{RET}
instructions can move stack values from one lexical level and depth
to another lexical level and depth.

\item The operands that take integer values must have values in the
range $[0,2^{32})$ (so they will fit into \TT{immedA}, \TT{immedB},
or \TT{immedC} instruction
members).
\item Some instructions have a \emkey{level}\label{LEVEL} argument, which must
specify a lexical level in the range [1,$L$], where $L$ is the lexical
level of the instruction.  If the argument is missing or \TT{0},
the specified lexical level is $L$.
If the argument is a positive integer, it is the specified lexical level
(and must be in range).  If the argument is a negative integer -$i$,
the specified lexical level is $L-i$ (and must be in range).
\item Some instructions have an \emkey{attribute-label}\label{ATTRIBUTE-LABEL}
argument which may be a {\em string} or may have the form
\begin{indpar}
\TT{[} {\em string}\PLUS{} \TT{]}
\end{indpar}
This latter form specifies a MIN label whose elements are the {\em string}s.
\item Some instructions have a \emkey{trace-message} argument
and some have \emkey{trace-packet} arguments, where:
\begin{indpar}
\emkey{trace-message} ::= {\em string}
\\[0.5ex]
\emkey{trace-packet} ::= {\em trace-message} {\em trace-variable}\STAR{}
\\[0.5ex]
\emkey{trace-variable} ::= {\em variable-name}
\end{indpar}
These specify the {\em trace-info} for the instructions:
see Trace-Packet Based Trace Messages,
\mexref{TRACE-PACKET-BASED-TRACE-MESSAGES}.
\item To assemble a run-time instruction, {\tt MEXAS} first adjusts
{\tt mexstack::stack\_length} to what it will be \underline{after}
the instruction, then pushes the instruction to
the end of the {\tt mexcom::output\_module} code vector, and lastly
adjusts the variable and function stacks.

If an instruction takes trace variables, these are pushed into the stack by
calling {\tt push\_push\_\EOL instr} for each trace variable \underline{before}
assembling the run-time instruction.  The variable stack does \underline{not}
have elements corresponding to trace variables, and they are \underline{not}
counted by {\tt mexstack::stack\_length}.  They are in a sense
invisible to the regular assembly process.
\item
In describing the MEXAS statements that output a run-time instruction,
we describe what the assembler does to the variable stack, pending
jump list, etc., but omit reference to outputting the instructions to the
module code vector (including instructions to push trace variable values).
Thus when we say that the assembler does nothing for {\tt NOP}, {\tt TRACE},
{\tt WARN}, and {\tt ERROR},
we mean nothing but outputting instructions to the module code vector.
\end{enumerate}


Given the above notes, the instruction descriptions are:

{\em aop} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em aop} is any non-immediate
arithmetic operation code (e.g. {\tt ADD} but not {\tt ADDI}) from
Figure~\mexref{ARITHMETIC-INSTRUCTIONS}.
The run-time
action of the instruction is specified in that figure.

At assembly-time the same number of elements are popped from the variable stack
as are popped from the process stack during run-time.
Then one element is pushed to the variable stack with
{\em new-variable-name} as its name.
\end{indpar}

{\em aop}\TT{I} ~ {\em number} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em aop}\TT{I} is any immediate arithmetic operation code from
Figure~\mexref{ARITHMETIC-INSTRUCTIONS} (e.g., {\tt ADDI})
with \TT{immedD} set to {\tt number}.
The run-time
action of the instruction is specified in
Figure~\mexref{ARITHMETIC-INSTRUCTIONS}.

At assembly-time one element is popped from the variable stack and then
one element is pushed to the variable stack with
{\em new-variable-name} as its name.
\end{indpar}

\ttkey{PUSHM} ~ {\em variable-name} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
lexical level 0 variable, using a \TT{PUSHL} instruction with
\TT{immedB == 0} as per
Figure~\mexref{STACK-INSTRUCTIONS}.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em variable-name} is restricted to
elements with the lexical level \TT{0}.
\end{indpar}

\ttkey{PUSHG} ~ {\em module-name} ~ {\em variable-name} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
global variable in the named module using the \TT{PUSHG} instruction
from Figure~\mexref{STACK-INSTRUCTIONS}.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack searched for {\em variable-name} is the variable
stack of the previously assembled module named, as it is at the
end of the assembly of that module (only level 0, depth 0 variables
of the module are present in this stack).

If {\em module-name} is `\TT{*}', all modules are searched in most recently
assembled first order, and the first module found with named variable
is used.
\end{indpar}

\ttkey{PUSH} ~ {\em variable-name} ~
             {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the variable
named in the variable stack or previously assembled module variable stack.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The search for {\em variable-name} begins with the entire variable
stack and proceeds through the symbol table stack
of previously assembled modules
in most recently assembled first order.
\TT{PUSH} assembles
to the run-time instruction \TT{PUSHS}, \TT{PUSHL}, \TT{PUSHG},
or \TT{PUSHA} from Figure~\mexref{STACK-INSTRUCTIONS},
depending on the location of the variable.

(If the variable name is in the variable stack,
{\tt mexstack::push\_\EOL push\_instr}\mexnote{PUSH-PUSH-INSTR}
is called.  Otherwise {\tt PUSHG} is used.)
\end{indpar}

\ttkey{PUSHI} ~ {\em number} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ {\em attrubute-label} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{TRUE} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{FALSE} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{NONE} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of
the {\em number}\pagnote{NUMBER}, or
the {\em attibute-label}\pagnote{ATTRIBUTE-LABEL} (which might be
a {\em string}),
or \TT{mex::TRUE}, or \TT{mex::FALSE}, or \TT{min::NONE()}.
\ttkey{PUSHI} assembles to the run-time instruction \TT{PUSHI}
from Figure~\mexref{STACK-INSTRUCTIONS}.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{POP} ~ {\em variable-name}\QMARK{}
\begin{indpar}
At run-time, pops the process stack and stores the value popped
into the variable named in the variable stack.  Or if the
variable name is not given or is `\TT{*}', discards the value popped.

At assembly time, pops the variable stack.

The variable stack search for {\em variable-name} is restricted to
elements with the same lexical level as the \TT{POP} instruction
that are not arguments to that lexical level and that are of
lesser depth than the \TT{POP} instruction or are
loop `{\tt next-\ldots}' variables.

\ttkey{POP} assembles to the run-time instruction \TT{POPS}
from Figure~\mexref{STACK-INSTRUCTIONS}.
Note that \TT{POPL}, \TT{POPG}, and \TT{POPA} do
\underline{not} exist as you cannot write
variables that are arguments, or at a different lexical level,
or in a different module.
\end{indpar}

\ttkey{DEL} ~ {\em immedA} ~ {\em immedC}
\begin{indpar}
At run-time, executes the \TT{DEL} instruction from
Figure~\mexref{STACK-INSTRUCTIONS}.

At assembly time, deletes from the variables stack the {\em immedC}
variables that are immediately below the top {\em immedA} variables
in the stack.

\end{indpar}

\ttkey{JMP} ~ {\em jmp-target}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{JUMP-INSTRUCTIONS}.  At assembly-time,
this instruction 
calls {\tt mexstack::push\_\EOL jmp\_instr}\mexnote{PUSH-JMP-INSTR}
to add an element to the pending jump list.
\end{indpar}

\ttkey{JMPEQ}/\ttkey{JMPNEQ}/\ttkey{JMPLT}/\ttkey{JMPLEQ}/%
     \ttkey{JMPGT}/\ttkey{JMPGEQ} ~ \TT{*}\QMARK{} {\em jmp-target}
\begin{indpar}
At run-time these instruction's actions are as described in
Figure~\mexref{JUMP-INSTRUCTIONS}, where the \TT{*}
option sets \TT{immedB} = 1 (otherwise it is 0).  At assembly-time,
these instructions first pop two elements from the variable stack,
then
call {\tt mexstack::\EOL push\_\EOL jmp\_instr}\mexnote{PUSH-JMP-INSTR}
to add an element to the pending jump list, then if \TT{*} is present
push the first element popped back onto the variable stack.

Note that
the pending jump list element
$S$ value is the length of the variable stack \underline{after}
the two elements are popped (and before any element is pushed back).
\end{indpar}

\ttkey{JMPTRUE}/\ttkey{JMPFALSE}/\ttkey{JMPNONE}/\ttkey{JMPINT}/%
    \ttkey{JMPFIN}/\ttkey{JMPINF}/\ttkey{JMPNUM}/\ttkey{JMPTRUTH}/%
    \ttkey{JMPSTR}/\ttkey{JMPOBJ} \\
\hspace*{1in}\ttkey{*}\QMARK{} {\em jmp-target}
\begin{indpar}
At run-time these instructions' actions are as described in
Figure~\mexref{JUMP-INSTRUCTIONS}, where the \TT{*}
option sets \TT{immedB} = 1 (otherwise it is 0).  At assembly-time,
these instructions first pop one element from the variable stack and
then call {\tt mexstack::\EOL push\_\EOL jmp\_instr}\mexnote{PUSH-JMP-INSTR}
to add an element to the pending jump list.

Note that
the pending jump list element
$S$ value is the length of the variable stack \underline{after}
the one element is popped.
\end{indpar}

\ttkey{JMPCNT} ~ {\em variable-name} ~ {\em number}\QMARK{} ~ {\em jmp-target}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{JUMP-INSTRUCTIONS}, where {\em variable-name}
names the stack location affected and {\em number} (defaults to
{\tt 1}) is the value of {\tt immedD}.
At assembly-time,
these instructions
call {\tt mexstack::\EOL push\_\EOL jmp\_instr}\mexnote{PUSH-JMP-INSTR}
to add an element to the pending jump list.
\end{indpar}

\ttkey{BEG} ~ {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
calls {\tt mexstack::begx}\mexnote{BEGX} to
increment the depth and set
{\tt stack\_limit}\mexnote{STACK-LIMIT}.
\end{indpar}

\ttkey{END} ~ {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.
At assembly-time,
calls {\tt mexstack::endx}\mexnote{ENDX} to
pop from the symbol table stack all elements with the
same lexical level and depth as the \TT{END} instruction, reset
{\tt stack\_limit} to its value when the companion
{\tt BEG} was encountered,
decrement the depth, and update the pending jmp list.
\end{indpar}

\ttkey{BEGL} ~ {\em nnext} ~ {\em trace-message}\QMARK{}
\begin{indpar}
Here {\em nnext} is the number of next variables
(see Next Variables and Loops, \mexref{NEXT-VARIABLES-AND-LOOPS}).
At run-time this instruction's action is as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS} with \TT{immedB} equal
to {\em nnext}.

At assembly-time, this instruction first checks that the
top {\em nnext} variable stack elements have the current lexical level
and depth and are not dummy variables.  It then adds
{\em nnext} to {\tt mexstack::stack\_length}, increments
the current depth, and outputs the instruction.
Lastly it pushes {\em nnext} variable stack elements with current lexical
level and depth
and with names derived from their {\em nnext}'th predecessor
in the stack by adding the prefix `\TT{next-}'\label{NEXT-VARIABLE}
to the predecessor's name.  These {\tt next-\ldots}~variables are
marked write-only, which allows them to be identified
as loop {\tt next-\ldots} variables by {\tt POP}.

Thus, for example, if the top two stack elements have names
\TT{X} and \TT{Y} and depth $D$, and {\em nnext} is \TT{2}, the two elements
pushed would have names \TT{next-X} and \TT{next-Y}, depth $D+1$,
and would be marked write-only.
\end{indpar}

\ttkey{ENDL}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
\TT{ENDL} does the same thing as \TT{END}.
\end{indpar}

\ttkey{CONT} ~ {\em loop\_depth}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction does nothing (i.e., it calls {\tt mexstack::cont}\mexnote{CONT}
which does nothing but fill in instruction fields and push the instruction
into the module code vector).

The {\tt mexstack::cont} function
searches the block stack for the {\em loop\_depth}'th {\tt BEGL ...~ENDL}
loop block and uses that to create an appropriate instruction.
{\tt Loop\_depth} defaults to {\tt 1}, which continues the innermost
loop (exiting any non-loop blocks inside the innermost loop).
A value of {\tt 2} would exit the innermost loop and continue
the next to innermost loop, etc.
\end{indpar}

\ttkey{BEGF}\label{BEGF} ~ {\em function-name} ~ {\em variable-name}\STAR{} ~
	{\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}, with the number
of {\em variable-names} as \TT{immedA} (the minimum number of
arguments expected).

At assembly-time, this instruction first adds
to {\tt mexstack::\EOL stack\_\EOL length}
the number of {\em variable-names},
increments the current lexical level, zeroes the current depth,
and outputs the instruction.  Then this instruction pushes
entries into the variable stack with the given {\em variable-names},
and pushes into the function stack
an element with the {\em function-name} and location of the {\tt BEGF}
instruction.

This instruction computes its {\tt trace-info}
consisting of the {\em trace-message} followed by the list of
{\em variable-names} (which are the function argument names).
This {\tt trace-info} is used at run-time by the
{\tt CALL\ldots} instruction to trace function
arguments\mexnote{CALL-TO-BEGF}.
\end{indpar}

\ttkey{ENDF} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.
At assembly-time,
calls {\tt mexstack::endx}\mexnote{ENDX} to
pop from the symbol table stack all elements with the
same lexical level as the \TT{ENDF} instruction,
restore 
{\tt stack\_limit} and
the current lexical level and depth to what they were before
the associated \TT{BEGF} instruction, and clear the pending jmp list.
\end{indpar}

\ttkey{CALLM} ~ {\em function-name} ~ {\em nargs} ~
        {\em variable-name}\STAR{} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS} with {\tt immedA} equal to
{\tt nargs} (the number of arguments).  At assembly-time,
it pops from the variable variable stack {\em nargs} variables
and pushes into the stack one element for each {\em variable-name}
(representing the results of the function execution).
The number of {\em variable-names} \underline{must} equal
the number of actual results.

The {\tt trace-info} for this instruction
consists of the {\em trace-message} followed by the list of
{\em variable-names} (which are the function result names).
This {\tt trace-info} is used at run-time by the
{\tt RET} or {\tt ENDF} instruction to trace the results
of the function\mexnote{RET-TO-CALL}.

The {\em function-name} is searched for in the function stack.
\end{indpar}

\ttkey{CALLG} ~ {\em module-name} ~ {\em function-name} ~
              {\em nargs} ~ {\em variable-name}\STAR{} ~
	      {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
the actions are the same as for \TT{CALLM}.

The {\em function-name} is searched for in the function stack of
the previously assembled module named, as it is at the
end of the compilation of that module (only level 1 functions
of the module are present in this stack).
\end{indpar}

\ttkey{CALL} ~ {\em function-name} ~
             {\em nargs} ~ {\em variable-name}\STAR{} ~
	      {\em trace-message}\QMARK{}
\begin{indpar}
This instruction searches for the {\em function-name} first in the function
stack and then in the function symbol table of the previously assembled
modules, in most recently assembled first order.  It then
assembles to \TT{CALLM} or \TT{CALLG}.
\end{indpar}

\ttkey{RET} ~ {\em nresults} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction pops {\em nresults} elements from the
variables stack.
\end{indpar}

\ttkey{PUSHOBJ} ~ {\em unused\_size}\QMARK{}
                ~ {\em hash\_size}\QMARK{}
                ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a new object with the
given {\em unused\_size} (\TT{immedA} value, default 32) and
{\em hash\_size} (\TT{immedC} value, default 8):
see Figure~\mexref{OBJECT-INSTRUCTIONS}.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{VPUSH} ~ {\em object-variable-name}
	\{ {\em attribute-label} $|$ \TT{NONE} \}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer, and
{\em attribute-label} specifies the \TT{immedD} value which is
a MIN string, label, or \TT{min::NONE()}
(default, \TT{min::MISSING()} which does NOT match \TT{min::NONE()}).

At assembly time, pops the variable stack.

The variable stack search for {\em object-variable-name} is restricted to
elements with the same lexical level as the \TT{VPUSH} instruction.
\end{indpar}

\ttkey{VPOP} ~ {\em object-variable-name} {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer.

At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em object-variable-name} is restricted to
elements with the same lexical level as the \TT{VPOP} instruction.
\end{indpar}

\ttkey{VSIZE} ~ {\em object-variable-name} {\em new-variable-name}\QMARK{}
\begin{indpar}
Same as \TT{VPOP} except the value pushed into the stack is the
size of the vector of the object.
\end{indpar}

\ttkey{GET} ~ {\em object-variable-name} {\em attribute-label-variable-name}
	      {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label-variable-name} specifies the variable containing the
attribute label value \EOL (\TT{immedC} value).
If {\em attribute-label-variable-name}
is \TT{*}, the attribute name is popped from the stack
(\TT{immedB} != 0, \TT{immedC} == 0).

At assembly time, pops one entry from the variable stack if the
{\em attribute-lable-variable-name} was \TT{*},
and then pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack searches for {\em object-variable-name} 
and {\em attribute-label-variable-name} are restricted to
elements with the same lexical level as the \TT{GET} instruction.
\end{indpar}

\ttkey{GETI} ~ {\em object-variable-name} {\em attribute-label}
	       {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label}\pagnote{ATTRIBUTE-LABEL}
names the attribute (\TT{immedD} value).

At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em object-variable-name} 
is restricted to
elements with the same lexical level as the \TT{GETI} instruction.
\end{indpar}

\ttkey{SET} ~ {\em object-variable-name} {\em attribute-label-variable-name}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label-variable-name} specifies the variable containing the
attribute label value \EOL (\TT{immedC} value).
If {\em attribute-label-variable-name} is \TT{*},
the attribute label is popped from the stack
(\TT{immedB} != 0, \TT{immedC} == 1).

At assembly time, pops the variable stack twice if
{\tt attribute-label-variable-name} is \TT{*}, or once otherwise.

The variable stack searches for {\em object-variable-name} 
and {\em attribute-label-variable-name} are restricted to
elements with the same lexical level as the \TT{SET} instruction.
\end{indpar}

\ttkey{SETI} ~ {\em object-variable-name} {\em attribute-label}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label} names the attribute being written
(\TT{immedD} value).

At assembly time, pops the variable stack once.

The variable stack search for {\em object-variable-name} 
is restricted to
elements with the same lexical level as the \TT{SETI} instruction.
\end{indpar}

\ttkey{PUSHNARGS} ~ {\em level}\QMARK{} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{STACK-INSTRUCTIONS} with \TT{immedB} set
to the lexical level specified by {\em level} (see \pagref{LEVEL}).
At assembly-time,
this instruction pushes into the variable stack an element
with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{PUSHV} ~ {\em level}\QMARK{} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\mexref{STACK-INSTRUCTIONS} with \TT{immedB} set
to the lexical level specified by {\em level} (see \pagref{LEVEL}).

At assembly-time, this instruction first pops an element from the
variable stack, and then pushes into the variable stack an element
with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{SET\_TRACE} ~ \{ {\em trace-class} $|$ {\em trace-class-group} \}\STAR{}%
\label{SET-TRACE}
\begin{indpar}
At run-time set the process \TT{trace\_flags} parameter so as
to have a flag for each {\em trace-class} given, or each trace class
in a given {\em trace-class-group}.  This instruction itself has
the \TT{ALWAYS} trace class.
See Instruction Tracing\mexnote{INSTRUCTION-TRACING} for details.

At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{NOP}/\ttkey{TRACE}/\ttkey{WARN}/\ttkey{ERROR} ~
    {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time these instructions do nothing except produce trace messages
(if there is a {\em trace-packet}),
except that the \TT{ERROR}
instruction terminates the process
(see Figure~\mexref{HOUSEKEEPING-INSTRUCTIONS}).  At assembly-time,
these instructions do nothing.

All these instructions except \TT{NOP} are in the \TT{ALWAYS}
trace class.
\end{indpar}

\ttkey{SET\_EXCEPTS} ~ {\em except-name}\STAR{}
\begin{indpar}
At run-time set the process \TT{excepts\_mask} parameter so as
to have a flag for each named except.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{SET\_OPTIMIZE} ~ \{ \TT{ON} $|$ \TT{OFF} \}
\begin{indpar}
At run-time set the process \TT{optimize} parameter on or off.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{TRACE\_EXCEPTS}
\begin{indpar}
At run-time, this instruction is just traced as specified
in Other Instruction Trace Messages,
\mexref{OTHER-INSTRUCTION-TRACE-MESSAGES}.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{TEST\_INSTRUCTION} ~
    \begin{tabular}[t]{@{}l@{}}
    {\em op-code} ~ {\em trace-class}\QMARK{}
                  ~ \{ \TT{[} {\em trace-depth} \TT{]} \}\QMARK{}
		  ~ \TT{\textbackslash} \\
    {\em immedA} ~ {\em immedB} ~ {\em immedC} ~ {\em immedD} \\
    \end{tabular}
\begin{indpar}
Fields may be omitted from the end of the instruction.

Outputs an instruction with the given fields, and does nothing
else at assembly time.  Used for testing \TT{FORMAT\_ERROR}
and \TT{JMP\_ERROR},
since otherwise such errors are (seem to be, should be) impossible
because of assembler checks.

The {\em op-code} and {\em trace-class} are names.
{\em immedD} may be a number,
{\em attribute-label}\pagnote{ATTRIBUTE-LABEL} (includes strings),
module name, or one of the special value names
\TT{TRUE} for {\tt mex::TRUE}, \TT{FALSE} for {\tt mex::FALSE},
or \TT{NONE} for {\tt min::NONE()}.
The other fields are integers in the range $[0,2^{32})$.
\end{indpar}

\section{MEXAS Declarations}
\label{MEXAS-DECLARATIONS}

\ttkey{LABEL}\label{LABEL} ~ {\em jmp-target}
\begin{indpar}
This statement just calls {\tt mexstack::jmp\_target}\mexnote{JMP-TARGET}
with the given {\em jmp-target} name.
\end{indpar}

\ttkey{STACKS}
\begin{indpar}
Prints the names in the assembly time symbol table stacks.
Each name is preceeded by `{\tt $L$.$D$}' where $L$
it the name's lexical level and $D$ is the name's depth.
Used mostly for testing the assembler.
\end{indpar}


\section{The MEXAS Program}
\label{THE-MEXAS-PROGRAM}

The \key{MEXAS program} executes {\em mexas-operations} that
appear in its arguments.  The syntax is:

\begin{indpar}
\emkey{MEXAS-command} ::= \ttkey{mexas} ~ {\em mexas-operation}\STAR{}
\\[0.5ex]
\emkey{mexas-operation} ::= \\
\hspace*{3em}\begin{tabular}[t]{l@{~~~~~}l}
    \emkey{mexas-filename}		& [assemble the file] \\
    \ttkey{-pa} 			& [print assembled instructions] \\
    \ttkey{-pasource}			& [ditto and include source lines] \\
    \ttkey{-paoff}			& [do not print
                                           assembled instructions] \\
    \ttkey{-tcnever}			& [assemble with \TT{NEVER}
                                           trace class] \\
    \ttkey{-tcnormal}			& [assemble with normal trace class] \\
    \ttkey{-tc:}{\em tc-list}		& [set process {\tt trace\_flags}] \\
    \ttkey{-ex:}{\em ex-list}		& [set process {\tt excepts\_mask}] \\
    \ttkey{-o:on}			& [set process optimize on] \\
    \ttkey{-o:off}			& [set process optimize off] \\
    \ttkey{-counter} $L$		& [set process instruction
                                           {\tt counter\_limit}] \\
    \ttkey{-stack} $L$		        & [set process stack size] \\
    \ttkey{-return-stack} $L$	        & [set process return stack size] \\
    \ttkey{-test} $L$	        	& [set process test counter] \\
    \ttkey{-r} {\em function-name}	& [run named function] \\
    \end{tabular}
\\[0.5ex]
\emkey{tc-list} :::= $|$ {\em trace-class-or-group}
                         \{ \TT{,} {\em trace-class-or-group} \}\STAR{} \\
\emkey{trace-class-or-group} :::= {\em trace-class} $|$ {\em trace-group} \\
\emkey{trace-class} :::= trace class
    listed in Figure~\mexref{TRACE-CLASSES-AND-GROUPS} \\
\emkey{trace-group} :::= trace group
    listed in Figure~\mexref{TRACE-CLASSES-AND-GROUPS} \\
\\[0.5ex]
\emkey{ex-list} :::= $|$ {\em exception} \{ \TT{,} {\em exception} \}\STAR{} \\
\emkey{exception} :::= except listed on Figure~\mexref{EXCEPTIONS}

\end{indpar}

Note that the symbol :::= is used to indicate that syntactic components
can\underline{not} be separated by whitespace, whereas ::= indicates
that components can and often should be separated by whitespace.

A {\em mexas-operation} is effective for all subsequent
{\em mexas-operations} until it is overridden.  E.g.,
\TT{-o:on} will cause following all executions to be optimized
until an \TT{-o:off} is encountered.

Details are:
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
{\em mexas-filename} & Name of file, usually ending in \TT{.mex}, containing
                      instructions as described in
                      MEXAS Instructions, \itemref{MEXAS-INSTRUCTIONS}.
		      The file is assembled as a module and given the
		      filename minus any \TT{.mex} extension as its
		      module name.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\begin{tabular}[t]{@{}l@{}}
\TT{-pa} \\
\TT{-pasource} \\
\TT{-paoff} \\
\end{tabular}	    & Determines whether an instruction is printed after
                      it is assembled, and if so, whether source lines
		      from the file are printed before the instruction.
		      Default is \TT{-paoff}.
		      See {\tt mexstack::print\_instr}\mexnote{PRINT-INSTR}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-tcnever}	    & Determines the trace class of an assembled instruction. \\
\label{-TCNEVER}
\TT{-tcnormal}	    & \TT{-tcnormal} sets the trace class of an op code
                      to that
		      given by Figure~\mexref{TRACE-CLASSES-AND-GROUPS}.
                      \TT{-tcnever} sets the class to \TT{NEVER} unless
		      the normal instruction trace class is \TT{ALWAYS}.
		      Default is \TT{-tcnormal}.
\\[0.5ex]
\TT{-tc:}{\em tc-list} \label{-TC:}
		    & Sets the process \TT{trace\_flags}\mexnote{TRACE-FLAGS}
		      at the start of mex
		      program execution.  \TT{ALWAYS} and \TT{NEVER}
		      can\underline{not} be listed: their flags are always
		      on and off, respectively.
		      Default is \TT{-tc:NONE}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-ex:}{\em ex-list}
		    & Sets the process \TT{excepts\_mask}\mexnote{EXCEPTS-MASK}
		      at the start of mex
		      program execution.  Default is: \\
		    & ~~~~~~~~~~\TT{-ex:DIVBYZERO,INVALID,OVERFLOW}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\begin{tabular}[t]{@{}l@{}}
\TT{-o:off} \\
\TT{-o:on} \\
\end{tabular}	    & Sets the process \TT{optimize} flag\mexnote{OPTIMIZE}
                     \TT{on} or \TT{off}
                      at the start of mex program execution.
		      Default is \TT{-o:off}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-counter} $L$   & Sets the process
                      \TT{counter\_limit}\mexnote{COUNTER-LIMIT}
		      to integer $L$.
\\[0.5ex]
\TT{-stack} $L$	    & Sets the process \TT{max\_length} (stack size)
                      to integer $L$.
\\[0.5ex]
\TT{-return-stack} $L$
		    & Sets the process \TT{return\_stack->max\_length}
		      (return stack size) to integer $L$.
\\[0.5ex]
\TT{-test} $L$
		    & Sets the process \TT{test} counter to $L$.
		      This allows $L$ fatal errors to be output by
		      making each transgressing instruction into
		      a no operation.  Used only to test detection
		      of program errors that are really compiler
		      bugs.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-r} {\em function-name}
                    & Calls the named function, which must be of lexical
		      level 1 in some previously assembled module.
		      To find the function, the name is searched for
		      in the modules, most recently assembled module first.
\\[0.5ex]
		    & The function must take no arguments and return no
		      results.
\end{tabular}\end{indpar}

\clearpage

\printindex

\end{document}
