% Minimal Runtime System Execution Engine
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage{xr}
\externaldocument{mexas}

\input{mex-macros}

\begin{document}
        
\title{Minimal Run-time System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Version 4)}

\author{Robert L. Walton}

\date{January 13, 2025}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Run-time System Execution Engine.

MEX is layered on top of the MIN Minimal Run-time System.

MEX is stack-oriented and block-oriented.  It computes with
\ttkey{min::gen} values.

References to pages in this document have the form p\# (e.g., p5)
whereas references to pages in the MEX Assember (MEXAS) document have the
form mexas\# (e.g., mexas13).

\section{Abbreviations}
\label{ABBREVIATIONS}

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{ap}{abbreviation}	& argument pointer \\
\ttmkey{except}{abbreviation}	& exception \\
\ttmkey{fp}{abbreviation}	& frame pointer \\
\ttmkey{immed}{abbreviation}	& immediate \\
\ttmkey{info}{abbreviation}	& information \\
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{jmp}{abbreviation}	& jump (go to) \\
\ttmkey{nargs}{abbreviation}	& number of arguments \\
\ttmkey{nresults}{abbreviation}	& number of results \\
\ttmkey{nnext}{abbreviation}	& number of loop next variables \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{ret}{abbreviation}	& return \\
\ttmkey{sp}{abbreviation}	& stack pointer \\
\end{tabular}
\end{indpar}

In addition abbreviations of the MIN Run-time System are used
in names of types and functions of that system.

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test files such as \TT{Makefile} and
                               \TT{mex\_compile\_test\_1.mex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}

MEX is layered on top of MIN, the Minimal Run-time System, and
includes \ttkey{min.h}.

The C++ data and functions of MEX can be
accessed by C++ code that contains the following inclusion:

\begin{center}\ttindex{mex.h}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable vector.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, it is loaded into memory
ready for execution.  There are no MEX `binary' files.

Interfaces are provided by and used by the compiler, and
not by MEX.  Typically a module may reference interfaces
of previously compiled modules.

Immediately after a module is compiled, it is executed.  A copy of the
resulting execution stack (see Stacks, \itemref{STACKS}) becomes the
module's \key{global variable vector}, i.e., its vector of
global variables.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector
and variables are added to the end of
the module's global variable stack.  The compiler should add
interfaces to new global variables and new module functions, but
this is a matter for the compiler, and not for MEX.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called
the function code block instructions are executed.  A function
can itself contain another function.

MEX does \underline{not} itself provide a compiler, but it
assumes a few compilation behaviors.

\section{Stacks}
\label{STACKS}

MEX is stack oriented.  A \key{stack} is a vector of
elements.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Elements may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector. The length of the stack is referred to as the
\key{stack pointer} and is one greater than the vector index of the top of
the stack, unless the stack is empty and its vector length is zero.

The word `stack' without qualification refers to the main
\key{process stack}\label{PROCESS-STACK},
which is a stack of \TT{min::gen} variable values.
MEX supports the programming paradigm
in which variables in this stack are read-only, unless
they are being assigned values by a block of code.  Using this paradigm
variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values that code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.  MEX assumes that to allow
a form of variable update the compiler implements `next variables'
as described in Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.
The arguments and all the values the function pushes into the
stack are called the function's \key{frame}.  The stack pointer
value when the function begins is called the function's
\key{frame pointer}, and points just after the last argument
of the function.  The pointer to the first argument is called
the \key{argument pointer}.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and then pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, the module's
global variable vector is created by making
a copy of the final execution stack.

Backward jumps are only allowed at the end of a loop blocks.
These pop the values pushed into the stack by the loop block.
Forward jumps can be used to exit any block and
are the only means of exiting a loop block.  These
pop all values pushed into the stack by blocks that are exited.

There are special considerations involving the stack if the
compiler allows functions to be nested inside other functions.
These considerations are described in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

\subsection{Next Variables and Loops}
\label{NEXT-VARIABLES-AND-LOOPS}

MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler re-points the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\label{EXAMPLE-LOOP}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and re-point the names {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the compiler will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such values
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Nested Functions}
\label{NESTED-FUNCTIONS}

MEX assumes that any compiler compiling into MEX code follows the
rules of lexical scoping.  For our purposes these are as follows.
The compiler maintains a stack of visible variables and a separate
stack of visible functions.  When the compiler outputs a {\tt PUSH\ldots}
instruction that creates a variable, it pushes the name of the variable
into the stack of visible variables (not all {\tt PUSH\ldots} instructions
create new variables).  When the compiler outputs a {\tt BEGF}
instruction that creates a function, it pushes the name of the function
into the stack of visible functions.  Instructions output by the compiler
that read a variable value can only read visible variables, and 
instructions that call a function can only call visible functions.
When a block end instruction ({\tt ENDF}, {\tt ENDL}, or {\tt END}) is
output, the visible variables and visible functions stacks are popped to
remove all variables and functions defined within the block just ended.%
\footnote{The compiler variable and function stacks are stacks but they
are also symbol tables that allow variables and functions to be looked
up by name.  Also, the variable and function stacks may be combined into
a single symbol table.}

The \key{lexical level}\label{LEXICAL-LEVEL}
of a function is defined as follows.

If the function $F$ is not inside any other function, $F$ has
level 1.

If the function $F$ is inside a function and $F'$ is the smallest
function lexically containing $F$, and if $F'$ has level $L'$, then $F$
has level $L=L'+1$.

If $F$ is a function lexically inside another function $F'$, then instructions
in $F$ can reference the variables of $F'$ that could be referenced by
an instruction located where $F$ is defined.
To locate these variables, knowing the frame pointer and argument
pointer for the
execution of $F'$ is sufficient.  The frame pointer is the
stack pointer when $F'$ is called, and this points just after the last
argument to $F'$.  The argument pointer is
the pointer to the first argument for $F'$ when $F'$ is called.

So how do we compute the frame and argument pointers of $F'$?  To see how,
we need to analyze the situation in more detail.

We define the level of an instruction to be the level of the
smallest function lexically containing the instruction, or \TT{0} if the
instruction is not lexically inside any function.

\begin{indpar}
{\bf Lemma 1}\label{LEMMA-1}~~~An execution of a \TT{CALL\ldots} instruction of
level $L$ must call a function of level $L'\leq L+1$.
\end{indpar}
\begin{indpar}
{\bf Proof}: To be visible to the \TT{CALL\ldots}
instruction, a function must be either defined within functions
lexically containing the \TT{CALL\ldots} instruction, in which case the
function cannot have a level greater than $L+1$, or the function must be global,
in which case it has level \TT{1}.  QED
\end{indpar}

Let $E$ be the sequence of instruction executions in an
incomplete program execution.
An execution of a function $F$ within $E$ is defined as all the
instruction executions from the first instruction execution
after $F$ is called until and including the instruction that returns
from $F$, or until the last instruction of $E$ if there is no return
instruction for the function execution in $E$.
A function execution can be complete, meaning
it ends with a return from the function, or incomplete.  A function execution
$E_i$ contains the function executions of every function called by
a \TT{CALL\ldots} instruction execution in $E_i$.

The lexical level of a function execution is defined as the lexical level
of its function.

The \underline{incomplete} function executions in $E$ are ordered by size, and
identically ordered by the sequence of their first instruction executions.
(This is the same order as the order of their return stack entries
as per the description of \TT{CALLM} and \TT{RET} in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}).

\begin{indpar}
{\bf Corollary 1 of Lemma 1}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of lexical levels
$L_1$ and $L_2$.  Let $E_2$ immediately follow $E_1$ in the size
ordering.  Then $L_2\leq L_1+1$.
\end{indpar}
\begin{indpar}
{\bf Proof}: The \TT{CALL\ldots} instruction that starts $E_2$ must be
inside the function of $E_1$, as $E_2$ is incomplete
and $E_2$ immediately follows $E_1$ in the set of incomplete
function executions.  Therefore this call has level $L_1$ and
the corollary follows from Lemma 1. QED
\end{indpar}

\begin{indpar}
{\bf Corollary 2 of Lemma 1}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of lexical levels
$L_1$ and $L_2$, let $E_2\subset E_1$, and let $L_2>L'>L_1$.
Then there must be an incomplete function execution $E'$ in $E$
that is in between $E_1$ and $E_2$ in the sequence of incomplete function
executions of $E$ and that has level $L'$.
\end{indpar}
\begin{indpar}
{\bf Proof}: Stepping through the sequence from $E_1$ to $E_2$,
the levels at each step can increase by at most $1$ (by Corollary 1),
so no level can be skipped over.  QED.
\end{indpar}

\begin{indpar}
{\bf Lemma 2}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of functions $F_1$ and $F_2$ which have levels $L_1$ and $L_2$
and let  $E_2$ immediately follow $E_1$ in the size
ordering.  If further there is a function $F$ of level $L$ that lexically
contains $F_1$ ($F=F_1$ is allowed), and if $L_2>L$, then $F$ lexically contains
$F_2$.
\end{indpar}
\begin{indpar}
{\bf Proof}: The \TT{CALL\ldots} instruction that starts $E_2$ must be
inside $F_1$, as $E_2$ is incomplete
and $E_2$ immediately follows $E_1$ in the set of incomplete
function executions.
This \TT{CALL\ldots}
is therefore lexically inside $F$ by hypothesis, and the only functions visible
to the \TT{CALL\ldots} that have levels $>L$ are also inside $F$.
Therefore $F_2$ is lexically inside $F$.
\end{indpar}

\begin{indpar}
{\bf Theorem}~~~If $F'$ is the unique function of level $L' < L$ that lexically
contains function $F$ of level $L$,
then during the execution of instructions in $F$ (and not in any other
function defined inside $F$),
there is a smallest incomplete execution of $F'$ and this is also
the smallest incomplete function execution of level $L'$.
\end{indpar}

\begin{indpar}
{\bf Proof of Theorem}: Since the currently executing instruction is in $F$
it is in the smallest incomplete function execution, and this has level $L$.
The largest incomplete function execution
has level $1$, the smallest
incomplete function execution has level
$L$, and by hypothesis $1\leq L'<L$,
so by Corollary 2 there is an incomplete function execution of level $L'$
and hence a smallest one $E'$.  Let $F''$ be its function.
If we can prove that $F''$ lexically contains $F$, then we will be done,
since there is only one function of level $L' < L$ that contains $F$,
so we would have $F'' = F'$.

First, all the incomplete function executions after $E'$ in the sequence
of incomplete function executions
must have lexical level $>L'$.  For if one had level $L'$, $E'$ would
not be the smallest such, and if one had level $<L'$, applying Corollary 2
to it and the smallest incomplete function execution which has level $L$ would
yield an incomplete function execution of level $L'$ that was 
smaller than $E'$.

Then by applying Lemma 2 recursively to successive incomplete function
executions after $E'$, we deduce that all are executions of functions
lexically inside $F''$, and therefore $F''$ is a function of
level $L'$ lexically containing $F$ (which is the function of the
last incomplete execution).  As the function of level $L'$
that lexically contains $F$ is unique, $F''=F'$.

QED
\end{indpar}


During execution MEX computes \TT{fp[$L'$]} as the frame pointer
of the smallest (most recently called)
incomplete function execution of level $L'$,
and therefore
during the execution of instructions in $F$, \TT{fp[$L'$]} is the
frame pointer of $F'$.
Similarly MEX computes \TT{ap[$L'$]} as the argument pointer of
the smallest incomplete execution of level $L'$.

If follows that during an execution of an instruction in $F$
the variables of $F'$ can be accessed by
\TT{PUSHL} with \TT{immedB} = $L'$
(Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}),
and the arguments of $F'$ can be
accessed by \TT{PUSHA} with \TT{immedB} = $L'$
(Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}).
MEX sets \TT{fp[0] = 0},
so the global variables can be accessed by \TT{PUSHL} with \TT{immedB} = $0$
or by \TT{PUSHG}
(Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}).

\section{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em stack-and-flow-control-instruction} \\
		  $|$ & {\em block-and-function-instruction} \\
		  $|$ & {\em object-instruction} \\
		  $|$ & {\em stack-and-housekeeping-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction} ::= \\
\hspace*{3em}
    instructions in Figure \itemref{ARITHMETIC-INSTRUCTIONS}
\\[0.5ex]
\emkey{stack-and-flow-control-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
\\[0.5ex]
\emkey{block-and-function-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS},
     except for \TT{BEG\ldots} and \TT{END\ldots} instructions
\\[0.5ex]
\emkey{object-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{OBJECT-INSTRUCTIONS}
\\[0.5ex]
\emkey{stack-and-housekeeping-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{instr}\verb|          // Instruction|
\LABEL{MEX::INSTR} \\
\verb|{                   | \\
\verb|    min::uns8 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_class}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_depth}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{unused}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::module\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::module\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::module\_header}} \\
\verb|    min::gen | & \TTMKEY{name}{in {\tt mex::module\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::module\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::module\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::module\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{trace\_info}
                                              {in {\tt mex::module\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module\_ins}
\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttmkey{name}{of module} member of the \TT{module} is derived
from the module's file name by removing any \TT{.mex} extension.
If the module is input from the standard input, and not a file,
the \TT{name} is \TT{min::MISSING()}.

The \ttmkey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module} (may be \TT{min::MISSING()} if input was
from standard input).  In particular, the \TT{min::phrase\_\EOL position}
of instruction \TT{m[i]} is \TT{m->position[i]}.
This information can be used to
print trace and error messages.

The \ttmkey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code
(initializing the module).
This stack contains values of global variables exported by the module.

The \ttmkey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.

The \ttmkey{trace\_info}{of module} member of the \TT{module} points
at a vector of \TT{min::gen} values such that for module \TT{m},
\TT{m->\EOL trace\_\EOL info[i]} gives information that can be used
to print trace messages for instruction \TT{m[i]}.  See
Instruction Tracing, \itemref{INSTRUCTION-TRACING}.

\section{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
a return stack, and other parameters.  Specifically:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{pc}\verb|          // Program Counter|%
\LABEL{MEX::PC} \\
\verb|{                   | \\
\verb|mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::|
    & \MEXKEY{ret}\verb|          // Return Stack Entry|%
\LABEL{MEX::ret} \\
\verb|{                   | \\
\verb|mex::pc | & \TTMKEY{saved\_pc}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_level}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_fp}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_ap}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{nresults}{in {\tt mex::ret}} \\
\verb|}                   | \\
\end{tabular}
\\[1ex]
\verb|const unsigned mex::|\MEXKEY{max\_lexical\_level}\verb| = 16|%
\LABEL{MEX::MAX_LEXICAL_DEPTH}
\\[1ex]
\begin{tabular}{@{}r@{}l}
\verb|struct                         mex::| & \MEXKEY{process\_header}%
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                   | \\
\verb|min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|min::printer | & \TTMKEY{printer}{in {\tt mex::process\_header}} \\
\verb|mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|min::packed_vec_insptr<mex::ret> | & \TTMKEY{return\_stack}%
                                              {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{level}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{fp}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{ap}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{trace\_depth}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{trace\_flags}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_mask}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_accumulator}%
                         {in {\tt mex::process\_header}} \\
\verb|bool | & \TTMKEY{optimize}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{optimized\_counter}%
                         {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter\_limit}{in {\tt mex::process\_header}} \\
\verb|mex::state | & \TTMKEY{state}%
                                   {in {\tt mex::process\_header}} \\
\verb|}                                    | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|enum         mex::| & \MEXKEY{state}%
\LABEL{MEX::STATE} \\
\verb|{                 | \\
\verb|mex::| & \TTMKEY{NEVER\_STARTED}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RUNNING}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{MODULE\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{CALL\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{COUNTER\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{STACK\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RETURN\_STACK\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{ERROR\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{JMP\_ERROR}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{FORMAT\_ERROR}{in {\tt mex::state}} \\
\verb|}                 | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}

\end{indpar}

A \TT{mex::process} \TT{p} is a vector of \TT{min::gen} elements which
is the process \key{stack}, with the last element being the top
of the stack (\TT{p[p->length-1]}) and the first element
being the bottom of the stack (\TT{p[0]}), assuming the stack
is not empty.  The \key{stack pointer} (a.k.a., \TT{sp})
is \TT{p->length}, and is the index of an element of
the process vector which is just beyond the top of the stack,
and is also the length of the stack.

To push a value into the stack,
you store the value in the element \TT{p->length}
indexes, and then add +1 to \TT{p->length}.
To pop a value, you add -1 to \TT{p->length}, and then
read the value indexed by \TT{p->length}.
We require that \TT{0 <= p->length <= p->max\_length} at all times,
and \underline{never} increase \TT{p->max\_length} during execution
(but see Note~\ref{LIMIT-STOP-NOTE} on page~\pageref{LIMIT-STOP-NOTE}).

A \ttkey{pc}, or \key{program counter}, is a pointer to a module,
which is a code vector, and an index in that vector of an instruction.
Thus a \TT{pc} points at an instruction.  The \TT{pc} member of a
process (\TT{p->pc}) is the \key{current program counter} of that process.

The value of \TT{p->level} is the current lexical level of the
process, i.e., the lexical level of the instruction pointed at
by \TT{p->pc}.  \TT{p->fp[$L$]} is the frame pointer for the
most recently started currently executing function of level $L$,
and \TT{p->ap[$L$]} is argument pointer (pointer at first argument)
for this function.
Note that the list of currently executing functions
in order of being called is \underline{not} monotonic in level: a function
of level $L$ may call a function of level $\leq L+1$.

The actual number of arguments to the most recent
currently executing function of
level $L$ is:
\hspace*{1in}\TT{p->fp[$L$] - p->ap[$L$]} \\
\TT{p->ap[$L$]} points at the first argument and
\TT{p->fp[$L$]} points just \underline{after} the last argument.
Arguments are pushed into the stack in left-to-right lexical
order.\footnote{Unlike languages which do not have an argument
pointer separate from the frame pointer.}

The process's frame pointer member \TT{fp[\ldots]}
and argument pointer member \TT{ap[\ldots]}
are further explained in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

The value of \TT{fp[0]}, the frame pointer
for lexical level \TT{0} (outside all functions), is always \TT{0}.

The \ttkey{return\_stack} is used by \TT{CALL} and \TT{RET}
instructions.  The value of \TT{return\_stack->\EOL length},
a.k.a.~the \key{return stack pointer}, is the index of the element of
the return stack which is just beyond the top of the stack,
and is also the length of the stack.  If the stack is not empty,
\TT{p->return\_stack[return\_stack->length-1]} is the top of the stack.

A \TT{CALL} instruction pushes a \TT{mex::ret} value
into the return stack.  This contains a \TT{saved\_pc} member
pointing at the \TT{CALL} instruction.
A \TT{RET} instruction pops a \TT{mex::ret} value from
the \TT{return\_stack} and stores its \TT{saved\_pc}
in the current program counter
of the process (\TT{p->pc}), and then increments that program counter
by \TT{1}.

The \TT{CALL} also changes the process \TT{level} to the lexical level
of the function being called (determined by the function's \TT{BEGF}
instruction) and if this level is $L$, changes \TT{fp[$L$]} to the
frame pointer of that function and \TT{ap[$L$]} to the argument pointer
of that function.  Before making changes the \TT{CALL}
saves these values in the \TT{mex::ret} value.
The \TT{nresults} member of \TT{mex::ret}
is the number of function results expected by the call.
See the \TT{CALL} instruction in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}
for specifics.

The process's \TT{counter} is incremented once every time an instruction
finishes execution.  The process stops when
\TT{counter >= counter\_\EOL limit}\label{COUNTER-LIMIT}.
The \TT{optimized\_counter}
is incremented (along with the \TT{counter})
for every instruction executed in optimize mode;
it has no limit and is for information purposes only.

When the process terminates, \TT{state} is set.  For details
see \TT{mex::run\_process}, \pagref{MEX::RUN_PROCESS},

A process runs in \key{optimized} or \key{non-optimized} mode
according to the setting of the process's \TT{optimize} member.
Optimized execution is faster but surpresses tracing.
However, if the next instruction in optimized mode would have
any error, the instruction is executed in non-optimized mode.

The \TT{trace\_depth}, \TT{trace\_flags}, \TT{excepts\_mask}, and
\TT{excepts\_accumulator}
members of a process
are explained in
Instruction Tracing \itemref{INSTRUCTION-TRACING}
and Arithmetic Exceptions \itemref{ARITHMETIC-EXCEPTIONS}.


\section{Instructions}
\label{INSTRUCTIONS}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code}, \TT{trace\_class}, \TT{trace\_\EOL depth},
and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.
\TT{Trace\_class} is explained in Instruction Tracing,
\itemref{INSTRUCTION-TRACING}, and
\TT{trace\_depth} is explained in Trace Depth,
\itemref{TRACE-DEPTH}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD, mex::T_AOP};
    // Pop 2 values and push their sum.
    // mex::T_AOP is the trace class of all arithmetic
    // operations.
mex::instr an_add_immediate_instruction =
        {mex::ADDI,mex::T_AOP,,,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG, mex::T_BEG};
    // Do nothing. (Marks block beginning for compiler.)
mex::instr an_end_instruction = {mex::END,mex::T_END,,,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,mex::T_JMP,1,,10,,32};
    // Pop 10 values and discard them, then decrement the process's
    // trace_depth by 1, then add 32 to program counter to skip
    // 32 instructions.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\itemref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations and the C \TT{math.h}
library are used.  See Arithmetic Exceptions,
\itemref{ARITHMETIC-EXCEPTIONS} for error
handling.

The stack and flow control instruction set is in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
See Stacks, \itemref{STACKS}, for an overview of stack handling.

The block and function instruction set is in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.
See Nested Functions, \itemref{NESTED-FUNCTIONS},
for details concerning nested functions.

The object instruction set creates and modifies MIN objects.
See Figure~\itemref{OBJECT-INSTRUCTIONS}.

The stack and housekeeping instruction set is in
Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}.

Some instructions use the values of the following parameters to represent
the logical values `true' and `false':

\hspace*{0.3in}\begin{tabular}{rll}
\tt min::gen mex::& \ttkey{FALSE} & \tt // Default: min::FALSE(). \\
\tt min::gen mex::& \ttkey{TRUE}  & \tt // Default: min::TRUE().  \\
\end{tabular}

\pagebreak


\begin{boxedfigure}[p!]

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{ADD}/\ttkey{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\ttkey{ADDI}
    & Adds \TT{immedD} to the top value.
\\\hline
\ttkey{MULI}
    & Multiplies the top value by \TT{immedD}.
\\\hline
\ttkey{SUB}/\ttkey{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\ttkey{SUBI}
    & Subtract \TT{immedD} from the top value.
\\\hline
\ttkey{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\ttkey{DIV}/\ttkey{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\ttkey{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\ttkey{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\ttkey{MOD}/\ttkey{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first popped divided by \\
    & the first/second popped.
\\\hline
\ttkey{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\ttkey{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\ttkey{POW}/\ttkey{POWR}
    & Pop 2 values, then push the second/first popped to the \\
    & first/second popped power.
\\\hline
\ttkey{POWI}
    & Replace the top value by the the top value to the \\
    & \TT{immedD} power.
\\\hline
\ttkey{POWRI}
    & Replace the top value by \TT{immedD} to the top value power.
\\\hline
\ttkey{LSH}/\ttkey{LSHI}/\ttkey{RSH}/\ttkey{RSHI}
    & Pop 2 values, then push the second popped times 2 to the \\
    & first/\TT{immedD}/minus-first/minus-\TT{immedD} power.
\\\hline
\ttkey{FLOOR}/\ttkey{CEIL}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward minus/plus infinity.
\\\hline
\ttkey{TRUNC}/\ttkey{ROUND}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward zero/the-nearest-integer, \\
    & with nearest halfway cases rounded to the even integer.
\\\hline
\ttkey{NEG}/\ttkey{ABS}
    & Replace the top value by its negation/absolute-value.
\\\hline
\ttkey{LOG}/\ttkey{LOG10}
    & Replace the top value by its log base e/10.
\\\hline
\ttkey{EXP}/\ttkey{EXP10}
    & Replace the top value by e/10 to the top value power.
\\\hline
\ttkey{SIN}/\ttkey{COS}/\ttkey{TAN}
    & Replace the top value by its sin/cos/tan.
\\\hline
\ttkey{ASIN}/\ttkey{ACOS}/\ttkey{ATAN}
    & Replace the top value by its arc- sin/cos/tan.
\\\hline
\ttkey{ATAN2}/\ttkey{ATAN2R}
    & Pop 2 values, then push the arc-tangent of the second/first \\
    & popped (y value) divided by the first/second popped \\
    & (x value).
\\\hline
\end{tabular}
\end{center}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\pagebreak

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{PUSHS}
    & Read the value at \TT{sp[- immedA - 1]} and push it into the \\
    & stack; so \TT{immedA} = 0 duplicates the top value.
\\\hline
\ttkey{PUSHL}
    & Read the value at \TT{fp[immedB] + immedA} and push it into the \\
    & stack.  But if \TT{immedB == 0} and \TT{m->globals} is not \TT{min::} \\
    & \TT{NULL\_STUB} for the module \TT{m} of the current program counter, \\
    & push \TT{m->globals[immedA]} instead.  Note \TT{fp[0] == 0}.
\\\hline
\ttkey{PUSHI}
    & Push \TT{immedD} into the stack.  \TT{immedD} should \underline{not} be \\
    & a modifyable value like a non-public object.
\\\hline
\ttkey{PUSHG}
    & Push \TT{m->globals[immedA]} into the stack, where \TT{m} is \\
    & the module pointed at by \TT{immedD}
\\\hline
\ttkey{POPS}
    & Store the top value in the stack into \TT{sp[- immedA - 1]}, and \\
    & then pop the stack once; so \TT{immedA} = 0 discards the top value.
\\\hline
\ttkey{DEL}
    & Delete from the stack the \TT{immedC} values just below the top \\
    & \TT{immedA} values.  \TT{immedC} == 0 does nothing.
\\\hline
\ttkey{JMP}
    & Subtract \TT{immedA} from \TT{sp} (popping the stack \TT{immedA} times),
      \\
    & then add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
      \\
    & It is illegal for \TT{immedC} = 0 (\TT{JMP} would jump to itself).
\\\hline
\ttkey{JMPEQ}/\ttkey{JMPNEQ}
    & Pop 2 values and compare them.  If they are \TT{==}/\TT{!=} as \\
    & \TT{min::gen} values, continue as per the \TT{JMP} instruction.  \\
    & Otherwise if \TT{immedB} == 0, do nothing more, but if \\
    & \TT{immedB} == 1, push the first value popped back into the stack.
\\\hline
\ttkey{JMPLT}/\ttkey{JMPLEQ}
    & Ditto, but \TT{JMP} if the second popped is arithmetically \\
    & less-than/less-than-or-equal-to the first popped.
\\\hline
\ttkey{JMPGT}/\ttkey{JMPGEQ}
    & Ditto, but \TT{JMP} if the second popped is arithmetically \\
    & greater-than/greater-than-or-equal-to the first popped.
\\\hline
\ttkey{JMPTRUE}
    & Pop 1 value and respectively test whether it: equals \TT{mex::TRUE}, \\
\ttkey{JMPFALSE}
    & equals \TT{mex::FALSE}, \\
\ttkey{JMPNONE}
    & equals \TT{min::NONE()}, \\
\ttkey{JMPINT}
    & is an integer in the range (-1e15,+1e15), \\
\ttkey{JMPFIN}/\ttkey{JMPINF}
    & is a finite number, is an infinite number, \\
\ttkey{JMPNAN}/\ttkey{JMPNUM}
    & is an arithmetic NaN, is a MIN number (includes NaNs), \\
\ttkey{JMPTRUTH}
    & equals mex::TRUE or mex::FALSE, \\
\ttkey{JMPSTR}/\ttkey{JMPOBJ}
    & is a MIN string, or is a MIN object. \\
    & If yes, continue as per \TT{JMP}, and if no, do nothing, \\
    & provided \TT{immedB} = 0.  However if \TT{immedB} != 0, reverse \\
    & the test, so `no' jumps and `yes' does not.
\\\hline
\ttkey{JMPCNT}
    & Test whether \TT{sp[- immedB - 1]} is arithmetically $\leq 0$, \\
    & and if yes, continue as per \TT{JMP}.  Otherwise subtract \TT{immedD} \\
    & (must be a finite number) from \TT{sp[ - immedB - 1]}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Stack and Flow Control Instructions}
\label{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
\end{boxedfigure}

\pagebreak

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{BEG}/\ttkey{END}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped include trace values.
\\\hline
\ttkey{BEGL}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.  Then \\
    & take the top \TT{immedB} values in the stack and push a copy of \\
    & them all into the stack, preserving stack ordering.
\\\hline
\ttkey{ENDL}/\ttkey{CONT}
    & First subtract \TT{immedA} from \TT{sp}
      (popping the stack \TT{immedA} times), \\
    & then take the top \TT{immedB} values in the stack and copy them \\
    & to the next lower \TT{immedB} values in the stack, then subtract \\
    & \TT{immedC} from the \TT{pc} (jumping backwards to just after \\
    & the appropriate \TT{BEGL}).
\\\hline
\ttkey{BEGF}
    & Add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
    \\[0.5ex]
    & Also used to provided data for \TT{CALL} as follows: \TT{immedB} is the \\
    & target function's lexical nesting level (\pagref{LEXICAL-LEVEL}),
      and \TT{immedA} is the \\
    & minimum number of arguments expected.
\\\hline
\ttkey{ENDF}
    & Same as a \TT{RET} instruction (below) with \TT{immedC} = 0. 
\\\hline
\ttkey{CALLM}
    & Push a \TT{mex::ret} entry $e$ into the return stack, setting
      \TT{$e$.saved\_pc} \\
    & to point to the \TT{CALLM} instruction, and then
      set the \TT{index} \\
    & of \TT{p->pc} to \TT{immedC}, which must reference a
      \TT{BEGF} instruction.
    \\[0.5ex]
    & Check that the \TT{CALL} \TT{immedA} value, the number of arguments \\
    & passed, is at least as great as the \TT{BEGF}
      \TT{immedA}, the minimum \\
    & number of arguments expected.  Take the target 
      function's lexical \\
    & level $L$ from the \TT{BEGF} \TT{immedB} value, and save
      \TT{p->\{level,fp[$L$],} \\
    & \TT{ap[$L$]\}} in \TT{$e$.saved\_\{level,fp,ap\}}.
       Next set \TT{p->level} \\
    & to $L$, \TT{p->fp[$L$]} to \TT{sp}, \TT{p->ap[$L$]} to \TT{sp - immedA},
      and \TT{$e$.nresults} \\
    & to \TT{immedB}.
    \\[0.5ex]
    & Lastly add +1 to the process current \TT{pc} to skip the \TT{BEGF}.
\\\hline
\ttkey{CALLG}
    & Same as \TT{CALLM} but also set the process's \TT{pc} member's 
                                                           \TT{module} \\
    & member from \TT{immedD} (which must convert to a \TT{mex::module}).
\\\hline
\ttkey{RET}
    & Check that \TT{immedB} equals \TT{p->level}.  Then pop element $e$
      from \\
    & the return stack and check that \TT{immedC} equals
       \TT{$e$.nresults}.  Next \\
    & pop \TT{immedC} values from the stack and save them.  Set \TT{sp} to \\
    & \TT{ap[immedB]} (popping the
      current function execution stack values).  \\
    & Then push the saved values into the stack. Lastly, restore the \\
    & process members saved in \TT{$e$.saved\_\{pc,level,fp,ap\}}, \\
    & and increment the restored \TT{pc} by \TT{1}.
\\\hline
\end{tabular}
\end{center}
\caption{Block and Function Instructions}
\label{BLOCK-AND-FUNCTION-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\begin{boxedfigure}

\begin{center}
\small
\begin{tabular}{|l|l|}
\hline
\ttkey{VPUSH}
    & Push the value of the top of the stack to the end of the vector of \\
    & the object pointed at by \TT{sp[- immedA - 1]}. However, if the value \\
    & at the top of the stack is itself an object with 
                    \TT{.initiator == immedD}, \\
    & push instead all the vector elements of this object.  After finishing \\
    & adding to the vector of the object, pop the execution stack once. 
\\\hline
\ttkey{VPOP}
    & Pop one value from the end of the vector of the object pointed at by \\
    & \TT{sp[- immedA - 1]} and then push that value into the stack.
        However, \\
    & if the vector is empty, push \TT{min::NONE()} instead.
\\\hline
\ttkey{VSIZE}
    & Push the size of the vector of the object pointed at by \\
    & \TT{sp[- immedA - 1]} into the stack.
\\\hline
\ttkey{GET}
    & Read the attribute labelled by the value X
        of \TT{sp[- immedC - 1]} from \\
    & the object pointed to by \TT{sp[- immedA - 1]} and then push that value \\
    & into the stack.  If X is an integer, read the X+1'st element of the \\
    & vector of the object, while if X is a string or MIN label, read the \\
    & labelled attribute of the object.  If the value to be read does not
    		exist, \\
    & push \TT{min::NONE()} into the stack instead.  If \TT{immedB}
    	is non-zero, \\
    & \TT{immedC} is required to be zero, and the value X is popped from \\
    & the stack just before the attribute value read is pushed.
\\\hline
\ttkey{GETI}
    & Read the attribute labelled by \TT{immedD}, which must be a string \\
    & or MIN label, from the object pointed to by \TT{sp[- immedA - 1]}, \\
    & and then push that value into the stack.  If the value to be read does \\
    & not exist, push \TT{min::NONE()} into the stack instead.
\\\hline
\ttkey{SET}
    & Write the top value in the stack to the attribute labelled by the value \\
    & X of \TT{sp[- immedC - 1]} in the object pointed to by
    	\TT{sp[- immedA - 1]}. \\
    & If X is an integer, write the X+1'st element of the vector of the \\
    & object, while if X is a string or MIN label, write to the labelled \\
    & attribute in the object.  If X is an integer, the vector element is \\
    & required to exist; otherwise if the attribute does not have a previous \\
    & value, the attribute is created.  After the write, pop one value from \\
    & the stack (the value written), and then if \TT{immedB} is non-zero, 
        require \\
    & \TT{immedC} to equal \TT{1} and pop a second value (X)
	    from the stack.
\\\hline
\ttkey{SETI}
    & Write the top value in the stack to the attribute labelled
        by \TT{immedD}, \\
    & which must be a string or MIN label, in the object pointed to by \\
    & \TT{sp[- immedA - 1]}.  Then pop one value (the value written) from the \\
    & stack.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Object Instructions}
\label{OBJECT-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\begin{boxedfigure}

\begin{center}
\small
\begin{tabular}{|l|l|}
\hline
\ttkey{PUSHA}
    & Read the stack vector value with index \TT{ap[immedB] + immedA} \\
    & and push it into the stack.  \TT{immedA} must be in the range \\
    & \TT{[0, nargs)} where \TT{nargs = p->fp[immedB] - p->ap[immedB]}.
\\\hline
\ttkey{PUSHNARGS}
    & Push \TT{nargs = p->fp[immedB] - p->ap[immedB]}
        (which is a natural \\
    & number) converted to IEEE 64-bit floating point.
\\\hline
\ttkey{PUSHV}
    & Replace the top stack value \TT{V} with the value of the stack element
      with \\
    & index \TT{p->ap[immedB] + V}. \TT{V} must convert to a non-negative
      integer.   \\
    & If \TT{V >= nargs} where
      \TT{nargs = p->fp[immedB] - p->ap[immedB]}, \\
    & \TT{min::NONE()} replaces the top value.
\\\hline
\ttkey{SET\_TRACE}
    & The process \TT{trace\_flags} member is set to \TT{immedA} with its\\
    & \TT{T\_ALWAYS} flag forced on and its \TT{T\_NEVER} flag forced off. \\
    & This instruction is in the \TT{ALWAYS} trace class.
\\\hline
\ttkey{NOP}/\ttkey{TRACE}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times).  The \\
\ttkey{WARN}/\ttkey{ERROR}
    & values popped are always trace values.  All these instructions \\
    & but \TT{NOP} are in the \TT{ALWAYS} trace class.  All these instructions
      are \\
    & no-operations used only for tracing, except \TT{ERROR} prints \\
    & a `Fatal Error' message before its trace and then terminates \\
    & the process with an \TT{ERROR\_STOP} state.
\\\hline
\ttkey{TRACE\_EXCEPTS}
    & No operation.  When traced prints the process
      \TT{excepts\_accumulator}.  \\
    & This instruction is in the \TT{ALWAYS} trace class.
\\\hline
\ttkey{SET\_EXCEPTS}
    & The process \TT{excepts\_mask} member is set to \TT{immedA}.
\\\hline
\ttkey{SET\_OPTIMIZE}
    & The process \TT{optimize} member is set to the low order bit
      of \TT{immedA}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Stack and Housekeeping Instructions}
\label{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}
\end{boxedfigure}

\section{Arithmetic Exceptions}
\label{ARITHMETIC-EXCEPTIONS}

Arithmetic instructions (Figure~\itemref{ARITHMETIC-INSTRUCTIONS})
may raise the exceptions in Figure~\itemref{EXCEPTIONS}.
When an exception is raised, a flag bit associated with the
exception is turned on the process's \TT{excepts\_\EOL accumulator}
member.  This bit is never turned off, so it can be used at the
end of an execution to determine whether the exception
occurred during the execution.

In C/C++ the flag bit associated with exception \TT{XX}
is defined as a bit mask macro \TT{FE\_XX} in \TT{fenv.h}
(see fenv(3) in the UNIX manual):

\begin{boxedfigure}[t!]
\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{DIVBYZERO} &  An operation on finite numbers produces infinity \\
                  &  as a result (e.g., {\tt 5/+0}).
\\\hline
\ttkey{INVALID} & An operation has no well defined result
                  (e.g., {\tt 0/0}). \\
		& \TT{NaN} becomes the result.
\\\hline
\ttkey{OVERFLOW} & An operation produces a finite result too large to
                   store. \\
		 & An infinity becomes the result.
\\\hline
\ttkey{UNDERFLOW} & An operation produces a finite result too small to
                    store. \\
	          & {\tt +0} or {\tt -0} becomes the result.
\\\hline
\ttkey{INEXACT} & An operation produces a finite result that cannot
                  be stored exactly. \\
		& The result is rounded to the nearest value.
\\\hline
\end{tabular}
\end{center}
\caption{Exceptions}
\label{EXCEPTIONS}
\end{boxedfigure}

Only arithmetic instructions in Figure~\itemref{ARITHMETIC-INSTRUCTIONS}
can raise exceptions.

In non-optimized mode, i.e.~when a process's \TT{optimize} member is \TT{false},
an instruction that raises an exception prints
an error message if the instruction exception is one whose bit
is on in the process's \TT{excepts\_mask}\label{EXCEPTS-MASK} member.
This error message is always followed by a trace of the instruction
(regardless of the process trace flag settings): see
Instruction Tracing, \itemref{INSTRUCTION-TRACING}.

In optimized mode, instructions do not print error messages
involving exceptions.  However exception flag bits are still
raised in the process's \TT{excepts\_accumulator} member.

In both modes, when a process terminates and there is any exception
bit on in both the process's \TT{excepts\_\EOL accumulator}
and \TT{excepts\_mask} member, an error message is printed.

The initial setting of a process's \TT{excepts\_mask} member is
provided by the \TT{mex::\EOL run\_\EOL excepts\_\EOL mask}
global variable\pagnote{RUN-EXCEPTS-MASK}, whose default value is:
\begin{center}
\TT{DIVBYZERO} ~~ \TT{INVALID} ~~ \TT{OVERFLOW}
\end{center}

\section{Instruction Tracing}
\label{INSTRUCTION-TRACING}

A process has two modes: \key{normal} and \key{optimized}, as
determined by the \TT{optimize}\label{OPTIMIZE} member of the process.
The default setting of the \TT{optimize} member of a process
is \TT{false}.

In normal mode, tracing of an instruction
is controlled by the \key{trace class} $C$ of the instruction
and the \key{trace flags}\label{TRACE-FLAGS} $F$ of the process.  If
\TT{$F$ \& ( 1 <{}< $C$ ) != 0} the instruction is traced.

In optimized mode, instructions are \underline{not} traced,
except that instructions in the \ttkey{ALWAYS} trace class are always
traced.  These include the \TT{TRACE}, \TT{TRACE\_\EOL EXCEPTS},
\TT{SET\_\EOL TRACE},
\TT{WARN}, and \TT{ERROR} instructions.

Instructions in the \ttkey{NEVER} trace class are never
traced.  Typically there are compiler switches that will
change to \TT{NEVER} the trace class stored in every instruction that
does not have the \TT{ALWAYS} class
(see The MEXAS Program \TT{-tcnever} option, page \mexasref{-TCNEVER}).

The trace classes are given in Figure \itemref{TRACE-CLASSES-AND-GROUPS}.
Also given there are trace groups that can be used for convenience
to set the trace flags of a process to include
a pre-defined group of trace classes.
Trace class names and trace group names are used by compiler switches
which set the initial trace flags of processes
(see The MEXAS Program \TT{-tc:\ldots} option, page \mexasref{-TC:}),
and by the
\TT{SET\_\EOL TRACE} instruction that sets the current trace flags
of a process.

Notice that all arithmetic instructions have the same
trace class, all \TT{PUSH\ldots} instructions have the same trace
class, and all conditional \TT{JMP\ldots} instructions have the
same two trace classes, one for a successful jump and one for
a failed jump.  Object instructions have the \TT{SET} trace class for
instructions that create or modify objects, and the \TT{GET} trace
class for instructions that read objects.
Other instructions each have their own trace class,
except for those with the \TT{ALWAYS} class.

In C++ code trace class \TT{XX} is a number that is the value of
the \TT{mex::T\_XX} constant.  Thus the trace class of \TT{ADD}
is \TT{mex::T\_AOP}.


\begin{boxedfigure}[!h]

\begin{center}

\bigskip

{\Large \bf Trace Classes}
\\[2ex]
\begin{tabular}{|l|p{5in}|}
\hline
\ttmkey{NEVER}{trace class} & Instruction is never traced.
\\\hline
\ttmkey{ALWAYS}{trace class} & Instruction is always traced.
    The following instructions have this trace class:
    \TT{ERROR}, \TT{WARN}, \TT{TRACE}, \TT{TRACE\_\EOL EXCEPTS},
    \TT{SET\_\EOL TRACE}.
\\\hline
\ttmkey{AOP}{trace class} & Arithmetic instructions in Figure
    \itemref{ARITHMETIC-INSTRUCTIONS}.
\\\hline
\ttmkey{PUSH}{trace class} & All \TT{PUSH\ldots} instructions in Figures
    \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS} and
    \itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}.
\\\hline
\ttmkey{POP}{trace class} & The \TT{POP} instruction in Figure
    \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
\\\hline
\ttmkey{JMP}{trace class} & The \TT{JMP} instruction.
\\\hline
\begin{tabular}[t]{@{}l@{}}
\ttmkey{JMPS}{trace class} \\
\ttmkey{JMPF}{trace class}
\end{tabular} & \TT{JMP\ldots} instructions in
	        Figure \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
		When compiled the instruction is given the \TT{JMPS}
		class.  When executed, if the jump test succeeds
		(jump is taken),
		the instruction trace class is left unchanged, but if
		the jump test fails (there is no actual jump),
		the effective trace class is changed
		to \TT{JMPF}.
\\\hline
\ttmkey{SET}{trace class} & The \TT{PUSHOBJ}, \TT{VPUSH}, \TT{SET},
                            and \TT{SETI} instructions in Figure
                            \itemref{OBJECT-INSTRUCTIONS}.
\\\hline
\ttmkey{GET}{trace class} & The \TT{VPOP}, \TT{VSIZE}, \TT{GET},
                            and \TT{GETI} instructions in Figure
                            \itemref{OBJECT-INSTRUCTIONS}.
\\\hline
\ttmkey{XXX}{trace class} & Instruction with operation code \TT{XXX},
                            for instructions not mentioned above
			    (e.g., for \TT{NOP}, \TT{BEG}, etc.,
			    but \underline{not} for \TT{ADD},
			    \TT{PUSH}, \TT{JMPEQ}, \TT{ERROR}, etc.).
\\\hline
\end{tabular}
\end{center}

\begin{center}
{\Large \bf Trace Class Groups}
\\[2ex]
\begin{tabular}{|l|l|}
\hline
\ttmkey{ALL}{trace class group} &  All trace classes.
\\\hline
\ttmkey{NONE}{trace class group} &  No trace classes.
\\\hline
\ttmkey{FUNC}{trace class group} &  \TT{CALLM} \TT{CALLG} \TT{RET} \TT{ENDF}
\\\hline
\ttmkey{LOOP}{trace class group} &  \TT{BEGL} \TT{CONT} \TT{ENDL}
\\\hline
\end{tabular}
\end{center}
\caption{Trace Classes and Groups}
\label{TRACE-CLASSES-AND-GROUPS}
\end{boxedfigure}

\subsection{Trace Messages}
\label{TRACE-MESSAGES}

Each instruction trace message begins with:
\begin{indpar}
\emkey{trace-header} ::= \\
\hspace*{0.3in}
\TT{\{}{\em line-number}\TT{:}{\em code-vector-location}%
                        \TT{,}{\em stack-length}%
                        \TT{,}{\em process-counter}\TT{\}} ~ {\em op-code}
\end{indpar}
The {\em line-number} is the number of the \underline{last} source code
line containing code that generated the instruction.
The {\em code-vector-location} is the index of the instruction
in its code vector.
The {\em stack-length} is the number of values in the stack
just \underline{after} the traced instruction executes.
The {\em process-counter} is the number of instruction executions
since the process was originally initialized just \underline{after} the traced
instruction executes.  The {\em op-code} is the instruction operation code.

The rest of the instruction trace message is specific to the type of
instruction and is specified in the following subsections.  However
in all cases it is based on the value of
\TT{module->\EOL trace\_\EOL info[i]} where \TT{i} is the index of
the instruction in its code vector.
If \TT{module->\EOL trace\_\EOL info[i]} does not exist
or is of an unexpected type, the message may be incomplete.

\subsubsection{Arithmetic Tracing}
\label{ARITHMETIC-TRACING}

The trace message of an arithmetic instruction has the form:
\begin{center}
{\em trace-header}\TT{:} {\em new-variable-name} \TT{=} {\em value}
                    \TT{<=} {\em value}\QMARK{}
                    {\em operator} {\em value}
\end{center}
For an arithmetic instruction the value of
\TT{module->\EOL trace\_\EOL info[i]} is {\em new-variable-name}
as a MIN string (this may be \TT{*}).
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string,
\TT{*} is used as {\em new-variable-name}.

Note that arithmetic instructions are usually not traced.

\subsubsection{Jump Tracing}
\label{JUMP-TRACING}

\TT{JMP\ldots} instruction trace messages have the form:

\begin{center}
{\em trace-header} {\em jmp-target} \TT{is successful:~true}
                    \TT{<=} {\em value} \{ {\em operator} {\em value} \}\QMARK{}
\end{center}
or
\begin{center}
{\em trace-header} {\em jmp-target} \TT{is UNsuccessful:~false}
                    \TT{<=} {\em value} \{ {\em operator} {\em value} \}\QMARK{}
\end{center}

or for a plain unconditional \TT{JMP} instruction, just:
\begin{center}
{\em trace-header} {\em jmp-target}
\end{center}

For a jump instruction the value of
\TT{module->\EOL trace\_\EOL info[i]} is {\em jmp-target}
as a MIN string or label.
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string or label,
`\TT{location} {\em target-index}' is used as {\em jump-target}, where
{\em target-index} is the index of the target instruction in its
module's code vector.

For the comparison jump instructions (\TT{JMPGT}, etc.), a \TT{*}
is appended to the {\em op-code} name if the instruction's
\TT{immedB} is non-zero (so that for an unsuccessful jump,
the first value popped is
pushed back into the stack).

\subsubsection{Push/Pop Tracing}
\label{PUSH/POP-TRACING}

\TT{PUSH\ldots} instructions and the \TT{POP} instruction are in essence
value copy instructions and their trace messages
have the form:

\begin{center}
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<=} {\em from-variable} \TT{=} {\em value}
\end{center}

For \TT{PUSH\ldots} the {\em to-variable} is the {\em new-variable}
and the {\em from-variable} is the instruction {\tt variable}.
For \TT{POP} the {\em to-variable} is the instruction {\em variable}
and the {\em from-variable} is the name of the top of the stack.

As always in tracing, `\TT{*}' is used for a missing variable name.

For a \TT{PUSH\ldots} or \TT{POP} instruction
in Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
the value of
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\TT{[<} {\em from-variable} ~ {\em to-variable} \TT{>]}.
If \TT{module->\EOL trace\_\EOL info[i]} is not a 2 element MIN label,
both {\em from-variable} and {\em to-variable} are taken to be \TT{*}.

However there are two exceptions with different {\em from-variables}
and with {\em trace\_\EOL info[i]} equal to just {\em to-variable}.
They are:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\bf Op Code & \bf \em from-variable
\\\hline
\TT{PUSHNARGS} & \TT{nargs[$L$]} \\
\TT{PUSHV}     & \TT{stack[ap[$L$]+$V$]}
\end{tabular}
\\[1ex]
where $L$ is the lexical level, \\
$V$ is the value at the top of the stack, \\
and \TT{nargs[$L$] = fp[$L$] - ap[$L$]}
\end{center}
For these two case,
if \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string or MIN label,
{\em to-variable} is taken to be \TT{*}.

\subsubsection{DEL Instruction Tracing}
\label{DEL-INSTRUCTION-TRACING}

If \TT{immedA} > 0 and \TT{immedC} > 0 the trace message has the form:
\begin{center}
{\em trace-header}\TT{:} \TT{sp[-$n1$..-$n2$] <= sp[-$n3$..-1]}
\end{center}
where $n1$ = \TT{immedA + immedC}, $n2$ = \TT{immedC + 1},
$n3$ = \TT{immedA}.

If \TT{immedA} == 0 and \TT{immedC} > 0 the trace message has the form:
\begin{center}
{\em trace-header}\TT{:} \TT{popped sp[-$n$..-1]}
\end{center}
where $n$ = \TT{immedC}.

If \TT{immedA} == 0 and \TT{immedC} == 0 the trace message has the form:
\begin{center}
{\em trace-header}\TT{:} \TT{no operation}
\end{center}

\subsubsection{Object Instruction Tracing}
\label{OBJECT-INSTRUCTION-TRACING}

The trace messages for the object instructions in
Figure~\itemref{OBJECT-INSTRUCTIONS} are:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\TT{PUSHOBJ} &
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<=} \TT{NEW OBJ (} {\em unused\_size}\TT{,}
		    {\em hash\_size} \TT{)}
\\[1ex]
\TT{VPUSH} &
{\em trace-header}\TT{:} \TT{PUSHED} {\em object-variable}
                    \TT{<=} {\em from-variable}
		    \TT{=} {\em value}
\\[1ex]
\TT{VPOP} &
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<= POPPED} {\em object-variable}
		    \TT{=} {\em value}
\\[1ex]
\TT{VSIZE} &
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<= SIZE OF} {\em object-variable}
		    \TT{=} {\em value}
\\[1ex]
\TT{GET}/\TT{GETI} &
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<=} {\em object-variable}\TT{[}{\em label-value}\TT{]}
		    \TT{=} {\em value}
\\[1ex]
\TT{SET}/\TT{SETI} &
{\em trace-header}\TT{:} {\em object-variable}\TT{[}{\em label-value}\TT{]}
		    \TT{<=} {\em from-variable} \TT{=} {\em value}
\end{tabular}
\end{center}

For these instructions,
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\TT{[<} {\em from-variable} ~ {\em to-variable} \TT{>]},
where one of the two variables is {\em object-variable}.
If \TT{module->\EOL trace\_\EOL info[i]} does not have the right form,
{\em from-variable} and {\em to-variable} are taken to be \TT{*}.

Also, for \TT{GET} and \TT{SET} the operation code that ends the
{\em trace-header} is followed by \TT{*}
if the instruction \TT{immedB} value is non-zero (indicating that
\TT{GET} replaces the top stack value instead of pushing the value
read, and \TT{SET} pops two values instead of just one:
see Figure~\itemref{OBJECT-INSTRUCTIONS}).


\subsubsection{Trace-Packet Based Trace Messages}
\label{TRACE-PACKET-BASED-TRACE-MESSAGES}

A \key{trace packet} is a \key{trace packet message} and a list of
\skey{trace variable}s.\label{TRACE-VARIABLE}
The trace message of a trace packet
instruction has the form:
\begin{indpar}
    {\em trace-header}\TT{:} ~
    {\em trace-packet-message} ~
    \{\TT{,} {\em trace-variable}\TT{=}{\em value} \} \STAR{}
\end{indpar}

For a trace packet instruction
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\begin{center}
\vspace*{-1ex}
\TT{[<} {\em trace-packet-message} ~ {\em trace-variable}\STAR{} \TT{>]}
\end{center}
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN label with at
least one element, then just the {\em trace-header} is output.

The trace packet instructions are:
\begin{center}
\begin{tabular}{ll}
Standard Trace Packet Instructions: &
    \TT{BEG} ~ \TT{END} ~ \TT{TRACE} ~ \TT{NOP} ~ \TT{WARN} ~ \TT{ERROR}
\\[0.5ex]
Special Trace Packet Instructions: &
    \TT{BEGL} ~ \TT{ENDL} ~ \TT{CONT}  \\
  & \TT{BEGF} ~ \TT{ENDF} ~ \TT{CALL\ldots} ~ \TT{RET}
\end{tabular}
\end{center}

For standard trace packet instructions, the compiler must push
the values of the trace variables into the stack just
before the instruction.  Then the instruction is traced before
it is executed, if tracing the instruction is enabled.  Lastly
the instruction execution pops the trace variable
values from the stack, which is why instructions such as \TT{NOP} and
\TT{TRACE}
can pop stack values.  This trace variable pushing and popping are made
invisible to the programmer by the compiler.

The special trace packet instructions do \underline{no} pushing and popping
of trace variable values, and sometimes use the trace packet
of an instruction related to them rather than a trace packet of their
own.  Specifically:

\begin{center}
\begin{tabular}{lp{4.0in}}
\TT{BEGL}  & Uses its own trace packet, with the \TT{immedB} loop variable
             values in the stack when \TT{BEGL} is executed as the trace packet 
	     variable values.
\\[0.5ex]
\TT{ENDL}/\TT{CONT}  & Uses the trace packet of the associated \TT{BEGL},
                       with the \TT{next-\ldots} variable values in the
		       stack \underline{after} the \TT{ENDL} or \TT{CONT}
		       has been executed as the trace variables.
		       At this time these \TT{next-\ldots} variable values
		       are a copy of the loop variable values for the next
		       iteration.
\\[0.5ex]
\TT{CALL\ldots}  & Uses the trace packet of the associated \TT{BEGF},
                   with the argument values in the stack as the trace
		   variable values. 
		   Also the {\em op-code}
		   in the {\em trace-header} is replaced by
		   \TT{CALL\ldots{}~to BEGF}\label{CALL-TO-BEGF}.
\\[0.5ex]
\TT{RET}/\TT{ENDF}  & Uses the trace packet of the associated \TT{CALL},
                   with the return values in the stack as the trace
		   variable values.
		   Also the {\em op-code}
		   in the {\em trace-header} is replaced by
		   \TT{RET to CALL\ldots}\label{RET-TO-CALL}
		   or \TT{ENDF to CALL\ldots}.
\end{tabular}
\end{center}

Note: The compiler should make the trace variables of a \TT{BEGL}
match the names actually used in source code to refer to the loop
variables, and similarly for \TT{BEGF} and arguments and \TT{CALL\ldots}
and return values.
But MEX knows nothing of names used in source code.
To see how MEXAS handles this look at MEXAS Instructions,
\mexasref{MEXAS-INSTRUCTIONS}.



\subsubsection{Other Instruction Trace Messages}
\label{OTHER-INSTRUCTION-TRACE-MESSAGES}

\begin{center}
\begin{tabular}{lp{4.5in}}
\bf Op Code     & \bf Trace Message
\\\hline
\ttmkey{SET\_TRACE}{trace message}
		& {\em trace-header}\TT{:} {\em trace-class}\STAR{} \\
                & The {\em trace-classes} being enabled are
	          listed, but they are \underline{not}
		  aggregated into {\em trace-class-groups}.
\\[0.5ex]
\ttmkey{SET\_EXCEPTS}{trace message}
		& {\em trace-header}\TT{:}
                    \{ \TT{*}\QMARK{}{\em except-name} \}\STAR{} \\
                & The names of the excepts being enable in
		  \TT{p->excepts\_mask} are listed, and those that are
		  also in \TT{p->excepts\_accumulator} are starred with
		  \TT{*}.
\\[0.5ex]
\ttmkey{SET\_OPTIMIZE}{trace message}
		& {\em trace-header}\TT{:}
                    {\em new-value} \TT{<=} {\em old-value} \\
                & The new and old values are listed as indicated.
		  The values are denoted as \TT{ON} or \TT{OFF}.
\\[0.5ex]
\ttmkey{TRACE\_EXCEPTS}{trace message}
		& {\em trace-header}\TT{:}
                    \{ \TT{*}\QMARK{}{\em except-name} \}\STAR{} \\
                & The names of the excepts in \TT{p->excepts\_accumulator}
		  are listed, and those that are also in \TT{p->excepts\_mask}
		  are starred with \TT{*}.
\end{tabular}
\end{center}

\subsection{Trace Depth}
\label{TRACE-DEPTH}

Trace messages are indented by the process's \TT{trace\_depth} member
times the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{trace\_indent}\verb|    // Default == 2.|
\end{indpar}
In addition, in the first line of a message all the indent spaces but
the last are replaced by the value of the global variable:
\begin{indpar}
\verb|char mex::|\MEXKEY{trace\_mark}\verb|    // Default == '*'.|
\end{indpar}

A process's \TT{trace\_depth} is initialized to \TT{0} and maintained
by the following instructions:
\begin{center}
\begin{tabular}{l@{~~~~}l}
\TT{BEG} ~ \TT{BEGL} ~ \TT{CALL}+\TT{BEGF} & Increment by 1. \\
\TT{END} ~ \TT{ENDF} ~ \TT{RET} & Decrement by 1. \\
\TT{JMP\ldots} ~ \TT{CONT} & Decrement by the instruction's \\
               & \TT{trace\_depth} member. \\
\end{tabular}
\end{center}
Note: \TT{JMP\ldots} is the only way to exit the current loop (\TT{ENDL} and
\TT{CONT} start a new iteration).

A process's \TT{trace\_depth} is maintained even when the process's
\TT{optimize} switch is \TT{true} (only a few instructions change
the trace depth).

\section{MEX Functions}
\label{MEX Functions}

{\tt mex::module mex::}\MEXKEY{create\_module}
    \verb|( min::file f )|
\begin{indpar}
A \TT{mex::module} is created and returned.  The code vector is empty.
Empty \TT{position} and \TT{trace\_info} vectors are created.
The \TT{globals} member is set to \TT{min::NULL\_STUB} and the
\TT{interface} member is set to \TT{min::MISSING()}.

The \TT{max\_length} of the three empty vectors is initially set to:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{module\_length}\verb|    // Default == 1 << 12.|
\end{indpar}

Note that \TT{mex::module} and its components are read-only, so that
to push instructions, positions, and info into the vectors the module type
must be converted to \TT{mex::module\_ins}.  The following inline
functions can be used to push elements into these vectors and
call \TT{min::acc\_write\_update} as necessary:
\begin{indpar}
{\tt void mex::}\MEXKEY{push\_instr} \\
\hspace*{2em}\verb|( mex::module_ins m, const mex::instr & instr )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_position} \\
\hspace*{2em}\verb|( mex::module m, const min::phrase_position & pp )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_trace\_info} \\
\hspace*{2em}\verb|( mex::module, min::gen info )|
\end{indpar}

These functions will increase the \TT{max\_length} of the vectors
automatically if necessary.

\end{indpar}

{\tt min::locatable\_var<min::printer> mex::}\MEXKEY{default\_printer}
\begin{indpar}
Default printer for \TT{create\_process}.  Initially \TT{min::NULL\_STUB}.
\end{indpar}

{\tt mex::process mex::}\MEXKEY{create\_process} \\
\hspace*{10em}\verb|( min::printer printer = mex::default_printer )|
\begin{indpar}
A \TT{mex::process} is created and returned.  The \TT{printer} argument
must \underline{not} be \TT{min::\EOL NULL\_\EOL STUB}.

The process \TT{length} member (stack size) is set to \TT{0}
and its \TT{max\_length} member (maximum stack size) is set to the
value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{run\_stack\_limit}\verb|    // Default == 16384.|
\end{indpar}

An empty \TT{return\_stack} vector is created and its \TT{max\_size}
is set to the value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{run\_return\_stack\_limit}%
            \verb|    // Default == 4096.|
\end{indpar}

Note: the stack's \TT{max\_length} members are \underline{not} permitted
to change during process execution, but see \TT{mex::\EOL run\_\EOL process}.

The \TT{printer} member is set to the \TT{printer} argument.
The \TT{counter\_\EOL limit}, \TT{trace\_\EOL flags},
\TT{excepts\_\EOL mask}, and \TT{optimize} members
are set respectively from:
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 mex::| & \MEXKEY{run\_counter\_limit} \\
                        & \verb|// Default == 1 << 20|
\\[0.5ex]
\verb|min::uns32 mex::| & \MEXKEY{run\_trace\_flags} \\
                        & \verb|// Default == 1 << mex::T_ALWAYS|
\\[0.5ex]
\verb|int mex::| & \MEXKEY{run\_excepts\_mask}%
		\label{RUN-EXCEPTS-MASK} \\
            & \verb+// Default == FE_DIVBYZERO|FE_INVALID|FE_OVERFLOW+
\\[0.5ex]
\verb|bool mex::| & \MEXKEY{run\_optimize} \\
            & \verb|// Default == false|
\end{tabular}\end{indpar}

The \TT{pc} member is set to \TT{\{min::NULL\_STUB,0\}}.
The \TT{fp[\ldots]}, \TT{ap[\ldots]}, \TT{level}, \TT{trace\_\EOL depth},
\TT{counter}, \TT{optimized\_\EOL counter}, and \TT{excepts\_\EOL accumulator}
members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.


\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::module m, mex::process p = min:NULL_STUB )|
\begin{indpar}
Initialize \TT{p} (which is created by \TT{mex::create\_process}
if that is \TT{NULL\_STUB}) to run the code in \TT{m}.
Return the process.

The \TT{pc} member is set to \TT{\{m,0\}}.

The \TT{fp[\ldots]}, \TT{ap[\ldots]}, \TT{level}, \TT{trace\_\EOL depth},
\TT{counter}, \TT{optimized\_\EOL counter}, and
\TT{excepts\_\EOL accumula\-tor} members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.

The stack sizes, \TT{counter\_limit}, \TT{trace\_flags},
\TT{excepts\_mask}, and \TT{optimize} members are
\underline{not} changed.

\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::pc pc, mex::process p = min:NULL_STUB )|
\begin{indpar}
Ditto, but does not set the process \TT{pc} member.

Then emulates a \TT{CALL} to the \TT{pc} argument
value, which must point at a \TT{BEGF} instruction with \TT{immedB == 1}
(i.e., lexical level = 1).
This creates a \TT{return\_stack} entry whose
\TT{saved\_pc} is \TT{\{min::NULL\_STUB,0\}}, so a return
will terminate the process normally.  The \TT{saved\_\ldots}
and \TT{nresults} members are set to \TT{0}.

If there is an error in pointing at a \TT{BEGF} instruction of level 1,
then instead the process \TT{pc} member is set to the illegal value
\TT{\{ min::NULL\_STUB, 1 \}} and \TT{min::NULL\_STUB} is returned.
\end{indpar}

{\tt bool mex::}\MEXKEY{run\_process} \verb|( mex::process p )|%
\label{MEX::RUN_PROCESS}
\begin{indpar}
Execute \TT{p} until it terminates.
Returns \TT{true} on normal termination
and \TT{false} otherwise.  The process \TT{state} is
set as follows to indicate cause of termination:
\end{indpar}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{c}{\bf States That Return \TT{true}}
\\[1ex]
\verb|mex::|\MEXKEY{MODULE\_END}
    & \TT{pc} equals \TT{\{m,index\}} \\
    & with \TT{index == m->length} \\
\verb|mex::|\MEXKEY{CALL\_END}
    & \TT{pc} equals \TT{\{min::NULL\_STUB,0\}}
\\[1ex]
\multicolumn{2}{c}{\bf States That Return \TT{false}} \\
\multicolumn{2}{c}{\bf But Do NOT print An Error Message}
\\[1ex]
\verb|mex::|\MEXKEY{COUNTER\_LIMIT\_STOP}
    & \TT{p->counter > p->limit} \\
\verb|mex::|\MEXKEY{STACK\_LIMIT\_STOP}
    & \TT{p->length > p->max\_length} \\
\verb|mex::|\MEXKEY{RETURN\_STACK\_LIMIT\_STOP}
    & \TT{p->return\_stack->length >} \\
    & \TT{p->return\_stack->max\_length}
\\[1ex]
\multicolumn{2}{c}{\bf States That Return \TT{false}} \\
\multicolumn{2}{c}{\bf And Also print An Error Message}
\\[1ex]
\verb|mex::|\MEXKEY{ERROR\_STOP}
    & \TT{ERROR} instruction with \TT{immedB != 0} \\
\verb|mex::|\MEXKEY{JMP\_ERROR}
    & conditional \TT{JMP\ldots}~instruction with \\
    & invalid operand(s) (e.g., either a \TT{NaN} or \\
    & both infinities of the same sign) \\
\verb|mex::|\MEXKEY{FORMAT\_ERROR}
    & program formatting error \\
    & (likely a compiler error) \\
\end{tabular}
\end{center}

Notes:
\begin{enumerate}
\item For cases where \TT{false} is returned by \TT{mex::run\_process},
the process stops \underline{before} executing the instruction which
would violate the condition.
Thus the process will stop before executing an instruction that would
violate one of the limits, trigger a programming format error, etc.
The \TT{ERROR} instruction stops the process with the program counter
pointing at the \TT{ERROR} instruction.
\item \label{LIMIT-STOP-NOTE}
On \TT{\ldots\_LIMIT\_STOP}, you can increase the limit
and call \TT{run\_process} again to continue execution.
For stacks you must re-size the stack (as per \TT{min::\EOL resize}).
\item You can use \TT{init\_process ( m )} followed by \TT{run\_process}
to run the code of \TT{m}.  Then after \TT{MODULE\_END},
you can add to the end of \TT{m}
and call \TT{run\_process} again to continue the execution of the code
of \TT{m} (i.e., execute the added code).
\end{enumerate}

{\tt bool mex::}\MEXKEY{excepts\_check} \verb|( mex::process p )|%
\label{MEX::EXCEPTS_CHECK}
\begin{indpar}
If \hspace*{0.5in}
\TT{flags = p->excepts\_mask \& p->excepts\_accumulator} \\
is zero,
returns \TT{true}.  Otherwise prints a WARNING message listing
the bits of \TT{flags} that are on and returns \TT{false}.
\end{indpar}

\section{MEX Compiler Components}
\label{MEX-COMPILER-COMPONENTS}

Compilers that compile into MEX have some structure in common,
and the MEX has two compiler components, each with data and
functions that can be shared among all these compilers.

\subsection{MEX Basic Compiler Component}
\label{MEX-BASIC-COMPILER-COMPONENT}

The MEX basic compiler component provides functions that print
compiler error and warning messages and count errors and warnings.
It also provides some data structures including a stack of all the
modules compiled and information tables for op codes, trace classes,
trace flags, and except masks.

The MEX basic compiler component is in the following:

\begin{indpar}
\begin{tabular}{l}
{\tt namespace} \ttkey{mexcom}
\\
{\tt \ldots/mex/include/}\ttkey{mexcom.h}
\\
{\tt \ldots/mex/src/}\ttkey{mexcom.cc}
\end{tabular}
\end{indpar}

\subsubsection{MEX Basic Compiler Data}
\label{MEX-BASIC-COMPILER-DATA}

\begin{tabular}{@{}r@{~~~}l}
\verb|min::locatable_var<mex::module_ins> mexcom::|
	& \MEXCOMKEY{output\_module} \\
\verb|min::locatable_var<min::file> mexcom::|
	& \MEXCOMKEY{input\_file}
\end{tabular}

\begin{indpar}
These must be set by the compiler to
the {\tt mex::module} currently being compiled and
its input file.  The printer used by the compiler is
{\tt mexcom::input\_file->printer}.
\end{indpar}

\begin{tabular}{@{}r@{~~~}l}
\verb|typedef min::packed_vec_insptr<mex::module> mexcom:|
	& \MEXCOMKEY{module\_stack} \\
\verb|min::locatable_var<mexcom::module_stack> mexcom:|
	& \MEXCOMKEY{modules}
\end{tabular}
\begin{indpar}
{\tt Mexcom::modules}
is the list of modules completely compiled so far, organized as
a stack, most recent topmost.  When the compiler finishes compiling
a module, it should execute: \\
\hspace*{3em}{\tt min::push(mexcom::modules) = mexcom::output\_module}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{op\_code\_table}
\begin{indpar}
For {\tt op\_code OP < mex::NUMBER\_OF\_OP\_CODES}
with name {\tt "OP"}:\\
\hspace*{3em}{\tt op\_code\_table[OP] == new\_str\_gen ( "OP" )} \\
and \\
\hspace*{3em}{\tt ~~~min::get ( op\_code\_table, new\_str\_gen ( "OP" ) )} \\
\hspace*{3em}{\tt == new\_num\_gen ( OP )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{trace\_class\_table}
\begin{indpar}
For {\tt trace\_class} {\tt T\_XX < mex::NUMBER\_OF\_TRACE\_CLASSES}
with name {\tt "XX"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_class\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( T\_XX )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{trace\_flag\_table}
\begin{indpar}
For {\tt trace\_class} {\tt T\_XX < mex::NUMBER\_OF\_TRACE\_CLASSES}
with name {\tt "XX"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_class\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( 1 <{}< T\_XX )} \\
For trace group {\tt GG := GG1, GG2, ...}
with name {\tt "GG"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_group\_table, new\_str\_gen ( "GG" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( (1 <{}< T\_GG1) $|$ (1 <{}< T\_GG2) $|$ ... )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{except\_mask\_table}
\begin{indpar}
For except named {\tt "XX"} with mask {\tt M = 1 <{}< FE\_XX}: \\
\hspace*{3em}{\tt ~~~min::get ( except\_mask\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( M )}
\end{indpar}

\subsubsection{MEX Basic Compiler Functions}
\label{MEX-BASIC-COMPILER-FUNCTIONS}

\verb|min::uns32 mexcom::| \MEXCOMKEY{error\_count} \\
\verb|min::uns32 mexcom::| \MEXCOMKEY{warning\_count} \\
\verb|void mexcom::| \MEXCOMKEY{compile\_error} \\
\verb|        ( const min::phrase_position & pp,| \\
\verb|          const char * message1,| \\
\verb|          const min::op & message2 = min::pnop,| \\
\verb|          const char * message3    = "",| \\
\verb|          const min::op & message4 = min::pnop,| \\
\verb|          const char * message5,   = ""| \\
\verb|          const min::op & message6 = min::pnop,| \\
\verb|          const char * message7,   = ""| \\
\verb|          const min::op & message8 = min::pnop,| \\
\verb|          const char * message9,   = "" )| \\
\verb|void mexcom::| \MEXCOMKEY{compile\_warn} \\
\verb|        ( const min::phrase_position & pp,| \\
\verb|          const char * message1,| \\
\verb|          const min::op & message2 = min::pnop,| \\
\verb|          const char * message3    = "",| \\
\verb|          const min::op & message4 = min::pnop,| \\
\verb|          const char * message5,   = ""| \\
\verb|          const min::op & message6 = min::pnop,| \\
\verb|          const char * message7,   = ""| \\
\verb|          const min::op & message8 = min::pnop,| \\
\verb|          const char * message9,   = "" )|
\begin{indpar}
Print error message (or warning message).  Increment
{\tt mexcom::error\_count} (or increment {\tt mexcom::\EOL warning\_count}).
If {\tt pp != min::\EOL MISSING\_\EOL PHRASE\_\EOL POSITION},
print source lines after error message, and print the source file name and
source line numbers as part of the error message.  Printing is done using
{\tt mexcom::\EOL input\_\EOL file} and
{\tt mexcom::\EOL input\_\EOL file->\EOL printer}.
\end{indpar}


\subsection{MEX Stack Compiler Component}
\label{MEX-STACK-COMPILER-COMPONENT}

MEX code is organized into blocks: {\tt BEGF/ENDF} \skey{function block}s,
{\tt BEGL/ENDL} \skey{loop block}s, and {\tt BEG/END} \skey{ordinary block}s.
The MEX process stack\pagnote{PROCESS-STACK} is also block organized:
each process stack block consists of all the variables allocated
by a code block (or in the case of function arguments, allocated for
a function code block by code that calls the function).

Each function block is assigned a (lexical) \key{level}.
The entire code of a module is treated as a virtual function block
of level 0.  Other function blocks are assigned the level of their
smallest containing function block plus 1.  Thus
a function block not inside any other non-virtual function block
(but inside the virtual module function block) is assigned level 1.

Each block is also assigned a depth.  Function blocks are assigned depth
0, and the virtual function block of all module code is assigned depth 0.
Non-function blocks are assigned the depth
of their smallest containing block (function or non-function) plus 1.

Instructions are assigned the level and depth of their smallest containing
block.

The MEX stack compiler component ({\tt mexstack}) assumes that the compiler
maintains a virtual stack that mirrors the process run-time stack.
If there are no function executions, this mirror is exact with the value of
{\tt mexstack::\EOL stack\_\EOL length}
when an instruction is compiled equaling the value of
{\tt process->length}, the run-time stack pointer, when the
instruction is executed.

At the beginning of a function, the compiler sets the
function's virtual argument pointer
to the current virtual stack length and the function's virtual
frame pointer to this plus the number of arguments expected by the
function (this can be less than the number of actual run-time arguments).
These virtual pointers correspond to the function's run-time argument
and frame pointers.

The compiler maintains one or more symbol tables of variables
and functions.  For variables the location of the variable value
in the virtual stack is recorded.  For functions, the location of
the function {\tt BEGF} instruction in its code vector is recorded.
The symbol tables are organized as stacks so that
when an {\tt END\ldots} instruction decreases the compiler's lexical
level and/or depth, all variables and functions of higher lexical level
than the new level, or of higher depth and equal lexical level, can be
popped from the symbol tables.

Not all locations in the virtual stack have corresponding variables
in the symbol table.

The MEX stack compiler component is in the following:

\begin{indpar}
\begin{tabular}{l}
{\tt namespace} \ttkey{mexstack}
\\
{\tt \ldots/mex/include/}\ttkey{mexstack.h}
\\
{\tt \ldots/mex/src/}\ttkey{mexstack.cc}
\end{tabular}
\end{indpar}

\subsubsection{MEX Stack Component Data}
\label{MEX-STACK-COMPONENT-DATA}

For stack management the compiler and {\tt mexstack}
communicate through the following variables:

\begin{tabular}{@{}r@{~~~}l}
\verb|min::uns8 mexstack::| & \MEXSTACKKEY{lexical\_level} \\
\verb|min::uns8 mexstack::| &
    \MEXSTACKKEY{depth}\verb|[mex::max_lexical_level+1]| \\
\verb|min::uns32 mexstack::| &
    \MEXSTACKKEY{ap}\verb|[mex::max_lexical_level+1]| \\
\verb|min::uns32 mexstack::| &
    \MEXSTACKKEY{fp}\verb|[mex::max_lexical_level+1]| \\
\verb|min::uns32 mexstack::| & \MEXSTACKKEY{stack\_length} \\
\end{tabular}

\begin{indpar}
The {\tt mexstack::init} function (see below) zeros {\tt lexical\_level},
{\tt depth[0]}, {\tt ap[0]}, {\tt fp[0]}, and {\tt stack\_length}.

If \TT{mexstack::lexical\_level} = $L$
when an instruction is compiled,
then it will be true that {\tt process->level} == $L$ when the instruction
is executed.\pagnote{LEXICAL-LEVEL}
{\tt mexstack::\EOL lexical\_\EOL level} is incremented when a {\tt BEGF}
instruction is compiled and decremented when an {\tt ENDF}
instruction is compiled.

If \TT{mexstack::depth[$L$]} = $D$\label{DEPTH}
when an instruction is compiled,
then the instruction is inside $D$ subblocks of the current function.
{\tt mexstack::depth[$L$]} is incremented when a {\tt BEG} of {\tt BEGL}
instruction is compiled at lexical level $L$, and decremented when
an {\tt END} or {\tt ENDL} instruction is compiled at lexical level $L$.

In the absence of function executions, if
\TT{mexstack::stack\_length} = $S$\label{STACK-LENGTH}
when an instruction is compiled,
then it will be true that {\tt process->length} == $S$ (the process run-time
stack length) when the instruction is executed.

The location (a.k.a., index) of a variable in the compile-time virtual stack
is the value of
{\tt mexstack::\EOL stack\_\EOL length - 1} (top of stack)
just after the {\tt PUSH...}
instruction that creates the variable is compiled, or just after
the subexpression that pushes the variable's value into the run-time
stack is compiled.
Similarly the location of a variable at run time is the value of
{\tt process->length - 1} just after the {\tt PUSH...}
instruction that creates the variable's value executes, or just after
the subexpression that pushes the variable's value executes.

The lexical level of a variable at compile time is the lexical
level of the instruction that creates the variable value in
the process stack, and this equals the lexical level of the variable
at run time.

Argument variables are pushed into
the compiler symbol table by a \TT{BEGF} instruction.
During run-time, argument variable values are transfered from the
calling code to the function by the \TT{CALL\ldots} instruction.

'Next' variables inside a loop are pushed into the compiler symbol
table by a \TT{BEGL} instruction, and at run-time, their values are
pushed into the stack by the same \TT{BEGL}.

Consider a variable that has lexical level $L$,
compile time location $\ell$,
and run-time location $\ell'$ for the variable value in the most recently
started execution of its containing function.
Then if the variable is a non-argument variable:\label{FP} \\
\hspace*{1in}{\tt $\ell$ - mexstack::fp[$L$] == $\ell'$ - process->fp[$L$]}, \\
and if the variable is an argument variable:\label{AP} \\
\hspace*{1in}{\tt $\ell$ - mexstack::ap[$L$] == $\ell'$ - process->ap[$L$]}

At compile-time variables with lexical level $L$ have locations in
the range:\label{LP} \\
\hspace*{1in}{\tt [ mexstack::ap[$L$], mexstack::ap[$L$+1] )}, \\
where if $L$ is the current compile time lexical level the second
limit is replace by {\tt mexstack::stack\_length}.
Argument variables have the subrange: \\
\hspace*{1in}{\tt [ mexstack::ap[$L$], mexstack::fp[$L$] )}, \\
and non-argument variables have the subrange: \\
\hspace*{1in}{\tt [ mexstack::fp[$L$], mexstack::ap[$L$+1] )}

At run-time values of variables in the most recently started
function of lexical level $L$ have locations in
the range: \\
\hspace*{1in}{\tt [ process->ap[$L$], process->ap[$L$+1] )}, \\
where if $L$ is the current run-time lexical level the second
limit is replace by {\tt process->\EOL length}.
Values of argument variables have the subrange: \\
\hspace*{1in}{\tt [ process->ap[$L$], process->fp[$L$] )}, \\
and values of non-argument variables have the subrange: \\
\hspace*{1in}{\tt [ process->fp[$L$], process->ap[$L$+1] )}

The minimum number of arguments expected by a \TT{BEGF} instruction
of level $L$
is at compile time: \\
\hspace*{1in}{\tt mexstack::ap[$L$] - mexstack::fp[$L$]} \\
The actual run-time  number of arguments passed to the \TT{BEGF} instruction
of the most recently started function of level $L$
is: \\
\hspace*{1in}{\tt process->ap[$L$] - process->fp[$L$]}

When a \TT{BEGF} instruction of level $L$ expecting \TT{nargs} arguments
(its \TT{immedA}) is compiled, \TT{mexstack::ap[$L$]}
is set to \TT{mexstack::stack\_length}, \TT{mexstack::fp[$L$]} is set
to \TT{mexstack::stack\_length + nargs}, and then \TT{nargs} argument
variables are pushed into the symbol table and for each
\TT{mexstack::stack\_length} is incremented so when all are done it equals
\TT{mexstack::fp[$L$]}.

When a \TT{CALL\ldots} instruction with \TT{nargs} arguments
(its \TT{immedA}) expecting \TT{nresults} return values (its \TT{immedB}) is compiled,
any symbol table entries referring to the \TT{nargs} arguments
are popped from the stack, and \TT{nargs} is substracted from
\TT{mexstack::\EOL stack\_\EOL length}.  Then a result variable is pushed into the
symbol table for every return value, and \TT{mexstack::\EOL stack\_\EOL length}
is incremented for every such result variable.
So when all is done, \TT{nargs} has been subtracted from \TT{mexstack::stack\_length}
and then \TT{nresults} has been added to \TT{mexstack::stack\_length}.

When a \TT{CALL\ldots} instruction with \TT{nargs} arguments
(its \TT{immedA}) is executed with a level $L$ target \TT{BEGF},
\TT{process->fp[$L$]} is set to \TT{process->length} and
\TT{process->ap[$L$]} is set to \TT{process->length - nargs}.
Upon return, \TT{process->length} set set to \TT{process->ap[$L$]}
plus the number of values returned (\TT{CALL\ldots} \TT{immedB}).

When a \TT{BEGL} instruction of level $L$ with \TT{nvars} loop
variables (its \TT{immedA}) is compiled, \TT{mexstack::depth[$L$]}
is incremented, and then
\TT{nvars} `next' loop variables are
pushed into the symbol table and for each
\TT{mexstack::stack\_length} is incremented.

When a \TT{BEGL} instruction of level $L$ with \TT{nvars} loop
variables (its \TT{immedA}) is executed, it copies the top
\TT{nvars} variable values into the stack (so there are two copies
of these) incrementing \TT{process->length} by \TT{nvars} in the
process.

\end{indpar}

\begin{tabular}{@{}r@{~~~}l}
\verb|min::uns32 mexstack::| & \MEXSTACKKEY{stack\_limit} \\
\end{tabular}

\begin{indpar}
\TT{Stack\_limit} is used by the MEXAS assembler, but likely will not be
used by compilers.
It is set so that for a variable of location
{\tt $\ell$ < stack\_limit}\label{STACK-LIMIT}:
\begin{enumerate}
\item The variable cannot be popped from the stack by instructions
that do \underline{not} decrease either {\tt lexical\_level} or
{\tt depth[lexical\_level]}.
\item A new variable of the same name (i.e., a '{\tt next}' variable)
cannot be pushed into the stack.  (This rule may be relaxed for
function arguments.)
\end{enumerate}

These rules must be enforced by the assembler or
compiler -- they are not enforced
by {\tt mexstack}.

An intuitive way of putting this is that the working part of the
stack consists of variables of location {\tt $\ell$ $\geq$ stack\_limit}.

More specifically, {\tt stack\_limit} is set by {\tt BEG\ldots}
instructions (via the {\tt mexstack::\EOL begx} function below) as follows: \\
\hspace*{3em}\begin{tabular}{@{}ll}
\tt BEG & \tt stack\_length \\
\tt BEGL & \tt stack\_length + {\rm instruction} immedB \\
         & ({\tt immedB} is number of loop next variables) \\
\tt BEGF & \tt stack\_length + {\rm instruction} immedA \\
         & ({\tt immedA} is minimum number of expected arguments) \\
\end{tabular} \\
Here {\tt stack\_length} is the value just before the {\tt BEG\ldots}
instruction is compiled.
The {\tt END\ldots} instructions (via the {\tt mexstack::endx} function below)
restore {\tt stack\_\EOL limit} to its previous value, the value
just before the corresponding {\tt BEG\ldots} was compiled.

The {\tt mexstack::init} function (see below) zeros {\tt stack\_limit}.
\end{indpar}

\begin{tabular}{@{}r@{~~~}l}
\verb|void mexstack::| & \MEXSTACKKEY{pop\_stacks} {\tt ( void )}
\end{tabular}
\begin{indpar}
This function is \underline{not} defined by the {\tt mexstack} component
and must be defined by the compiler (because {\tt mexstack} does not
know the detailed structure of the symbol tables).
It pops from the symbol
tables all entries with lexical level greater than
{\tt mexstack::\EOL lexical\_\EOL level}, and 
also all entries with lexical level $L$ equal to
{\tt mexstack::\EOL lexical\_\EOL level} and 
depth greater than {\tt mexstack::\EOL depth[$L$]}.

Note that when called by a \TT{ENDF} instruction, the argument
variables are popped because they have the lexical level of
the function that is ending.  Similarly when called by a \TT{ENDL},
the `next' variables are popped because they have the depth of the
loop that is ending.
\end{indpar}

\subsubsection{MEX Stack Component Instruction Compilation}
\label{MEX-STACK-COMPONENT-INSTRUCTION-COMPILATION}

In order to output an instruction, a compiler using {\tt mexstack} can
do the following:

\begin{enumerate}
\item Adjust {\tt mexstack::stack\_length} to the value it will have
\underline{after} the instruction is pushed into the
{\tt mexcom::output\_module}'s code vector.

\item Push the instruction into the code vector using one of the
functions:
\begin{indpar}[1in]
{\tt mexstack::push\_instr}\pagnote{PUSH-INSTR} \\
{\tt mexstack::push\_push\_instr}\pagnote{PUSH-PUSH-INSTR} \\
{\tt mexstack::push\_jmp\_instr}\pagnote{PUSH-JMP-INSTR}
\end{indpar}

\item Note that for {\em push\_jmp\_instr}, \,{\tt mexstack::stack\_length}
is set to what it should be if the {\tt JMP\ldots} is
UNsuccessful.  If {\tt JMP\ldots} is successful, the value of $S$
in the pending jump list entry\pagnote{PENDING-JUMP-LIST} is: \\
\hspace*{1in}{\tt mexstack::stack\_length + successful\_stack\_offset}. \\
where {\em successful\_stack\_offset} is an argument of
{\tt push\_jmp\_offset}.

\end{enumerate}

Alternatively, the compiler can do the following

\begin{enumerate}
\item Push the instruction into the code vector using one of the
functions:
\begin{indpar}[1in]
{\tt mexstack::begx}\pagnote{BEGX} \\
{\tt mexstack::cont}\pagnote{CONT} \\
{\tt mexstack::endx}\pagnote{ENDX}
\end{indpar}
\item These functions adjust {\tt mexstack::stack\_length} using
their function arguments and information saved in the
block stack\pagnote{BLOCK-STACK}.  For example, for a {\tt BEGF}
instruction the {\tt nargs} argument to {\tt begx} is added by
{\tt begx} to {\tt mexstack::stack\_length}, and for the {\tt ENDF}
instruction {\tt endx} restores {\tt mexstack::stack\_length}
to its value just before the corresponding {\tt begx} was called.

\end{enumerate}

The compiler variable symbol table is only updated at the end of
a compiler language statement or just after a block beginning or block end.
At the end of assignment
statements, the variables created by the assignment statement are
pushed into the symbol table.  Just after beginning a block,
argument variables or loop `next' variables are pushed into the symbol table.
At the end of a block,
{\tt mexstack::pop\_stacks} is called by {\tt mexstack::endx}
to pop the block's variables from the symbol table.

\subsubsection{MEX Stack Component Utility Functions}
\label{MEX-STACK-COMPONENT-UTILITY-FUNCTIONS}

\verb|enum mexstack::| \MEXCOMKEY{print} \\
\verb|{| \\
\verb|    mexstack::| \MEXCOMKEY{NO\_PRINT}, \\
\verb|    mexstack::| \MEXCOMKEY{PRINT}, \\
\verb|    mexstack::| \MEXCOMKEY{PRINT\_WITH\_SOURCE} \\
\verb|}| \\
\verb|mexstack::print mexstack::| \MEXCOMKEY{print\_switch}
    \verb|= mexstack::NO_PRINT| \\
\verb|void mexstack::| \MEXCOMKEY{print\_instr}\label{PRINT-INSTR} \\
\verb|        ( min::uns32 location,| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
Print the {\tt mexcom::output\_module[location]} instruction,
as per {\tt mexstack::\EOL print\_\EOL switch},
except do not print source lines if
{\tt no\_source} is {\tt true}.
Printing is done using {\tt mexcom::\EOL input\_\EOL file} and
{\tt mexcom::\EOL input\_\EOL file->\EOL printer}.

The instruction printout has the syntax:
\begin{indpar}
\emkey{instruction-printout} ::= \\
\hspace*{2em} {\em printout-header}
    \begin{tabular}[t]{l}
    {\em op-code} \TT{T\_}{\em trace-class}
               \{ \TT{[} {\em trace-depth} \TT{]} \}\QMARK{} \\
    {\em immedA} {\em immedB} {\em immedC} {\em immedD}
	       \{ \TT{;} {\em trace-info} \}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{printout-header}\label{PRINTOUT-HEADER} ::=
    \TT{[}{\em line-number}\TT{:}{\em code-vector-location}%
                        \TT{,}{\em stack-length} \TT{]}
\end{indpar}
The source code is defined by {\tt mexcom::ouput\_module->position[location]}.
The {\em line-number} is the number of the \underline{last} source code
line (the first file line is
number \TT{1}).  The first {\em code-vector-location} is \TT{0}.
{\em Stack-length} equals {\tt mexstack::stack\_length}\pagnote{STACK-LENGTH}
plus {\tt stack\_offset} and is the compiler virtual stack length
\underline{after} the instruction is ouput.  In particular,
for {\tt PUSH\ldots} instructions
that push {\em trace-variables}\pagnote{TRACE-VARIABLE}
{\tt stack\_\EOL offset} is set to
the number of {\em trace-variables} pushed so far, as
these instructions do not update {\tt mexstack::stack\_length}.
{\em Trace-depth} is printed only if it is not zero,
{\em immedD} is printed only if it is not \TT{min::MISSING()},
and {\em trace-info} is printed only if it is not \TT{min::MISSING()}.

In some cases compiling an instruction or declaration
(e.g., \TT{MEXAS LABEL}\mexasnote{LABEL} which calls
{\tt mexstack::\EOL jmp\_\EOL target}\pagnote{JMP-TARGET})
modifies a previously compiled instruction.  In these cases the
convention is to print the
modified previously compiled instruction (without its source)
just before the instruction currently being compiled.
\end{indpar}

\verb|bool mexstack::| \MEXCOMKEY{trace\_never} \verb|= false| \\
\verb|inline void mexstack::| \MEXCOMKEY{push\_instr}\label{PUSH-INSTR} \\
\verb|        ( mex::instr & instr,| \\
\verb|          const min::phrase_position & pp =| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          min::gen trace_info = min::MISSING(),| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
If {\tt instr.trace\_class} is {\tt 0} set it to \\
\hspace*{3em}{\tt mex::op\_\EOL infos[instr.op\_\EOL code].trace\_\EOL class}.
\\
Then if {\tt mexstack::\EOL trace\_\EOL never} is {\tt true} and
additionally {\tt instr.trace\_class != mex::\EOL T\_ALWAYS}, set
{\tt instr.trace\_class} to {\tt mex::T\_NEVER}.

Then push the given parts of an instruction into the corresponding
{\tt mexcom::\EOL output\_\EOL module} stacks.

Lastly call {\tt mexstack::print\_instr} with the instruction
location and the {\tt no\_source} and {\tt stack\_offset}
arguments.  For this to work, {\tt mexstack::stack\_length}
must be set \underline{before} {\tt push\_instr} is called
so that it plus {\tt stack\_offset} (usually {\tt 0})
is the compiler virtual stack length
\underline{after} the instruction is ouput.
\end{indpar}

\verb|void mexstack:| \MEXSTACKKEY{push\_push\_instr}
                      \label{PUSH-PUSH-INSTR} \\
\verb|    ( min::gen new_name, min::gen old_name,| \\
\verb|      min::ins32 location,| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION,| \\
\verb|      bool no_source = false,| \\
\verb|      min::int32 stack_offset = 0 )|
\begin{indpar}
This function creates a {\tt PUSH\ldots} instruction that pushes
into the process stack\pagnote{PROCESS-STACK}
the value of the variable referenced by the variable stack entry
with the given {\tt location}, and executes {\tt mexstack::push\_instr}
to push that instruction into the {\tt mexcom::\EOL output\_\EOL module}
code vector.  The {\tt pp}, {\tt no\_source},
and {\tt stack\_offset} parameters
are passed to {\tt mexstack::\EOL push\_\EOL instr}.

More specifically, the created instruction is always given
trace class {\tt mex::T\_PUSH}, phrase position {\tt pp},
trace info equal to a label whose components are {\tt old\_name}
and {\tt new\_name} in that order, and the following:

If {\tt fp[L] <= location}: \\
\hspace*{3em}\verb|op_code = mex::PUSHS, immedA = SP + stack_offset - location - 1|

For {\tt K$\leq$L},~~~{\tt ap[$K$] <= location < fp[$K$]}: \\
\hspace*{3em}\verb|op_code = mex::PUSHA, immedA = location - ap[K], immedB = K|

For {\tt K<L},~~~{\tt fp[K] <= location < ap[K+1]}: \\
\hspace*{3em}\verb|op_code = mex::PUSHL, immedA = location - fp[K], immedB = K|

where \\
\hspace*{3em}\verb|L = mexstack::lexical_level| \\
\hspace*{3em}\verb|SP = mexstack::stack_length| \\
\hspace*{3em}({\tt stack\_offset} corrects {\tt SP} when pushing trace values
							      because \\
\hspace*{3em}~trace values are not recorded in the compiler variable stack)
\end{indpar}

The following function initializes the {\tt mexstack} data described above:

\verb|void mexstack:| \MEXSTACKKEY{init} \verb|( void )|
\begin{indpar}
This function initializes {\tt mexstack} data at the beginning
of the compilation of a module.  Specifically this function zeros:
\begin{indpar}\begin{verbatim}
mexstack::stack_length
mexstack::lexical_level
mexstack::depth[0]
mexstack::ap[0]
mexstack::fp[0]
mexstack::stack_limit
\end{verbatim}\end{indpar}

It also empties and re-initializes
the block and jump stacks described in subsequent sections.
However it does \underline{not} change any {\tt mexcom} data,
such as the error and warning counts.
\end{indpar}

\subsubsection{MEX Stack Component Block Management}
\label{MEX-STACK-COMPONENT-BLOCK-MANAGEMENT}

{\tt BEG\ldots}, {\tt END\ldots}, or {\tt CONT} instructions make
adjustments to the process value stack and process return stack,
and the sizes of these adjustments must be encoded in the instructions.
This encoding is done by {\tt mexstack} functions described below.
To output a {\tt BEG\ldots}, {\tt END\ldots}, or {\tt CONT} instruction,
the compiler must call one of these functions.

\verb|void mexstack:| \MEXSTACKKEY{begx} \label{BEGX} \\
\verb|    ( mex::instr & instr,| \\
\verb|      min::uns32 nvars, min::uns32 tvars,| \\
\verb|      min::gen trace_info = min::MISSING(),| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION )|
\\[0.5ex]
\verb|void mexstack:| \MEXSTACKKEY{endx} \label{ENDX} \\
\verb|    ( mex::instr & instr,| \\
\verb|      min::uns32 tvars,| \\
\verb|      min::gen trace_info = min::MISSING(),| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION )|
\\[0.5ex]
\verb|bool mexstack:| \MEXSTACKKEY{cont} \label{CONT} \\
\verb|    ( mex::instr & instr,| \\
\verb|      min::uns32 loop_depth,| \\
\verb|      min::uns32 tvars,| \\
\verb|      min::gen trace_info = min::MISSING(),| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION )|
\begin{indpar}
To output a {\tt BEG\ldots}, {\tt END\ldots}, or {\tt CONT} instruction
the compiler must first create the {\tt mex:instr} instruction and set
its {\tt op\_code} and {\tt trace\_class} (which can be set to {\tt 0}
so it will then be set by {\tt mexstack::push\_instr}).  The compiler must then
compute the instruction's position {\tt pp} and {\tt trace\_info}.
If the {\tt trace\_info} has
trace variables\pagnote{TRACE-VARIABLE}, the
compiler must output push instructions using
{\tt mexstack::\EOL push\_\EOL push\_\EOL instr}
to push the corresponding trace values into the process stack.
Note that these trace values are \underline{not} recorded in the
compiler variable stack.  The number of these trace values becomes
the {\tt tvars} parameter of the above functions.

Then the compiler must call {\tt begx} for an {\tt BEG\ldots} instruction,
{\tt endx} for an {\tt END\ldots} instruction, and {\tt cont} for
a {\tt CONT} instruction.  For {\tt BEGF} {\tt nvars} is the minimum number
of arguments expected (will become value of instruction {\tt immedA}).
For {\tt BEGL} {\tt nvars} is the number of loop `{\tt next}' variables
(will become value of instruction {\tt immedB}).  For {\tt BEG} {\tt nvars}
is ignored.  For {\tt BEGF}, {\tt tvars} must be zero (the variables traced
by {\tt trace\_info} are the expected argument values).

For {\tt BEGF}, {\tt begx} increments {\tt lexical\_level},
sets {\tt depth[lexical\_level]} to 0,
sets {\tt ap[lexical\_level]} equal to {\tt stack\_length},
and sets {\tt fp[lexical\_level]} equal to {\tt stack\_length + nvars}.
Then after calling {\tt begx}, the compiler
must push {\tt nvars} argument variables into the symbol table
incrementing {\tt stack\_length} for each push.  These variables
take their the lexical level and depth after {\tt begx} is called.

For {\tt BEGL}, {\tt begx} increments {\tt depth[lexical\_level]}.
Then after calling {\tt begx}, the compiler
must push {\tt nvars} `next' variables into the symbol table
incrementing {\tt stack\_\EOL length} for each push.  These variables,
which are the write-only loop variables updatable by `next variable = ...'
or `POP next-variable' statements inside the loop block,
take their depth after {\tt begx} is called.

All these functions fill in parts of {\tt instr} and end by calling
{\tt mexstack::push\_instr}.  To do this, {\tt begx} pushes into the
block stack\label{BLOCK-STACK} a block description containing:
\begin{enumerate}
\item The {\tt BEG\ldots}~{\tt op\_code}
\item The corresponding {\tt END\ldots}~{\tt op\_code} for checking purposes.
\item Saved value of {\tt stack\_limit}.
\item The {\tt nvars} argument
\item The location of the {\tt BEG\ldots} instruction
\end{enumerate}
This block description is popped from the block stack by the {\tt endx}
function, which uses information in the description to fill in parts of the
{\tt BEG\ldots}~and {\tt END\ldots}~instructions and to restore the compiler's
values of {\tt stack\_limit} and {\tt stack\_length} (which equals
{\tt stack\_limit} - {\tt nvars} for {\tt ENDF} and {\tt ENDL}
and {\tt stack\_limit} for {\tt END}).

{\tt Begx} and {\tt endx} also adjust the current lexical level and
depth as required by the {\tt BEG\ldots}~and {\tt END\ldots}~instructions
(e.g., {\tt BEGL} increments the depth and {\tt ENDL} decrements it).
After this adjustment, {\tt endx} calls {\tt mexstack::pop\_stacks}
to clear the symbol tables of variables and functions with
lexical level above the current lexical level, or lexical level
equal to the current lexical level and depth above the current depth
for that level.

A {\tt CONT} instruction is like a {\tt JMP} instruction except that it can
jump backwards.
The {\tt cont} function searches back through block descriptions to find
the {\tt loop\_depth}'th {\tt BEGL} description and uses it
to fill in parts of the {\tt CONT} instruction.  The {\tt cont} instruction
also increments {\tt instr.trace\_depth} (assumed initially {\tt 0})
once for very block description
it skips over in this search.
This function has no affect on {\tt stack\_length}, {\tt lexical\_level},
etc.
It returns {\tt true} on success,
but if it cannot find {\tt loop\_depth} {\tt BEGL} descriptions, it does
nothing but return {\tt false}.
\end{indpar}


\subsubsection{MEX Stack Component JMP Management}
\label{MEX-STACK-COMPONENT-JMP-MANAGEMENT}

A {\em jmp-target} is a MIN name (number, identifier string, or
label whose components are MIN names) that identifies
a code vector index value which can be used by \TT{JMP\ldots}
instructions as the point in the code vector to jump to.

\TT{JMP\ldots} instructions are pushed into the code vector
using the {\tt mexstack::push\_jmp\_instr} function, and their targets are
declared by the {\tt mexstack::jmp\_target} function.
\TT{JMP\ldots} instructions are forward-referencing: their
{\em jmp-targets} are declared after the \TT{JMP\ldots} instruction
(only {\tt ENDL} and {\tt CONT} instructions can jump backwards).
To manage \TT{JMP\ldots} instructions and their targets,
{\tt mexstack::push\_jmp\_instr}
pushes an element into a list of \skey{pending jumps}:
that is, jumps whose {\em jmp-target} has not yet been
declared.  When {\tt mexstack::jmp\_target} is called,
the pending jump list is searched for jumps with the given
{\em jmp-target},
and those that are found are resolved and removed from
the list.  Resolving involves calculating the distance
between the \TT{JMP\ldots} and its target, and the number of
process stack elements the \TT{JMP\ldots} should pop.
\TT{JMP\ldots} instructions
are allowed to pop stack elements, but cannot push them.

To permit this, an element of the pending jump list%
\label{PENDING-JUMP-LIST}
contains:
\begin{enumerate}
\item The location of the jump instruction so it can be updated
when its target is found.
\item The {\em jmp-target} MIN name.
\item The lexical level $L$ of the {\tt JMP\ldots} instruction.
\item The depth $D$ of the {\tt JMP\ldots} instruction.
\item The minimum $MD$ of $D$ and
      the depths immediately after any {\tt END} or {\tt ENDL} instructions
      encountered since the {\tt JMP\ldots} instruction.
      $MD\le D$.
\item The length $S$ of the compiler virtual stack (i.e., the value of
      {\tt mexstack::stack\_length}) just after the {\tt JMP\ldots}
      instruction pops its operands from the stack in the case that
      the {\tt JMP\ldots} is successful.
\item The minimum $MS$ of $S$ and all the compiler virtual stack lengths
      (i.e., values of {\tt mexstack::stack\_length}) immediately
      after any {\tt END} or {\tt ENDL} instructions encountered
      since the {\tt JMP\ldots} instruction.
      $MS\le S$.
\end{enumerate}

A call to {\tt jmp\_target} is legal if each of its
corresponding {\tt JMP\ldots} instructions (there can be more than one)
is such that:
\begin{enumerate}
\item
There is no {\tt ENDF} instruction between the
{\tt JMP\ldots}~and the {\tt jmp\_target}.
Equivalently, the smallest function containing the {\tt jmp\_target}
is the same as the smallest function containing the {\tt JMP\ldots}
(or both are outside any function).
\item The depth when {\tt jmp\_target} is called is \underline{equals} $MD$.
Equivalently, the smallest block containing the {\tt jmp\_target}
also contains the {\tt JMP\ldots}~instruction (which may be in an even
smaller block).
\item The value of {\tt mexstack::stack\_length} when {\tt jmp\_target}
is called \underline{equals} $MS$.
\end{enumerate}

A \TT{JMP\ldots} instruction for which a legal target exists
is called \key{resolvable}.  Other \TT{JMP\ldots} instructions
are \key{unresolvable} and are in error.

The following MEXAS assembler programs illustrate this
rule when the jump does \underline{not}
reduce depth and $M$ = the variables stack length just after the
\TT{JMP\ldots} is compiled (in MEXAS a {\tt LABEL} statement
just calls {\tt jmp\_target}):

Example 1:
\begin{indpar}\begin{verbatim}
// Program to calculate minimum ( X, Y ) in stack.
//
// Stack length is S
PUSH X
PUSH Y
// Stack length is S + 2
JMPLT ITS-X    // MS = S
// Stack length is S
PUSH Y
// Stack length is S + 1
JMP DONE       // MS = S + 1
// Stack length is S + 1
LABEL ITS-X    // JMPLT ITS-X *illegal*, MS == S != S + 1
PUSH X
// Stack length is S + 2
LABEL DONE     // JMP DONE *illegal*, MS == S + 1 != S + 2
// Stack length is S + 2
\end{verbatim}\end{indpar}

Example 2:
\begin{indpar}\begin{verbatim}
// Program to calculate minimum ( X, Y ) in stack.
//
// Stack length is S
PUSH 0 Z
// Stack length is S + 1
BEG
    // Stack length is S + 1
    PUSH X
    PUSH Y
    // Stack length is S + 3
    JMPLT ITS-X    // MS = S + 1
    // Stack length is S + 1
    PUSH Y
    // Stack length is S + 2
    POP Z
    // Stack length is S + 1
    JMP DONE       // MS = S + 1
    // Stack length is S + 1
    LABEL ITS-X    // JMPLT ITS-X legal, MS == S + 1 == S + 1
    PUSH X
    // Stack length is S + 2
    POP Z
    // Stack length is S + 1
    LABEL DONE    // JMP DONE legal, MS == S + 1 == S + 1
END
// Stack length is S + 1
\end{verbatim}\end{indpar}

The following are the {\tt mexstack} {\tt JMP}
management functions:

\verb|void mexstack:| \MEXSTACKKEY{push\_jmp\_instr}
		      \label{PUSH-JMP-INSTR} \\
\verb|        ( mex::instr & instr,| \\
\verb|          min::gen target,| \\
\verb|          const min::phrase_position & pp =| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 sucess_stack_offset = 0 )|
\begin{indpar}
{\tt Instr.op\_code} must be set to {\tt JMP\ldots}
and {\tt instr.trace\_class} may be set or may be {\tt 0}.
This function executes {\tt mexstack::push\_instr}
to push that instruction into the {\tt mexcom::\EOL output\_\EOL module}
code vector.  The {\tt pp} and {\tt no\_source}
parameters are passed to {\tt mexstack::\EOL push\_\EOL instr}.
The instruction {\tt trace\_info} is set equal to the {\tt target}.

Lastly this function creates an element of the pending jump list
for the newly output {\tt JMP\ldots} instruction.

Before calling this function, set {\tt mexstack::stack\_length} to the
value it should have it the {\tt JMP\ldots} \underline{fails}.  This
plus {\tt success\_stack\_offset} becomes the $S$ value in the jump list entry,
the effective virtual stack length if the {\tt JMP\ldots}
succeeds.
\end{indpar}

\verb|min::uns32 mexstack:| \MEXSTACKKEY{jmp\_target}\label{JMP-TARGET}
    \verb|( min::gen target )|
\begin{indpar}
Resolve all pending jumps that have the current lexical level, a minimum
depth $MD$ equal to the current depth, and the
given {\tt target}.
Resolved jumps transfer to the current location: \\
\hspace*{3em}\verb|mexcom::output_module->length|

The {\em trace\_depth} of a resolved {\tt JMP\ldots}~is set to the the depth 
of the {\tt JMP\ldots}~minus the current depth.

Resolved jumps are removed from the list
of pending jumps.  The number of resolved jumps is returned.
\end{indpar}

\verb|void mexstack::| \MEXCOMKEY{print\_label}\label{PRINT-LABEL} \\
\verb|        ( min::gen name,| \\
\verb|          const min::phrase_position & phrase_position| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
Print a label with the given {\em name} just \underline{prior} to calling
{\tt mexstack::jmp\_target} with that {\em name}.
Print as per {\tt mexstack::\EOL print\_\EOL switch},
except do not print source lines if
{\tt no\_source} is {\tt true} or {\em phrase\_position} is missing.
Printing is done using {\tt mexcom::\EOL input\_\EOL file} and
{\tt mexcom::\EOL input\_\EOL file->\EOL printer}.

The label printout has the syntax:
\begin{indpar}
\emkey{label-printout} ::=
    {\em printout-header} \ttkey{LABEL} {\em name}
\end{indpar}
In {\em printout-header}\pagnote{PRINTOUT-HEADER}
the {\em code-vector-location} is
{\tt mexcom::ouput\_module->length} and
the {\em stack-length} equals the current value of
{\tt mexstack::stack\_length}\pagnote{STACK-LENGTH}
plus {\tt stack\_\EOL offset} (usually {\tt 0}).
\end{indpar}

\verb|min::uns32 mexstack:| \MEXSTACKKEY{jmp\_clear} \verb|( void )|
\begin{indpar}
Delete all pending jumps with the current lexical level (making these
jumps unresolved and in error), and
call {\tt mexcom::compile\_error} to indicate which pending jumps
were deleted.  Return the number of deleted pending jumps.

This is called by {\tt mexstack::endx} for each {\tt ENDF} instruction.

{\bf This function must also be called by the compiler
at the end of compiling a module.}

Pending jumps are added at the end of the pending jump list, and
as this function is called whenever the lexical level decreases by one,
pending jumps are sorted by ascending lexical level in the pending jump list.
\end{indpar}

\verb|min::uns32 mexstack:| \MEXSTACKKEY{jmp\_update} \verb|( void )|
\begin{indpar}
For all pending jumps with the current lexical level $L$ decrease
their minimum depth $MD$ if necessary to {\tt mexstack::depth[$L$]}
and decrease their minimum stack $MS$ if necessary to 
{\tt mexstack::stack\_length}.  Return the number of elements
of lexical level $L$, even those not modified.

This function is called by {\tt mexstack::endx} for {\tt END} and
{\tt ENDL} instructions just after {\tt mexstack::depth[$L$]}
and {\tt mexstack::stack\_length} have been decremented
(restored to their values just before the corresponding {\tt BEG} or
{\tt BEGL} instructions were output).

This function need \underline{not} be called by the compiler, but
could be called to count the number of pending jumps with the
current lexical level (without modifying any pending jumps).
\end{indpar}

\clearpage

\printindex

\end{document}
