% Minimal Runtime System
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{wasysym}
\usepackage{makeidx}
% \usepackage{pictex} (obsolete? not available under CentOS 7)
\usepackage{upquote} % (imported to local directory
                     % ; not available under CentOS 7)
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\LAQUOTEBOX}
\begin{lrbox}{\LAQUOTEBOX}
{\tt \guillemotleft}
\end{lrbox}
\newcommand{\LAQUOTE}{\usebox{\LAQUOTEBOX}}

\newsavebox{\RAQUOTEBOX}
\begin{lrbox}{\RAQUOTEBOX}
{\tt \guillemotright}
\end{lrbox}
\newcommand{\RAQUOTE}{\usebox{\RAQUOTEBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MEXKEY}[1]%
	   {\TT{#1}\ttindex{mex::#1}\ttindex{#1}}
\newcommand{\MEXLKEY}[2]%
           {\TT{#1#2}\index{mex::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MEXIKEY}[2]%
           {\TT{#1}\ttindex{mex::#2}\ttindex{#2}}
\newcommand{\MEXMKEY}[2]%
           {\TT{#1}\ttmindex{mex::#1}{#2}\ttmindex{#1}{#2}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Minimal Runtime System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Draft 1a)}

\author{Robert L. Walton}

\date{June 18, 2023}
 
\maketitle

\newpage
\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Runtime System Execution Engine.

MEX is a stack-oriented assembly language with some higher level
language features.

TBD

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{prog}{abbreviation}	& program \\
\end{tabular}
\end{indpar}

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test scripts such as \TT{mex\_interface\_test.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}



The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace}\label{mex::} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable stack.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, the compiler may reference the interfaces
of pre-existing modules.

Immediately after a module is compiled, it is executed.  The
resulting execution stack (see \itemref{STACKS}) becomes the
modules global variable stack.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector, information
is added to the module's interface, and variables are pushed into the
the module's global variable stack.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called using the module interface,
the function code block instructions are executed.  A function
can itself contain another function, and each function has
its own interface.  However, these function interfaces are
only used during compilation of the function code, and cannot
be accessed by other modules, so they are part of the compiler
and not part of MEX.

MEX does \underline{not} itself provide a compiler, but it
assumes certain compilation behaviors.

\subsection{Stacks}
\label{STACKS}

MEX is stack oriented.  A stack is a vector of \TT{min::gen}
values.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Values may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector.

In MEX the only operations that pop the stack are returns from
functions and ends of blocks.

MEX assumes that variables in the stack are read-only, unless
they are being assigned values by a block of code.  MEX assumes
that the variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and them pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, it does not pop its stack, but
leaves the stack as the module's global variable stack.

The number of values above the current function arguments in the
stack (or the number above the beginning of the stack for a
module execution) is a parameter of the current instruction known
to the compiler.  To maintain this rule, forward jumps must push
null values into the stack to take the place of the values that would be
pushed by the code being skipped.  Backward jumps are not allowed.

Forward jumps that leave a block may pop values from the stack
instead of pushing values.  In general a jump may first pop
values from the stack, and then push null values.


MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler repoints the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and repoint {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the complier will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such vallues
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em jump-instruction} \\
		  $|$ & {\em push-instruction} \\
		  $|$ & {\em call-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{ADD} $|$ \TT{ADDI} \\
    $|$ & \TT{SUB} $|$ \TT{SUBR} $|$ \TT{SUBI} $|$ \TT{SUBRI} \\
    $|$ & \TT{MUL} $|$ \TT{MULI} \\
    $|$ & \TT{DIV} $|$ \TT{DIVR} $|$ \TT{DIVI} $|$ \TT{DIVRI} \\
    $|$ & \TT{FLOOR} $|$ \TT{FLOORR} $|$ \TT{FLOORI} $|$ \TT{FLOORRI} \\
    $|$ & \TT{CEIL} $|$ \TT{CEILR} $|$ \TT{CEILI} $|$ \TT{CEILRI} \\
    $|$ & \TT{TRUNC} $|$ \TT{TRUNCR} $|$ \TT{TRUNCI} $|$ \TT{TRUNCRI} \\
    $|$ & \TT{ROUND} $|$ \TT{ROUNDR} $|$ \TT{ROUNDI} $|$ \TT{ROUNDRI} \\
    $|$ & \TT{NEG} $|$ \TT{ABS} \\
    $|$ & \TT{LOG} $|$ \TT{LOG10} $|$ \TT{LOGE} \\
    $|$ & \TT{EXP} $|$ \TT{EXP10} $|$ \TT{EXPE} \\
    $|$ & \TT{SIN} $|$ \TT{ARCSIN} \\
    $|$ & \TT{COS} $|$ \TT{ARCCOS} \\
    $|$ & \TT{TAN} $|$ \TT{ARCTAN} \\
    $|$ & \TT{COTAN} $|$ \TT{ARCCOTAN} \\
    $|$ & \TT{POWER} \\
    \end{tabular}
\\[0.5ex]
\emkey{jump-instruction}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{JMP} \\
    $|$ & \TT{JMPEQ} $|$ \TT{JMPNE} $|$ \TT{JMPEQI} $|$ \TT{JMPNEI} \\
    $|$ & \TT{JMPLT} $|$ \TT{JMPLEQ} $|$ \TT{JMPLTI} $|$ \TT{JMPLEQI} \\
    $|$ & \TT{JMPGT} $|$ \TT{JMPGEQ} $|$ \TT{JMPGTI} $|$ \TT{JMPGEQI} \\
    $|$ & \TT{BREAK} $|$ \TT{CONTINUE} \\
    \end{tabular}
\\[0.5ex]
\emkey{push-instruction} ::= \TT{PUSH} $|$ \TT{PUSHI} $|$ \TT{PUSHG}
\\[0.5ex]
\emkey{call-instruction} ::= \TT{CALL} $|$ \TT{CALLG} $|$ \TT{RET}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{instr}
\LABEL{MEX::INSTR} \\
\verb|{                                  | \\
\verb|    min::uns16 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                                  | \\
\end{tabular}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::code\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::code\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module\_insptr}

\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttikey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module}.  This information can be used to
print trace and error messages.

The \ttikey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code.
This stack contains global variables exported by the module.

The \ttikey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.  However the compiler
may choose to use the interface in \itemref{INTERFACE}.

\subsection{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
and a return stack.  Specifically:

\begin{indpar}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{pc}
\LABEL{MEX::PC} \\
\verb|{                                  | \\
\verb|    mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|    min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                                  | \\
\end{tabular}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{process\_header}
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|    mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{sp}{in {\tt mex::process\_header}} \\
\verb|    min::packed_vec_insptr<mex::pc> | & \TTMKEY{return\_stack}
                                              {in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{rp}{in {\tt mex::process\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process\_insptr}

\end{indpar}

\subsection{Instructions}
\label{INSTRUCTIONS}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code} and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD};
    // Pop 2 values and push their sum.
mex::instr an_add_immediate_instruction = {mex::ADDI,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG};
    // Do nothing.
mex::instr an_end_instruction = {mex::END,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,10,5,32,min::MISSING()};
    // Pop 10 values and discard them, then push min::MISSING()
    // 5 times, then add 32 to program counter.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\ref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations are used; there are no errors
but \TT{NaN}s may be returned as results.

\begin{boxedfigure}

\begin{tabular}{|l|l|}
\hline
\TT{ADD}/\TT{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\TT{ADDI}/\TT{MULI}
    & Adds/multiplies the top value by \TT{immedD}.
\\\hline
\TT{SUB}/\TT{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\TT{SUBI}
    & Subtract \TT{immedD} from top value.
\\\hline
\TT{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\TT{DIV}/\TT{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\TT{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\TT{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\TT{MOD}/\TT{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first value popped divided by \\
    & the first/second value popped.
\\\hline
\TT{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\TT{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\end{tabular}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\section{Interface}
\label{INTERFACE}


\clearpage

\appendix

\centerline{\Large \bf Appendices}

TBD

\bibliographystyle{plain}
\bibliography{min}

\printindex

\end{document}
