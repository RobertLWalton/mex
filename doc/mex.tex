% Minimal Runtime System
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{wasysym}
\usepackage{makeidx}
\usepackage{upquote}
\usepackage{needspace}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MEXKEY}[1]%
	   {\TT{#1}\ttindex{mex::#1}\ttindex{#1}}
\newcommand{\MEXLKEY}[2]%
           {\TT{#1#2}\index{mex::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MEXIKEY}[2]%
           {\TT{#1}\ttindex{mex::#2}\ttindex{#2}}
\newcommand{\MEXMKEY}[2]%
           {\TT{#1}\ttmindex{mex::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MEXCOMKEY}[1]%
	   {\TT{#1}\ttindex{mexcom::#1}\ttindex{#1}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Minimal Runtime System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Version 1)}

\author{Robert L. Walton}

\date{May 25, 2024}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Runtime System Execution Engine.

MEX is layered on top of the Minimal Runtime System.

MEX is stack-oriented and block-oriented.  It computes with
\ttkey{min::gen} values.

\section{Abbreviations}
\label{ABBREVIATIONS}

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{except}{abbreviation}	& exception \\
\ttmkey{fp}{abbreviation}	& frame pointer \\
\ttmkey{immed}{abbreviation}	& immediate \\
\ttmkey{info}{abbreviation}	& information \\
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{jmp}{abbreviation}	& jump (go to) \\
\ttmkey{nargs}{abbreviation}	& number of arguments \\
\ttmkey{nresults}{abbreviation}	& number of results \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{ret}{abbreviation}	& return \\
\ttmkey{sp}{abbreviation}	& stack pointer \\
\end{tabular}
\end{indpar}

In addition abbreviations of the MIN Runtime System are used
in names of types and functions of that system.

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test files such as \TT{Makefile} and
                               \TT{mex\_compile\_test\_1.mex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}

MEX is layered on top of MIN, the Minimal Runtime System, and
includes \ttkey{min.h}.

The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}\ttindex{mex.h}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable vector.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, it is loaded into memory
ready for execution.  There are no MEX `binary' files.

Interfaces are provided by and used by the compiler, and
not by MEX.  Typically a module may reference interfaces
of previously compiled modules.

Immediately after a module is compiled, it is executed.  A copy of the
resulting execution stack (see Stacks, \itemref{STACKS}) becomes the
module's \key{global variable vector}, i.e., its vector of
global variables.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector
and variables are added to the end of
the module's global variable stack.  The compiler should add
interfaces to new global variables and new module functions, but
this is a matter for the compiler, and not for MEX.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called
the function code block instructions are executed.  A function
can itself contain another function.

MEX does \underline{not} itself provide a compiler, but it
assumes a few compilation behaviors.

\section{Stacks}
\label{STACKS}

MEX is stack oriented.  A \key{stack} is a vector of
elements.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Elements may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector. The length of the stack is referred to as the
\key{stack pointer} and is one greater than the vector index of the top of
the stack, unless the stack is empty and its vector length is zero.

The word `stack' without qualification refers to the main
processing stack, which is a stack of \TT{min::gen} values.
MEX supports the programming paradigm
in which variables in the stack are read-only, unless
they are being assigned values by a block of code.  Using this paradigm
variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values that code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.  MEX assumes that to allow
a form of variable update the compiler implements `next variables'
as described in Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.
The arguments and all the values the function pushes into the
stack are called the function's \key{frame}.  The stack pointer
value when the function begins is called the function's
\key{frame pointer}, and points just after the last argument
of the function.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and then pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, the module's
global variable vector is created by making
a copy of the final execution stack.

Backward jumps are only allowed at the end of a loop blocks.
These pop the values pushed into the stack by the loop block.
Forward jumps are the only means of exiting a loop block.  These
pop all values pushed into the stack by code between the jump
and the target of the jump.

There are special considerations involving the stack if the
compiler allows functions to be nested inside other functions.
These considerations are described in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

\subsection{Next Variables and Loops}
\label{NEXT-VARIABLES-AND-LOOPS}

MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler re-points the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\label{EXAMPLE-LOOP}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and re-point {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the compiler will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such values
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Nested Functions}
\label{NESTED-FUNCTIONS}

The \key{lexical nesting level}\label{LEXICAL-NESTING-LEVEL}
of a function is defined as follows.

If the function $F$ is not inside any other function, $F$ has
level 1.

If the function $F$ is inside a function and $F'$ is the smallest
function containing $F$, and if $F'$ has level $L'$, then $F$
has level $L=L'+1$.

If $F$ is a function lexically inside another function $F'$, then $F$ can
reference the variables that $F'$ can reference when $F$ is
defined.  To locate these variables, knowing the frame pointer for the
execution of $F'$ is sufficient.  The frame pointer is defined as the
stack pointer that points just after the last argument to $F'$,
or equivalently, the stack
pointer when $F'$ is called.

So how do we compute the frame pointer of $F'$?  To see how,
we need to analyze the situation in more detail.

We define the level of an instruction to be the level of the
smallest function lexically containing the instruction, or \TT{0} if the
instruction is not lexically inside any function.  If $E_I$ is an
execution of an instruction $I$, the level of $E_I$ is the
level of $I$.

\begin{indpar}
{\bf Lemma}~~~An execution of a \TT{CALL\ldots} instruction of
level $L$ must call a function of level $L'\leq L+1$.
\end{indpar}
\begin{indpar}
{\bf Proof}: To be visible to the \TT{CALL\ldots}
instruction, a function must be either defined within functions
lexically containing the \TT{CALL\ldots} instruction, in which case the
function cannot have a level greater than $L+1$, or the function must be global,
in which case it has level \TT{1}.  QED
\end{indpar}

Let $E$ be the sequence of instruction executions in an
incomplete program execution.
An execution of a function $F$ within $E$ is defined as all the
instruction executions from the first instruction execution
after $F$ is called until the last instruction execution which returns
from the call of $F$.  A function execution can be complete, meaning
it ends with a return from the function, or incomplete.  A function execution
$E_i$ contains the function executions of every function called by a 
a \TT{CALL\ldots} instruction execution in $E_i$.

The lexical level of a function execution is defined as the lexical level
of its function.

The \underline{incomplete} function executions in $E$ are ordered by size, and
identically ordered by the sequence of their first instruction executions.
(This is the same order as the order of their return stack entries
as per the description of \TT{CALLM} and \TT{RET} in
Figure~\itemref{FUNCTION-INSTRUCTIONS}).

\begin{indpar}
{\bf Corollary 1 of Lemma}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of lexical levels
$L_1$ and $L_2$.  Let $E_2$ immediately follow $E_1$ in the size
ordering.  Then $L_2\leq L_1+1$.
\end{indpar}
\begin{indpar}
{\bf Proof}: The \TT{CALL\ldots} to start $E_2$ must be in $E_1$
and cannot be in a complete function execution inside $E_1$ so
the \TT{CALL\ldots} must have level $L_1$.  QED
\end{indpar}

\begin{indpar}
{\bf Corollary 2 of Lemma}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of functions $F_1$ and $F_2$ which have levels $L_1$ and $L_2$
and let  $E_2$ immediately follow $E_1$ in the size
ordering.  If further there is a function $F$ of level $L$ that lexically
contains $F_1$, and if $L_1\geq L$ and $L_2>L$, then $F$ lexically contains
$F_2$.
\end{indpar}
\begin{indpar}
{\bf Proof}: The \TT{CALL\ldots} to start $E_2$ must be in $E_1$
and cannot be in a complete function execution inside $E_1$ so
the \TT{CALL\ldots} must have level $L_1$.  This \TT{CALL\ldots}
is lexically inside $F$ by hypothesis, and the only functions visible
to the \TT{CALL\ldots} that have levels $>L$ are also inside $F$.
Therefore $F_2$ is lexically inside $F$.
\end{indpar}

\begin{indpar}
{\bf Corollary 3 of Lemma}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of lexical levels
$L_1$ and $L_2$, let $E_2\subset E_1$, and let $L_2>L'>L_1$.
Then there must be an incomplete function execution $E'$ in $E$
that is in between $E_1$ and $E_2$ in the sequence of incomplete function
executions of $E$ and that has level $L'$.
\end{indpar}
\begin{indpar}
{\bf Proof}: Stepping through the sequence from $E_1$ to $E_2$,
the levels at each step can increase by at most $1$ (by Corollary 1),
so no level can be skipped over.  QED.
\end{indpar}

\begin{indpar}
{\bf Theorem}~~~If $F'$ is a function of level $L'$ that lexically
contains function $F$ of level $L$,
then during the execution of instructions in $F$
there is a smallest incomplete execution of $F'$ that is also
the smallest incomplete function execution of level $L'$.
\end{indpar}

\begin{indpar}
{\bf Proof of Theorem}: If the currently executing instruction is in $F$
it is in the smallest incomplete function execution, and this has level $L$.
The largest incomplete function execution
must have level $1$ and the last incomplete function execution has level
$L$, and by hypothesis $1\leq L'<L$,
so by Corollary 3 there is an incomplete function execution of level $L'$
and hence a smallest one $E'$.  Let $F''$ be its function.  Then all the
incomplete function executions between $E'$ and the end of the sequence
must have lexical level $>L'$, for otherwise applying Corollary 3 again
there would be a smaller incomplete function execution of level $L'$.

Then by applying Corollary 2 recursively to successive incomplete function
executions after $E'$, we deduce that all are executions of functions
lexically inside $F''$, and therefore $F''$ is the unique function of
level $L'$ containing $F$, and therefore $F''=F'$.

QED
\end{indpar}


During execution MEX computes \TT{fp[$L'$]} as the frame pointer
of the smallest (most recently called)
incomplete function execution of level $L'$,
and therefore
during the execution of instructions in $F$, \TT{fp[$L'$]} is the
frame pointer of $F'$.

If follows that during an execution of an instruction in $F$
the variables of $F'$ can be accessed by
\TT{PUSHL} with \TT{immedB} = $L'$ (Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}),
and the arguments of $F'$ can be
accessed by \TT{PUSHA} with \TT{immedB} = $L'$
(Figure~\itemref{FUNCTION-INSTRUCTIONS}).
The global variables can be accessed by \TT{PUSHL} with \TT{immedB} = $0$
or by \TT{PUSHG}
(Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}).

\section{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em stack-and-flow-control-instruction} \\
		  $|$ & {\em function-instruction} \\
		  $|$ & {\em housekeeping-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction} ::= \\
\hspace*{3em}
    instructions in Figure \itemref{ARITHMETIC-INSTRUCTIONS}
\\[0.5ex]
\emkey{stack-and-flow-control-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
     excepting \TT{BEG}, \TT{END}, \TT{BEGL}, and \TT{ENDL}
\\[0.5ex]
\emkey{function-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{FUNCTION-INSTRUCTIONS}
     excepting \TT{BEGF} and \TT{ENDF}
\\[0.5ex]
\emkey{housekeeping-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{HOUSEKEEPING-INSTRUCTIONS}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{instr}
\LABEL{MEX::INSTR} \\
\verb|{                   | \\
\verb|    min::uns8 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_class}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_depth}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{unused}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::code\_header}} \\
\verb|    min::gen | & \TTMKEY{name}{in {\tt mex::code\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{trace\_info}
                                              {in {\tt mex::code\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module\_ins}
\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttmkey{name}{of module} member of the \TT{module} is derived
from the module's file name by removing any \TT{.mex} extension.
If the module is input from the standard input, and not a file,
the \TT{name} is \TT{min::MISSING()}.

The \ttmkey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module} (may be \TT{min::MISSING()} is input was
from standard input).  In particular, the \TT{min::phrase\_\EOL position}
of instruction \TT{m[i]} is \TT{m->position[i]}.
This information can be used to
print trace and error messages.

The \ttmkey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code
(initializing the module).
This stack contains values of global variables exported by the module.

The \ttmkey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.

The \ttmkey{trace\_info}{of module} member of the \TT{module} points
at a vector of \TT{min::gen} values such that for module \TT{m},
\TT{m->\EOL trace\_\EOL info[i]} gives information that can be used
to print trace messages for instruction \TT{m[i]}.  See
Instruction Tracing, \itemref{INSTRUCTION-TRACING}.

\section{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
a return stack, and other parameters.  Specifically:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{pc}%
\LABEL{MEX::PC} \\
\verb|{                   | \\
\verb|mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{ret}%
\LABEL{MEX::ret} \\
\verb|{                   | \\
\verb|mex::pc | & \TTMKEY{saved\_pc}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_level}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_fp}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_nargs}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{nresults}{in {\tt mex::ret}} \\
\verb|}                   | \\
\end{tabular}
\\[1ex]
\verb|const unsigned mex::|\MEXKEY{max\_lexical\_level}\verb| = 16|%
\LABEL{MEX::MAX_LEXICAL_DEPTH}
\\[1ex]
\begin{tabular}{@{}r@{}l}
\verb|struct                         mex::| & \MEXKEY{process\_header}%
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                   | \\
\verb|min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|min::printer | & \TTMKEY{printer}{in {\tt mex::process\_header}} \\
\verb|mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|min::packed_vec_insptr<mex::ret> | & \TTMKEY{return\_stack}%
                                              {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{level}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{fp}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{nargs}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{trace\_depth}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{trace\_flags}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_mask}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_accumulator}%
                         {in {\tt mex::process\_header}} \\
\verb|bool | & \TTMKEY{optimize}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{optimized\_counter}%
                         {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter\_limit}{in {\tt mex::process\_header}} \\
\verb|mex::state | & \TTMKEY{state}%
                                   {in {\tt mex::process\_header}} \\
\verb|}                                    | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|enum         mex::| & \MEXKEY{state}%
\LABEL{MEX::STATE} \\
\verb|{                 | \\
\verb|mex::| & \TTMKEY{NEVER\_STARTED}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RUNNING}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{MODULE\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{CALL\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{COUNTER\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{STACK\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RETURN\_STACK\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{ERROR\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{JMP\_ERROR}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{FORMAT\_ERROR}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{EXCEPTS\_ERROR}{in {\tt mex::state}} \\
\verb|}                 | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}

\end{indpar}

A \TT{mex::process} \TT{p} is a vector of \TT{min::gen} elements which
is the process \key{stack}, with the last element being the top
of the stack (\TT{p[p->length-1]}) and the first element
being the bottom of the stack (\TT{p[0]}), assuming the stack
is not empty.  The \key{stack pointer} (a.k.a., \TT{sp})
is \TT{p->length}, and is the index of an element of
the process vector which is just beyond the top of the stack,
and is also the length of the stack.

To push a value into the stack,
you store the value in the element \TT{p->length}
indexes, and then add +1 to \TT{p->length}.
To pop a value, you add -1 to \TT{p->length}, and then
read the value indexed by \TT{p->length}.
We require that \TT{0 <= p->length <= p->max\_length} at all times,
and \underline{never} increase \TT{p->max\_length} during execution
(but see Note~\ref{LIMIT-STOP-NOTE} on page~\pageref{LIMIT-STOP-NOTE}).

A \ttkey{pc}, or \key{program counter}, is a pointer to a module,
which is a code vector, and an index in that vector of an instruction.
Thus a \TT{pc} points at an instruction.  The \TT{pc} member of a
process (\TT{p->pc}) is the \key{current program counter} of that process.

The value of \TT{p->level} is the current lexical level of the
process, i.e., the lexical level of the instruction pointed at
by \TT{p->pc}.  \TT{p->fp[$L$]} is the frame pointer for the
most recently started currently executing function of level $L$.
\TT{p->nargs[$L$]} is the number of arguments passed to this
function.  Note that the list of currently executing functions
in order of being called is not monotonic in level: a function
of level $L$ may call a function of level $\leq L+1$.

The process's frame pointer member \TT{fp[\ldots]}
is further explained in Nested Functions,
\itemref{NESTED-FUNCTIONS}.  The value of \TT{fp[0]}, the frame pointer
for lexical level \TT{0} (outside all functions), is always \TT{0}.

The \ttkey{return\_stack} is used by \TT{CALL} and \TT{RET}
instructions.  The value of \TT{return\_stack->\EOL length},
a.k.a.~the \key{return stack pointer}, is the index of the element of
the return stack which is just beyond the top of the stack,
and is also the length of the stack.  If the stack is not empty,
\TT{p->return\_stack[return\_stack->length-1]} is the top of the stack.

A \TT{CALL} instruction pushes a \TT{mex::ret} value
into the return stack.  This contains a \TT{saved\_pc} member
pointing at the \TT{CALL} instruction.
A \TT{RET} instruction pops a \TT{mex::ret} value from
the \TT{return\_stack} and stores its \TT{saved\_pc}
in the current program counter
of the process (\TT{p->pc}), and then increments that program counter
by \TT{1}.

The \TT{CALL} also changes the process \TT{level} to the lexical level
of the function being called (determined by the function's \TT{BEGF}
instruction) and if this level is $L$, changes \TT{fp[$L$]} to the
frame pointer of that function and \TT{nargs[$L$]} to the number of
arguments passed to that function.  Before making changes the \TT{CALL}
saves these values in the \TT{mex::ret} value.
The \TT{nresults} member of \TT{mex::ret}
is the number of function results expected by the call.
See the \TT{CALL} instruction in Figure~\itemref{FUNCTION-INSTRUCTIONS}
for specifics.

The process's \TT{counter} is incremented once every time an instruction
finishes execution.  The process stops when
\TT{counter >= counter\_\EOL limit}.   The \TT{optimized\_counter}
is incremented (along with the \TT{counter})
for every instruction executed in optimize mode;
it has no limit and is for information purposes only.

When the process terminates, \TT{state} is set.  For details
see \TT{mex::run\_process}, \pagref{MEX::RUN_PROCESS},

The \TT{trace\_depth}, \TT{trace\_flags}, \TT{excepts\_mask},
\TT{excepts\_accumulator}, and \TT{optimize}
members of a process
are explained in Arithmetic Exceptions, \itemref{ARITHMETIC-EXCEPTIONS}
and Instruction Tracing, \itemref{INSTRUCTION-TRACING}.


\section{Instructions}
\label{INSTRUCTIONS}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code}, \TT{trace\_class}, \TT{trace\_\EOL depth},
and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.
\TT{Trace\_class} is explained in Instruction Tracing,
\itemref{INSTRUCTION-TRACING}, and
\TT{trace\_depth} is explained in Trace Depth,
\itemref{TRACE-DEPTH}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD, mex::T_AOP};
    // Pop 2 values and push their sum.
    // mex::T_AOP is the trace class of all arithmetic
    // operations.
mex::instr an_add_immediate_instruction =
        {mex::ADDI,mex::T_AOP,,,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG, mex::T_BEG};
    // Do nothing.
mex::instr an_end_instruction = {mex::END,mex::T_END,,,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,mex::T_JMP,1,,10,,32};
    // Pop 10 values and discard them, then decrement the process's
    // trace_depth by 1, then add 32 to program counter to skip
    // 32 instructions.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\itemref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations and the C \TT{math.h}
library are used.  See Arithmetic Exceptions,
\itemref{ARITHMETIC-EXCEPTIONS} for error
handling.

The stack and flow control instruction set is in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
See Stacks, \itemref{STACKS}, for an overview of stack handling.

The function instruction set is in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.
See Nested Functions, \itemref{NESTED-FUNCTIONS},
for details concerning nested functions.

The housekeeping instruction set is in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.

\pagebreak


\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{ADD}/\ttkey{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\ttkey{ADDI}
    & Adds \TT{immedD} to the top value.
\\\hline
\ttkey{MULI}
    & Multiplies the top value by \TT{immedD}.
\\\hline
\ttkey{SUB}/\ttkey{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\ttkey{SUBI}
    & Subtract \TT{immedD} from the top value.
\\\hline
\ttkey{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\ttkey{DIV}/\ttkey{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\ttkey{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\ttkey{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\ttkey{MOD}/\ttkey{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first popped divided by \\
    & the first/second popped.
\\\hline
\ttkey{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\ttkey{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\ttkey{FLOOR}/\ttkey{CEIL}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward minus/plus infinity.
\\\hline
\ttkey{TRUNC}/\ttkey{ROUND}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward zero/the-nearest-integer, \\
    & with nearest halfway cases rounded to the even integer.
\\\hline
\ttkey{NEG}/\ttkey{ABS}
    & Replace the top value by its negation/absolute-value.
\\\hline
\ttkey{LOG}/\ttkey{LOG10}
    & Replace the top value by its log base e/10.
\\\hline
\ttkey{EXP}/\ttkey{EXP10}
    & Replace the top value by e/10 to the top value power.
\\\hline
\ttkey{SIN}/\ttkey{COS}/\ttkey{TAN}
    & Replace the top value by its sin/cos/tan.
\\\hline
\ttkey{ASIN}/\ttkey{ACOS}/\ttkey{ATAN}
    & Replace the top value by its arc- sin/cos/tan.
\\\hline
\ttkey{ATAN2}/\ttkey{ATAN2R}
    & Pop 2 values, then push the arc-tangent of the first/second \\
    & popped (x value) divided by the second/first popped \\
    & (y value).
\\\hline
\ttkey{POWI}
    & Replace the top value by the top value to the \TT{immedA} power.
\\\hline
\end{tabular}
\end{center}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\pagebreak

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{PUSHS}
    & Read the value at \TT{sp[- immedA - 1]} and push it into the \\
    & stack; so \TT{immedA} = 0 duplicates the top value.
\\\hline
\ttkey{PUSHL}
    & Push the stack vector value with index \TT{fp[immedB] + immedA}. \\
    & But if \TT{immedB == 0} and \TT{m->globals} is not \TT{min::NULL\_STUB} \\
    & for the module \TT{m} of the current program counter, push \\
    & \TT{m->globals[immedA]} instead.  Note \TT{fp[0] == 0}.
\\\hline
\ttkey{PUSHI}
    & Push \TT{immedD} into the stack.
\\\hline
\ttkey{PUSHG}
    & Push \TT{m->globals[immedA]} into the stack, where \TT{m} is \\
    & the module pointed at by \TT{immedD}
\\\hline
\ttkey{POPS}
    & Store the top value in the stack into \TT{sp[- immedA - 1]}, and \\
    & then pop the stack once; so \TT{immedA} = 0 discards the top value.
\\\hline
\ttkey{JMP}
    & Subtract \TT{immedA} from \TT{sp} (popping the stack \TT{immedA} times),
      then \\
    & add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
      It is \\
    & illegal for \TT{immedC} = 0 (\TT{JMP} would jump to itself).
\\\hline
\ttkey{JMPEQ}/\ttkey{JMPNE}
    & Pop 2 values and compare them.  If they are equal/not-equal \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\ttkey{JMPLT}/\ttkey{JMPLEQ}
    & Ditto, but \TT{JMP} if the second popped is \\
    & less-than/less-than-or-equal-to the first popped.
\\\hline
\ttkey{JMPGT}/\ttkey{JMPGEQ}
    & Ditto, but \TT{JMP} if the second popped is \\
    & greater-than/greater-than-or-equal-to the first popped.
\\\hline
\ttkey{BEG}/\ttkey{END}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.
\\\hline
\ttkey{BEGL}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.  Then \\
    & take the top \TT{immedB} values in the stack and push a copy of \\
    & them all into the stack, preserving stack ordering.
\\\hline
\ttkey{ENDL}/\ttkey{CONT}
    & First subtract \TT{immedA} from \TT{sp}
      (popping the stack \TT{immedA} times), \\
    & then take the top \TT{immedB} values in the stack and copy them \\
    & to the next lower \TT{immedB} values in the stack, then subtract \\
    & \TT{immedC} from the \TT{pc} (jumping backwards to just after \\
    & the associated \TT{BEGL}).
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Stack and Flow Control Instructions}
\label{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
\end{boxedfigure}

\pagebreak

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{BEGF}
    & Add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
    \\[0.5ex]
    & Also used to provided data for \TT{CALL} as follows: \TT{immedB} is the \\
    & target function's lexical nesting level (\pagref{LEXICAL-NESTING-LEVEL}),
      and \TT{immedA} is the \\
    & minimum number of arguments expected.
\\\hline
\ttkey{ENDF}
    & Same as a \TT{RET} instruction (below) with
      \TT{immedA} = \TT{immedC} = 0. 
\\\hline
\ttkey{CALLM}
    & Push a \TT{mex::ret} value $e$ into the return stack, setting
      \TT{$e$.saved\_pc} \\
    & to point to the \TT{CALLM} instruction, and then
      set the \TT{index} \\
    & of \TT{p->pc} to \TT{immedC}, which must reference a
      \TT{BEGF} instruction.
    \\[0.5ex]
    & Check that the \TT{CALL} \TT{immedA} value, the number of arguments \\
    & passed, is at least as great as the \TT{BEGF}
      \TT{immedA}, the minimum \\
    & number of arguments expected.  Take the target 
      function's lexical \\
    & level $L$ from the \TT{BEGF} \TT{immedB} value, and save
      \TT{p->\{level,fp[$L$],} \\
    & \TT{nargs[$L$]\}} in \TT{$e$.saved\_\{level,fp,nargs\}}.
       Next set \TT{p->level} \\
    & to $L$, \TT{p->fp[$L$]} to \TT{sp}, \TT{p->nargs[$L$]} to \TT{immedA},
      and \TT{$e$.nresults} \\
    & to \TT{immedB}.
    \\[0.5ex]
    & Lastly add +1 to the process current \TT{pc} to skip the \TT{BEGF}.
\\\hline
\ttkey{CALLG}
    & Same as \TT{CALLM} but also set the process's \TT{pc} member's 
                                                           \TT{module} \\
    & member from \TT{immedD} (which must convert to a \TT{mex::module}).
\\\hline
\ttkey{RET}
    & Check that \TT{immedB} equals \TT{p->level}.  Then subtract
      \TT{immedA} from \\
    & \TT{sp} (popping the stack \TT{immedA} times).  The
      values popped are \\
    & always trace values.  Pop element $e$ from the
      return stack and \\
    & check that \TT{immedC} equals \TT{$e$.nresults}.  Pop \TT{immedC}
      values from \\
    & the stack and save them.  Set \TT{sp} to
      \TT{fp[immedB] - nargs[immedB]} \\
    & (popping the current function execution stack values).   Then push \\
    & the saved values into the stack.  Lastly, restore the process \\
    & members saved in \TT{$e$.saved\_\{pc,level,fp,nargs\}}, and \\
    & increment the restored \TT{pc} by \TT{1}.
\\\hline
\ttkey{PUSHA}
    & Push the stack vector value with index \TT{fp[immedB] - immedA}. \\
    & \TT{immedA} must be 
      in the range \TT{[1,p->nargs[immedB]]}.
\\\hline
\ttkey{PUSHNARGS}
    & Push \TT{p->nargs[immedB]} (which is a natural number)
      converted \\
    & to IEEE 64-bit floating point.
\\\hline
\ttkey{PUSHV}
    & Replace the top stack value \TT{V} with the value of the stack element \\
    & with index \TT{p->fp[immedB] - p->nargs[immedB] + V - 1}. \\ 
    & \TT{V} must convert to an integer in the
      range \TT{[1,p->nargs[immedB]]}, \\
    & else an invalid exception is raised and the result is a \TT{NaN}.
\\\hline
\end{tabular}
\end{center}
\caption{Function Instructions}
\label{FUNCTION-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\begin{boxedfigure}

\begin{center}
\small
\begin{tabular}{|l|l|}
\hline
\ttkey{SET\_TRACE}
    & The process \TT{trace\_flags} member is set to \TT{immedA} with its\\
    & \TT{T\_ALWAYS} flag turned on and its \TT{T\_NEVER} flag forced off. \\
    & This instruction is in the \TT{ALWAYS} trace class.
\\\hline
\ttkey{NOP}/\ttkey{TRACE}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times).  The \\
\ttkey{WARN}/\ttkey{ERROR}
    & values popped are always trace values.  All these instructions \\
    & but \TT{NOP} are in the \TT{ALWAYS} trace class.  All these instructions
      are \\
    & no-operations used only for tracing, except \TT{ERROR} prints \\
    & a `Fatal Error' message before its trace and then terminates \\
    & the process with an \TT{ERROR\_STOP} state.
\\\hline
\ttkey{TRACE\_EXCEPTS}
    & No operation.  When traced prints the process
      \TT{excepts\_accumulator}.  \\
    & This instruction is in the \TT{ALWAYS} trace class.
\\\hline
\ttkey{SET\_EXCEPTS}
    & The process \TT{excepts\_mask} member is set to \TT{immedA}.
\\\hline
\ttkey{SET\_OPTIMIZE}
    & The process \TT{optimize} member is set to the low order bit
      of \TT{immedA}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Housekeeping Instructions}
\label{HOUSEKEEPING-INSTRUCTIONS}
\end{boxedfigure}

\section{Arithmetic Exceptions}
\label{ARITHMETIC-EXCEPTIONS}

Arithmetic instructions (Figure~\itemref{ARITHMETIC-INSTRUCTIONS})
may raise the exceptions in Figure~\itemref{EXCEPTIONS}.
When an exception is raised, a flag bit associated with the
exception is turned on the process's \TT{excepts\_\EOL accumulator}
member.  This bit is usually never turned off, and so can be used at the
end of an execution to determine what types of exception
occurred during the execution.

In C/C++ the flag bit associated with exception \TT{XX}
is defined as a bit mask macro \TT{FE\_XX} in \TT{fenv.h}
(see fenv(3) in the UNIX manual):

\begin{boxedfigure}[b!]
\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{DIVBYZERO} &  An operation on finite numbers produces infinity \\
                  &  as a result (e.g., {\tt 5/+0}).
\\\hline
\ttkey{INVALID} & An operation has no well defined result
                  (e.g., {\tt 0/0}). \\
		& \TT{NaN} becomes the result.
\\\hline
\ttkey{OVERFLOW} & An operation produces a finite result too large to
                   store. \\
		 & An infinity becomes the result.
\\\hline
\ttkey{UNDERFLOW} & An operation produces a finite result too small to
                    store. \\
	          & {\tt +0} or {\tt -0} becomes the result.
\\\hline
\ttkey{INEXACT} & An operation produces a finite result that cannot
                  be stored exactly. \\
		& The result is rounded to the nearest value.
\\\hline
\end{tabular}
\end{center}
\caption{Exceptions}
\label{EXCEPTIONS}
\end{boxedfigure}

Only arithmetic instructions in Figure~\itemref{ARITHMETIC-INSTRUCTIONS}
and the \TT{PUSHV} instruction in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS} can raise
exceptions.

In non-optimized mode, i.e.~when a process's \TT{optimize} member is \TT{false},
an instruction that raises an exception prints
an error message if the instruction exception is one whose bit
is on in the process's \TT{excepts\_mask} member.
This error message is always followed by a trace of the instruction
(regardless of the process trace flag settings): see
Instruction Tracing, \itemref{INSTRUCTION-TRACING}.

In optimized mode, instructions do not print error messages
involving exceptions.  However exception flag bits are still
raised in the process's \TT{excepts\_accumulator} member.

In both modes, when a process terminates and there is any exception
bit on in both the process's \TT{excepts\_\EOL accumulator}
and \TT{excepts\_mask} member, an error message is printed.

\needspace{5\baselineskip}

The \TT{mexas} program's (see \itemref{THE-MEXAS-PROGRAM}) initial setting of
a process's \TT{excepts\_mask} member is:
\begin{center}
\TT{DIVBYZERO} ~~ \TT{INVALID} ~~ \TT{OVERFLOW}
\end{center}

\section{Instruction Tracing}
\label{INSTRUCTION-TRACING}

A process has two modes: \key{normal} and \key{optimized}, as
determined by the \TT{optimize} member of the process.
The default setting of the \TT{optimize} member of a process
is \TT{false}.

In normal mode, tracing of an instruction
is controlled by the \key{trace class} $C$ of the instruction
and the \key{trace flags} $F$ of the process.  If
\TT{$F$ \& ( 1 <{}< $C$ ) != 0} the instruction is traced.

In optimized mode, instructions are \underline{not} traced,
except that instructions in the \ttkey{ALWAYS} trace class are always
traced.  These include the \TT{TRACE}, \TT{TRACE\_\EOL EXCEPTS},
\TT{SET\_\EOL TRACE},
\TT{WARN}, and \TT{ERROR} instructions.

Instructions in the \ttkey{NEVER} trace class are never
traced.  Typically there are compiler switches that will
change to \TT{NEVER} the trace class stored in every instruction that
does not have the \TT{ALWAYS} class
(see The MEXAS Program \TT{-tcnever} option, page \pageref{-TCNEVER}).

The trace classes are given in Figure \itemref{TRACE-CLASSES-AND-GROUPS}.
Also given there are trace groups that can be used for convenience
to set the trace flags of a process to include
a pre-defined group of trace classes.
Trace class names and trace group names are used by compiler switches
which set the initial trace flags of processes
(see The MEXAS Program \TT{-tc:\ldots} option, page \pageref{-TC:}),
and by the
\TT{SET\_\EOL TRACE} instruction that sets the current trace flags
of a process.

Notice that all arithmetic instructions have the same
trace class, all \TT{PUSH\ldots} instructions have the same trace
class, and all conditional \TT{JMP\ldots} instructions have the
same two trace classes, one for a successful jump and one for
a failed jump.  Other instructions each have their own trace class,
except for those with the \TT{ALWAYS} class.

In C++ code trace class \TT{XX} is a number that is the value of
the \TT{mex::T\_XX} constant.  Thus the trace class of \TT{ADD}
is \TT{mex::T\_AOP}.


\begin{boxedfigure}[t]

\begin{center}

\bigskip

{\Large \bf Trace Classes}
\\[2ex]
\begin{tabular}{|l|p{5in}|}
\hline
\ttmkey{NEVER}{trace class} & Instruction is never traced.
\\\hline
\ttmkey{ALWAYS}{trace class} & Instruction is always traced.
    The following instructions have this trace class:
    \TT{ERROR}, \TT{WARN}, \TT{TRACE}, \TT{TRACE\_\EOL EXCEPTS},
    \TT{SET\_\EOL TRACE}.
\\\hline
\ttmkey{AOP}{trace class} & Arithmetic instructions in Figure
    \itemref{ARITHMETIC-INSTRUCTIONS}.
\\\hline
\ttmkey{PUSH}{trace class} & All \TT{PUSH\ldots} instructions in Figures
    \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS} and
    \itemref{FUNCTION-INSTRUCTIONS}.
\\\hline
\ttmkey{POP}{trace class} & The \TT{POP} instruction in Figure
    \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
\\\hline
\ttmkey{JMP}{trace class} & The \TT{JMP} instruction.
\\\hline
\begin{tabular}[t]{@{}l@{}}
\ttmkey{JMPS}{trace class} \\
\ttmkey{JMPF}{trace class}
\end{tabular} & \TT{JMP\ldots} instructions in
	        Figure \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
		When compiled the instruction is given the \TT{JMPS}
		class.  When executed, if the jump test succeeds
		(jump is taken),
		the instruction trace class is left unchanged, but if
		the jump test fails (there is no actual jump),
		the effective trace class is changed
		to \TT{JMPF}.
\\\hline
\ttmkey{XXX}{trace class} & Instruction with operation code \TT{XXX},
                            for instructions not mentioned above
			    (e.g., for \TT{NOP}, \TT{BEG}, etc.,
			    but \underline{not} for \TT{ADD},
			    \TT{PUSH}, \TT{JMPEQ}, \TT{ERROR}, etc.).
\\\hline
\end{tabular}
\end{center}

\begin{center}
{\Large \bf Trace Class Groups}
\\[2ex]
\begin{tabular}{|l|l|}
\hline
\ttmkey{ALL}{trace class group} &  All trace classes.
\\\hline
\ttmkey{NONE}{trace class group} &  No trace classes.
\\\hline
\ttmkey{FUNC}{trace class group} &  \TT{CALLM} \TT{CALLG} \TT{RET} \TT{ENDF}
\\\hline
\ttmkey{LOOP}{trace class group} &  \TT{BEGL} \TT{CONT} \TT{ENDL}
\\\hline
\end{tabular}
\end{center}
\caption{Trace Classes and Groups}
\label{TRACE-CLASSES-AND-GROUPS}
\end{boxedfigure}

\subsection{Trace Messages}
\label{TRACE-MESSAGES}

Each instruction trace message begins with:
\begin{indpar}
\emkey{trace-header} ::= \\
\hspace*{0.3in}
\TT{\{}{\em line-number}\TT{:}{\em code-vector-location}%
                        \TT{,}{\em stack-length}%
                        \TT{,}{\em process-counter}\TT{\}} ~ {\em op-code}
\end{indpar}
The {\em line-number} is the number of the \underline{last} source code
line containing code that generated the instruction.
The {\em code-vector-location} is the index of the instruction
in its code vector.
The {\em stack-length} is the number of values in the stack
just before the traced instruction executes.
The {\em process-counter} is the number of instruction executions
since the process was originally initialized before the traced
instruction executes.  The {\em op-code} is the instruction operation code.

The rest of the instruction trace message is specific to the type of
instruction and is specified in the following subsections.  However
in all cases it is based on the value of
\TT{module->\EOL trace\_\EOL info[i]} where \TT{i} is the index of
the instruction in its code vector.
If \TT{module->\EOL trace\_\EOL info[i]} does not exist
or is of an unexpected type, the message may be incomplete.

\subsubsection{Arithmetic Tracing}
\label{ARITHMETIC-TRACING}

The trace message of an arithmetic instruction has the form:
\begin{center}
{\em trace-header}\TT{:} {\em new-variable-name} \TT{=} {\em value}
                    \TT{<=} {\em value}\QMARK{}
                    {\em operator} {\em value}
\end{center}
except for the \TT{POWI} instruction whose trace message has the form:
\begin{center}
{\em trace-header}\TT{:} {\em new-variable-name} \TT{=} {\em value}
                    \TT{<=} \TT{pow} {\em exponent} {\em value}
\end{center}
If {\em new-variable-name} is not given in the instruction,
\TT{*} is used instead.
Note that arithmetic instructions are usually not traced.

For an arithmetic instruction the value of
\TT{module->\EOL trace\_\EOL info[i]} is {\em new-variable-name}
as a MIN string (this may be \TT{*}).
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string,
\TT{*} is used as {\em new-variable-name}.

\subsubsection{Jump Tracing}
\label{JUMP-TRACING}

\TT{JMP\ldots} instruction trace messages have the form:

\begin{center}
{\em trace-header} {\em jmp-target} \TT{is successful:~true}
                    \TT{<=} {\em value} {\em operator} {\em value}
\end{center}
or
\begin{center}
{\em trace-header} {\em jmp-target} \TT{is UNsuccessful:~false}
                    \TT{<=} {\em value} {\em operator} {\em value}
\end{center}

or for a plain unconditional \TT{JMP} instruction, just:
\begin{center}
{\em trace-header} {\em jmp-target}
\end{center}

For a jump instruction the value of
\TT{module->\EOL trace\_\EOL info[i]} is {\em jmp-target}
as a MIN string.
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string,
\TT{*} is used as {\em jump-target}.

\subsubsection{Push/Pop Tracing}
\label{PUSH/POP-TRACING}

\TT{PUSH\ldots} instructions and the \TT{POP} instruction are in essence
value copy instructions and their trace messages
have the form:

\begin{center}
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<=} {\em from-variable} \TT{=} {\em value}
\end{center}

For \TT{PUSH\ldots} the {\em to-variable} is the {\em new-variable}
and the {\em from-variable} is the instruction {\tt variable}.
For \TT{POP} the {\em to-variable} is the instruction {\em variable}
and the {\em from-variable} is the name of the top of the stack.

As always in tracing, `\TT{*}' is used for a missing variable name.

For a \TT{PUSH\ldots} or \TT{POP} instruction
in Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
the value of
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\TT{[<} {\em from-variable} ~ {\em to-variable} \TT{>]}.
If \TT{module->\EOL trace\_\EOL info[i]} is not a 2 element MIN label,
both {\em from-variable} and {\em to-variable} are taken to be \TT{*}.

However there are two exceptions with different {\em from-variables}
and with {\em trace\_\EOL info[i]} equal to just {\em to-variable}.
They are:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\bf Op Code & \bf \em from-variable
\\\hline
\TT{PUSHNARGS} & \TT{nargs[$L$]} \\
\TT{PUSHV}     & \TT{sp[fp[$L$]-nargs[$L$]+$V$-1]}
\end{tabular}
\\[1ex]
where $L$ is the lexical level \\
and $V$ is the value at the top of the stack
\end{center}
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string,
{\em to-variable} is taken to be \TT{*}.


\subsubsection{Trace-Packet Based Trace Messages}
\label{TRACE-PACKET-BASED-TRACE-MESSAGES}

A \key{trace packet} is a \key{trace packet message} and a list of
\skey{trace packet variable}s.  The trace message of a trace packet
instruction has the form:
\begin{indpar}
    {\em trace-header}\TT{:} ~
    {\em trace-packet-message} ~
    \{\TT{,} {\em trace-packet-variable}\TT{=}{\em value} \} \STAR{}
\end{indpar}

For a trace packet instruction
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\begin{center}
\vspace*{-1ex}
\TT{[<} {\em trace-packet-message} ~ {\em trace-packet-variable}\STAR{} \TT{>]}
\end{center}
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN label with at
least one element, then just the {\em trace-header} is output.

The trace packet instructions are:
\begin{center}
\begin{tabular}{ll}
Standard Trace Packet Instructions: &
    \TT{BEG} ~ \TT{END} ~ \TT{TRACE} ~ \TT{NOP} ~ \TT{WARN} ~ \TT{ERROR}
\\[0.5ex]
Special Trace Packet Instructions: &
    \TT{BEGL} ~ \TT{ENDL} ~ \TT{CONT}  \\
  & \TT{BEGF} ~ \TT{ENDF} ~ \TT{CALL\ldots} ~ \TT{RET}
\end{tabular}
\end{center}

For standard trace packet instructions, the compiler must push
the values of the trace packet variables into the stack just
before the instruction.  Then the instruction is traced before
it is executed, if tracing the instruction is enabled.  Lastly
the instruction execution pops the trace packet variable
values from the stack, which is why instructions such as \TT{NOP} and
\TT{TRACE}
can pop stack values.  This trace variable pushing and popping are made
invisible to the programmer by the compiler.

The special trace packet instructions do \underline{no} pushing and popping
of trace packet variable values, and sometimes use the trace packet
of an instruction related to them rather than a trace packet of their
own.  Specifically:

\begin{center}
\begin{tabular}{lp{4.0in}}
\TT{BEGL}  & Uses its own trace packet, with the \TT{immedB} loop variable
             values in the stack when \TT{BEGL} is executed as the trace packet 
	     variable values.
\\[0.5ex]
\TT{ENDL}/\TT{CONT}  & Uses the trace packet of the associated \TT{BEGL},
                       with the \TT{next-\ldots} variable values in the
		       stack \underline{after} the \TT{ENDL} or \TT{CONT}
		       has been executed as the trace packet variables.
		       At this time these \TT{next-\ldots} variable values
		       are a copy of the loop variable values for the next
		       iteration.
\\[0.5ex]
\TT{CALL\ldots}  & Uses the trace packet of the associated \TT{BEGF},
                   with the argument values in the stack as the trace
		   packet variable values. 
		   Also the {\em op-code}
		   in the {\em trace-header} is replaced by
		   \TT{CALL\ldots{} to BEGF}.
\\[0.5ex]
\TT{RET}/\TT{ENDF}  & Uses the trace packet of the associated \TT{CALL},
                   with the return values in the stack as the trace
		   packet variable values.
		   Also the {\em op-code}
		   in the {\em trace-header} is replaced by
		   \TT{RET to CALL\ldots} or \TT{ENDF to CALL\ldots}.
\end{tabular}
\end{center}

Note: The compiler should make the trace packet variables of a \TT{BEGL}
match the names actually used in source code to refer to the loop
variables, and similarly for \TT{BEGF} and arguments and \TT{CALL\ldots}
and return values.
But MEX knows nothing of names used in source code.
To see how MEXAS handles this look at MEXAS Instructions,
\itemref{MEXAS-INSTRUCTIONS}.



\subsubsection{Other Instruction Trace Messages}
\label{OTHER-INSTRUCTION-TRACE-MESSAGES}

\begin{center}
\begin{tabular}{lp{4.5in}}
\bf Op Code     & \bf Trace Message
\\\hline
\ttmkey{SET\_TRACE}{trace message}
		& {\em trace-header}\TT{:} {\em trace-class}\STAR{} \\
                & The {\em trace-classes} being enabled are
	          listed, but they are \underline{not}
		  aggregated into {\em trace-class-groups}.
\\[0.5ex]
\ttmkey{SET\_EXCEPTS}{trace message}
		& {\em trace-header}\TT{:}
                    \{ \TT{*}\QMARK{}{\em except-name} \}\STAR{} \\
                & The names of the excepts being enable in
		  \TT{p->excepts\_mask} are listed, and those that are
		  also in \TT{p->excepts\_accumulator} are starred with
		  \TT{*}.
\\[0.5ex]
\ttmkey{SET\_OPTIMIZE}{trace message}
		& {\em trace-header}\TT{:}
                    {\em new-value} \TT{<=} {\em old-value} \\
                & The new and old values are listed as indicated.
		  The values are denoted as \TT{ON} or \TT{OFF}.
\\[0.5ex]
\ttmkey{TRACE\_EXCEPTS}{trace message}
		& {\em trace-header}\TT{:}
                    \{ \TT{*}\QMARK{}{\em except-name} \}\STAR{} \\
                & The names of the excepts in \TT{p->excepts\_accumulator}
		  are listed, and those that are also in \TT{p->excepts\_mask}
		  are starred with \TT{*}.
\end{tabular}
\end{center}

\subsection{Trace Depth}
\label{TRACE-DEPTH}

Trace messages are indented by the process's \TT{trace\_depth} member
times the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{trace\_indent}\verb|    // Default == 2.|
\end{indpar}
In addition, in the first line of a message all the indent spaces but
the last are replaced by the value of the global variable:
\begin{indpar}
\verb|char mex::|\MEXKEY{trace\_mark}\verb|    // Default == '*'.|
\end{indpar}

A process's \TT{trace\_depth} is initialized to \TT{0} and maintained
by the following instructions:
\begin{center}
\begin{tabular}{l@{~~~~}l}
\TT{BEG} ~ \TT{BEGL} ~ \TT{CALL}+\TT{BEGF} & Increment by 1. \\
\TT{END} ~ \TT{ENDF} ~ \TT{RET} & Decrement by 1. \\
\TT{JMP\ldots} & Decrement by the instruction's \\
               & \TT{trace\_depth} member. \\
\end{tabular}
\end{center}
Note: \TT{JMP\ldots} is the only way to exit a loop (\TT{ENDL} and
\TT{CONT} start a new iteration).

A process's \TT{trace\_depth} is maintained even when the process's
\TT{optimize} switch is \TT{true} (only a few instructions change
the trace depth).

\section{MEX Functions}
\label{MEX Functions}

{\tt mex::module mex::}\MEXKEY{create\_module}
    \verb|( min::file f )|
\begin{indpar}
A \TT{mex::module} is created and returned.  The code vector is empty.
Empty \TT{position} and \TT{trace\_info} vectors are created.
The \TT{globals} member is set to \TT{min::NULL\_STUB} and the
\TT{interface} member is set to \TT{min::MISSING()}.

The \TT{max\_length} of the three empty vectors is initially set to:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{module\_length}\verb|    // Default == 1 << 12.|
\end{indpar}

Note that \TT{mex::module} and its components are read-only, so that
to push instructions, positions, and info into the vectors the module type
must be converted to \TT{mex::module\_ins}.  The following inline
functions can be used to push elements into these vectors and
call \TT{min::acc\_write\_update} as necessary:
\begin{indpar}
{\tt void mex::}\MEXKEY{push\_instr} \\
\hspace*{2em}\verb|( mex::module_ins m, const mex::instr & instr )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_position} \\
\hspace*{2em}\verb|( mex::module m, const min::phrase_position & pp )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_trace\_info} \\
\hspace*{2em}\verb|( mex::module, min::gen info )|
\end{indpar}

These functions will increase the \TT{max\_length} of the vectors
automatically if necessary.

\end{indpar}

{\tt min::locatable\_var<min::printer> mex::}\MEXKEY{default\_printer}
\begin{indpar}
Default printer for \TT{create\_process}.  Initially \TT{min::NULL\_STUB}.
\end{indpar}

{\tt mex::process mex::}\MEXKEY{create\_process} \\
\hspace*{10em}\verb|( min::printer printer = mex::default_printer )|
\begin{indpar}
A \TT{mex::process} is created and returned.  The \TT{printer} argument
must \underline{not} be \TT{min::\EOL NULL\_\EOL STUB}.

The process \TT{length} member (stack size) is set to \TT{0}
and its \TT{max\_length} member (maximum stack size) is set to the
value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{stack\_limit}\verb|    // Default == 16384.|
\end{indpar}

An empty \TT{return\_stack} vector is created and its \TT{max\_size}
is set to the value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{return\_stack\_limit}%
            \verb|    // Default == 4096.|
\end{indpar}

Note: the stack's \TT{max\_length} members are \underline{not} permitted
to change during process execution, but see \TT{mex::\EOL run\_\EOL process}.

The \TT{printer} member is set to the \TT{printer} argument.
The \TT{counter\_\EOL limit}, \TT{trace\_\EOL flags},
\TT{excepts\_\EOL mask}, and \TT{optimize} members
are set respectively from:
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 mex::| & \MEXKEY{run\_counter\_limit} \\
                        & \verb|// Default == 1 << 20|
\\[0.5ex]
\verb|min::uns32 mex::| & \MEXKEY{run\_trace\_flags} \\
                        & \verb|// Default == 1 << mex::T_ALWAYS|
\\[0.5ex]
\verb|int mex::| & \MEXKEY{run\_excepts\_mask} \\
            & \verb+// Default == FE_DIVBYZERO|FE_INVALID|FE_OVERFLOW+
\\[0.5ex]
\verb|bool mex::| & \MEXKEY{run\_optimize} \\
            & \verb|// Default == false|
\end{tabular}\end{indpar}

The \TT{pc} member is set to \TT{\{min::NULL\_STUB,0\}}.
The \TT{fp[\ldots]}, \TT{nargs[\ldots]}, \TT{level}, \TT{trace\_\EOL depth},
\TT{counter}, \TT{optimized\_\EOL counter}, and \TT{excepts\_\EOL accumulator}
members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.


\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::module m, mex::process p = min:NULL_STUB )|
\begin{indpar}
Initialize \TT{p} (which is created by \TT{mex::create\_process}
if that is \TT{NULL\_STUB}) to run the code in \TT{m}.
Return the process.

The \TT{pc} member is set to \TT{\{m,0\}}.

The \TT{fp[\ldots]}, \TT{nargs[\ldots]}, \TT{level}, \TT{trace\_\EOL depth},
\TT{counter}, \TT{optimized\_\EOL counter}, and
\TT{excepts\_\EOL accumula\-tor} members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.

The stack sizes, \TT{counter\_limit}, \TT{trace\_flags},
\TT{excepts\_mask}, and \TT{optimize} members are
\underline{not} changed.

\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::pc pc, mex::process p = min:NULL_STUB )|
\begin{indpar}
Ditto, but does not set the process \TT{pc} member.

Then emulates a \TT{CALL} to the \TT{pc} argument
value, which must point at a \TT{BEGF} instruction with \TT{immedB == 1}
(i.e., lexical level = 1).
This creates a \TT{return\_stack} entry whose
\TT{saved\_pc} is \TT{\{min::NULL\_STUB,0\}}, so a return
will terminate the process normally.  The \TT{nargs} and \TT{nresults} members
are set to \TT{0}.

If there is an error in pointing at a \TT{BEGF} instruction of level 1,
then instead the process \TT{pc} member is set to the illegal value
\TT{\{ min::NULL\_STUB, 1 \}} and \TT{min::NULL\_STUB} is returned.
\end{indpar}

{\tt bool mex::}\MEXKEY{run\_process} \verb|( mex::process p )|%
\label{MEX::RUN_PROCESS}
\begin{indpar}
Execute \TT{p} until it terminates.
Returns \TT{true} on normal termination
and \TT{false} otherwise.  The process \TT{state} is
set as follows to indicate cause of termination:
\end{indpar}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{c}{\bf States That Return \TT{true}}
\\[1ex]
\verb|mex::|\MEXKEY{MODULE\_END}
    & \TT{pc} equals \TT{\{m,index\}} \\
    & with \TT{index == m->length} \\
\verb|mex::|\MEXKEY{CALL\_END}
    & \TT{pc} equals \TT{\{min::NULL\_STUB,0\}}
\\[1ex]
\multicolumn{2}{c}{\bf States That Return \TT{false}} \\
\multicolumn{2}{c}{\bf But Do NOT print An Error Message}
\\[1ex]
\verb|mex::|\MEXKEY{COUNTER\_LIMIT\_STOP}
    & \TT{p->counter > p->limit} \\
\verb|mex::|\MEXKEY{STACK\_LIMIT\_STOP}
    & \TT{p->length > p->max\_length} \\
\verb|mex::|\MEXKEY{RETURN\_STACK\_LIMIT\_STOP}
    & \TT{p->return\_stack->length >} \\
    & \TT{p->return\_stack->max\_length}
\\[1ex]
\multicolumn{2}{c}{\bf States That Return \TT{false}} \\
\multicolumn{2}{c}{\bf And Also print An Error Message}
\\[1ex]
\verb|mex::|\MEXKEY{ERROR\_STOP}
    & \TT{ERROR} instruction with \TT{immedB != 0} \\
\verb|mex::|\MEXKEY{JMP\_ERROR}
    & conditional \TT{JMP\ldots}~instruction with \\
    & invalid operand(s) (either a \TT{NaN} or \\
    & both infinities of the same sign) \\
\verb|mex::|\MEXKEY{FORMAT\_ERROR}
    & program formatting error \\
    & (likely a compiler error) \\
\verb|mex::|\MEXKEY{EXCEPTS\_ERROR}
    & program terminated successfully \\
    & (as per \TT{MODULE\_END} or \TT{CALL\_END}) \\
    & but with some excepts bit on in both \\
    & \TT{p->excepts\_mask} and \TT{p->excepts\_accumulator} \\
\end{tabular}
\end{center}

Notes:
\begin{enumerate}
\item For cases where \TT{false} is returned by \TT{mex::run\_process},
the process stops \underline{before} executing the instruction which
would violate the condition (except for \TT{mex::\EOL EXCEPTS\_\EOL ERROR}).
Thus the process will stop before executing an instruction that would
violate one of the limits, trigger a programming format error, etc.
The \TT{ERROR} instruction stops the process with the program counter
pointing at the \TT{ERROR} instruction.
\item \label{LIMIT-STOP-NOTE}
On \TT{\ldots\_LIMIT\_STOP}, you can increase the limit
and call \TT{run\_process} again to continue execution.
For stacks you must resize the stack (as per \TT{min::\EOL resize}).
\item You can use \TT{init\_process ( m )} followed by \TT{run\_process}
to run the code of \TT{m}.  Then after \TT{MODULE\_END},
you can add to the end of \TT{m}
and call \TT{run\_process} again to continue the execution of the code
of \TT{m} (i.e., execute the added code).
\end{enumerate}

\section{MEX Compiler Components}
\label{MEX-COMPILER-COMPONENTS}

Compilers that compile into MEX have some structure in common,
and the MEX has two compiler components, each with data and
functions that can be shared among all these compilers.

\subsection{MEX Basic Compiler Component}
\label{MEX-BASIC-COMPILER-COMPONENT}

The MEX basic compiler component provides a function to push an
instruction into a module, compiler error and
warning printing and counting functions, an instruction trace printing
functions, and various data structures such as a stack of all the
modules compiled and information tables for op codes, trace classes,
trace flags, and except flags.

The MEX basic compiler component is in the following:

\begin{indpar}
\begin{tabular}{l}
{\tt namespace} \ttkey{mexcom}
\\
{\tt \ldots/mex/include/}\ttkey{mexcom.h}
\\
{\tt \ldots/mex/src/}\ttkey{mexcom.cc}
\end{tabular}
\end{indpar}

\subsubsection{MEX Compiler Context Data}
\label{MEX-COMPILER-CONTEXT-DATA}

\begin{tabular}{@{}r@{~~~}l}
\verb|min::locatable_var<mex::module_ins> mexcom::|
	& \MEXCOMKEY{output\_module} \\
\verb|min::locatable_var<min::file> mexcom::|
	& \MEXCOMKEY{input\_file}
\end{tabular}

\begin{indpar}
These must be set by the compiler to
the {\tt mex::module} currently being compiled and
its input file.
\end{indpar}

\begin{tabular}{@{}r@{~~~}l}
\verb|typedef min::packed_vec_insptr<mex::module> mexcom:|
	& \MEXCOMKEY{module\_stack} \\
\verb|min::locatable_var<mexcom::module_stack> mexcom:|
	& \MEXCOMKEY{modules}
\end{tabular}
\begin{indpar}
{\tt Mexcom::modules}
is the list of modules completely compiled so far, organized as
a stack, most recent topmost.  When the compiler finishes compiling
a module, it should execute: \\
\hspace*{3em}{\tt min::push(mexcom::modules) = mexcom::output\_module}
\end{indpar}

\verb|bool mexcom::| \MEXCOMKEY{trace\_never} \verb|= false| \\
\verb|inline void mexcom::| \MEXCOMKEY{push\_instr} \\
\verb|        ( mex::instr & instr,| \\
\verb|          const min::phrase_position & pp =| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          min::gen trace_info = min::MISSING() )|
\begin{indpar}
Push the given parts of an instruction into the corresponding
{\tt mexcom::\EOL output\_\EOL module} stacks.
If {\tt mexcom::\EOL trace\_\EOL never} is {\tt true} and
{\tt instr.trace\_class != mex::T\_ALWAYS}, first modify
{\tt instr.trace\_class} to equal {\tt mex::T\_NEVER}.
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{op\_code\_table}
\begin{indpar}
For {\tt op\_code OP < mex::NUMBER\_OF\_OP\_CODES}
with name {\tt "OP"}:\\
\hspace*{3em}{\tt op\_code\_table[OP] == new\_str\_gen ( "OP" )} \\
and \\
\hspace*{3em}{\tt ~~~min::get ( op\_code\_table, new\_str\_gen ( "OP" ) )} \\
\hspace*{3em}{\tt == new\_num\_gen ( OP )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{trace\_class\_table}
\begin{indpar}
For {\tt trace\_class} {\tt T\_XX < mex::NUMBER\_OF\_TRACE\_CLASSES}
with name {\tt "XX"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_class\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( T\_XX )}
\end{indpar}


\subsection{MEX Stack Compiler Component}
\label{MEX-STACK-COMPILER-COMPONENT}

\section{MEXAS Language}
\label{MEXAS Language}

\key{MEXAS} is an assembly language for MEX.  The \ttkey{mexas}
assembler can be use as a MEX compiler.

MEXAS is a tool for debugging MEX and a rough prototype for more
advanced MEX compilers.

\subsection{MEXAS Syntax}
\label{MEXAS-SYNTAX}

MEXAS programs are written in ASCII.  Control characters other
than whitespace, and non-ASCII bytes, are illegal and are
replaced by `\#'.

A MEXAS program consists of statements which are instructions
or declarations, each encoded as a sequence of lexemes.

If a lexeme begins with `\ttkey{//}', it and the rest of the
line are a \key{comment} and are ignored (except for detecting
illegal characters).  A line containing only a comment is a
\key{comment line}.  Blank lines have no effect.

If the last lexeme on a line is `\ttkey{\textbackslash}',
the current statement
is \key{continued} on the next line (the `\TT{\textbackslash}' is
discarded).

A \key{statement} is a sequence of lines beginning with the first
line after the previous statement (or the first line of a file)
and ending with a non-blank, non-comment line that is
\underline{not} continued.  Statements are either instructions or
declarations.

Instructions begin with an op code lexeme, and the program syntax
of all the instructions taken together
is that of a code vector: see Code Vectors,
\itemref{CODE-VECTORS}.

Declarations define jump instruction targets or print assembly
information.

When `\ttkey{::=}' is used in a syntax equation, the
items of the equation are lexemes and \underline{not}
characters.
When `\ttkey{:::=}' is used, the
items of the equation are characters and \underline{not}
lexemes.

\subsection{Lexemes}

A MEXAS \key{lexeme} is a sequence of non-whitespace characters
surrounded by whitespace, or a single quote (\TT{'}) followed
by a sequence of non-single-quote characters followed by a
single quote, or a double quote (\TT{"}) followed by a 
sequence of non-double-quote characters followed by a
double quote.

A \key{number}\label{NUMBER} is a lexeme acceptable as an IEEE floating point
number to the POSIX \TT{strtod} function.

A \key{name}\label{NAME} is a lexeme beginning with a letter that is
\underline{not} a number (\TT{nan}, \TT{InF}, etc. are numbers
and not names).

A \key{string}\label{STRING} is a lexeme beginning with quote and ending
with the same kind of quote.

All lexemes must be on a single line: they cannot be continued to the
next line.  Strings not terminated by an end of line are automatically
terminated with an error message.

A comment beginning lexeme (\TT{//\ldots}) and a continuation
lexeme (\TT{\textbackslash}) must be lexemes surrounded by whitespace.

Illegal characters are replaced by \TT{\#} and become part of the
current lexeme or comment.  An error message accompanies such replacement.

\subsection{Lexical Level and Depth}
\label{LEXICAL-LEVEL-AND-DEPTH}

Functions are bracketed with \TT{BEGF} and \TT{ENDF}
and have a \key{lexical level}.  The lexical level of a function
that is \underline{not} inside any other function is \TT{1}.
The lexical level of any other function $F$ is one plus the lexical
level of the smallest function containing $F$.
The lexical level of an instruction
is that of the smallest function containing the instruction.
The lexical level of instructions
that are \underline{not} inside any function is \TT{0}.

Code also contains (non-function) \skey{block}s that are
bracketed with either \TT{BEG} and \TT{END} or with
\TT{BEGL} and \TT{ENDL}.  A block has a \key{container}
and within the container a \key{depth}.
A block not inside a function has the module as its container.
The container of a block inside a function is the smallest
function containing the block.

The depth of a block that is not inside any other block with
the same container is \TT{1}.  The depth of any other block $B$
is one plus the depth of the smallest block containing $B$.
The depth of an instruction
is that of the smallest block containing the instruction.
The depth of instructions in a container
that are \underline{not} inside any block that is in the container
is \TT{0}.

\subsection{Assembler Stacks}
\label{ASSEMBLER-STACKS}

The assembler maintains several stacks during assembly.

The assembler's \key{variable stack} mirrors the stack of
the process during execution.  Each variable stack
element specifies the lexical level and depth of the
instruction that created the stack element, and optionally
assigns a name to the stack element.  These names are the
variable names of the assembly, and can be used in
push and pop instructions to name stack elements read or
written.

When assembled, most instructions manipulate the variable
stack just as they will manipulate the process stack
when executed.  The \TT{BEG} instruction does nothing
but when the \TT{END} instruction is assembled, it pops
from the end of the variable stack all elements with
the same lexical level and depth as the \TT{END} instruction.
\TT{BEGL} and \TT{ENDL} behave similarly, except that
\TT{BEGL} pushes next variables into the variable stack
(these have depth one less
than that of the \TT{BEGL} and \TT{ENDL}: see Next Variables and Loops,
\itemref{NEXT-VARIABLES-AND-LOOPS}).
\TT{BEGF} and \TT{ENDF} behave similarly except that \TT{BEGF}
pushes arguments into the variable stack (these have the same
lexical level and depth as the \TT{BEGF} and \TT{ENDF}).

Two instructions that treat the variable stack very differently
from a process stack are \TT{CALL\ldots} and \TT{JMP}.  \TT{CALL\ldots}
pops arguments from the variable stack and pushes returned values.
\TT{JMP} does nothing to the variable stack, and the conditional
jumps \TT{JMP\ldots} just pops two elements.

In order to locate arguments in the variable stack, the assembler variable
\TT{fp[$L$]} is maintained when a \TT{BEGF} is assembled as the
variable stack size after argument elements are pushed into the
variable stack by \TT{BEGF}: see \TT{BEGF}, \pagref{BEGF}.

The assembler's \key{function stack} specifies the functions that
can be called by a \TT{CALL\ldots} instruction.  \TT{BEGF} pushes
a element with a name, lexical level, and depth, and behaves
for the function stack like \TT{PUSH\ldots} does for the variable stack.
\TT{END\ldots} instructions pop the function stack in the same manner as
they pop the variable stack.

At the end of assembly, the variable and function stacks hold
elements of lexical level 0 and depth 0.  These stacks are then
saved as the module's interface that allows global variables
and lexical level 1 functions of the module to be accessed by
other modules.

Lastly the assembler maintains a \key{block stack} whose only
purpose is to check that \TT{BEG\ldots} and \TT{END\ldots} instructions
occur in matching pairs.

\subsection{JMP Targets}
\label{JMP-TARGETS}

A {\em jmp-target} is a name\pagnote{NAME} that identifies
a code vector index value which can be used by \TT{JMP\ldots}
instructions as the point in the code vector to jump to.

{\em Jmp-targets} are defined by \TT{LABEL} declarations
of the form:
\begin{center}
\ttkey{LABEL} {\em jmp-target}
\end{center}

\TT{JMP\ldots} instructions are forward-referencing: their
{\em jmp-targets} are defined by \TT{LABEL} declarations that
occur in source code \underline{after} the \TT{JMP\ldots} instruction.
To manage \TT{JMP\ldots} instructions and their targets,
the assembler maintains a list of \skey{pending jumps}:
that is, jumps whose {\em jmp-target} has not yet been
declared.  When a \TT{LABEL} declaration is processed,
the pending jump list is searched for matching jumps,
and those that are found are resolved and removed from
the list.  Resolving involves calculating the distance
between the jump and its target, and the number of
process stack elements the jump should pop.  Jump instructions
are allowed to pop stack elements, but cannot push them.

To allow this, an element of the pending jump list contains:
\begin{enumerate}
\item The location of the jump instruction so it can be updated
when its target is found.
\item The {\em jmp-target} name.
\item The lexical level $L$ of the jump instruction.
\item The maximum depth $D$ allowed for the target.
\item The length $S$ of the variable stack just after the jump instruction
      pops variable elements from the stack.
\item The minimum $M$ of $S$ and all the variable stack lengths that have
      occurred after \TT{END} or \TT{ENDL} instructions encountered
      since the jump instruction was encountered.
      $M\le S$.
\end{enumerate}

A \TT{JMP\ldots} instruction for which a legal target exists
is called \key{resolvable}.  Other \TT{JMP\ldots} instructions
are \key{unresolvable} and are in error.

The following instructions/declarations act on the pending jump list:

\ttkey{JMP\dots} {\em jmp-target}
\begin{indpar}
Add an element to the pending jmp list with $L$, $D$,
$S$ set to their current values and $M=S$.
\end{indpar}

\ttkey{END}/\ttkey{ENDL}
\begin{indpar}
For all pending jumps whose $D$ is equal to that
of the \TT{END}/\TT{ENDL}, decrement that $D$ by 1.

For all pending jumps whose $M$ is greater than the
variable stack length $s$ will be after the \TT{END}/\TT{ENDL},
decrease their $M$ to $s$.
\end{indpar}

\ttkey{LABEL} {\em jmp-target}\label{LABEL}
\begin{indpar}
Search the pending jump list for matching elements with $L$ equal
to the current lexical level and $D$ not less than the current
depth, resolve these, and remove them from
the pending jmp list.
\end{indpar}

\ttkey{ENDF}
\begin{indpar}
Search the pending jump list for elements with $L$ equal to the
lexical level of the \TT{ENDF} and remove them as being unresolvable,
and therefore in error.
\end{indpar}

{\bf Jump Stack Rule}: When a jump list element is resolved, its $M$
must equal the length of the stack when the resolving \TT{LABEL}
is encountered.

The following illustrate this rule when the jump does \underline{not}
reduce depth and $M$ = the variables stack length just after the
\TT{JMP\ldots} is compiled:

Example 1:
\begin{indpar}\begin{verbatim}
// Program to calculate minimum ( X, Y ) in stack.
//
// Stack length is S
PUSH X
PUSH Y
// Stack length is S + 2
JMPLT ITS-X    // M = S
// Stack length is S
PUSH Y
// Stack length is S + 1
JMP DONE       // M = S + 1
// Stack length is S + 1
LABEL ITS-X    // JMPLT ITS-X *illegal*, M == S != S + 1
PUSH X
// Stack length is S + 2
LABEL DONE     // JMP DONE *illegal*, M == S + 1 != S + 2
// Stack length is S + 2
\end{verbatim}\end{indpar}

Example 2:
\begin{indpar}\begin{verbatim}
// Program to calculate minimum ( X, Y ) in stack.
//
// Stack length is S
PUSH 0 Z
// Stack length is S + 1
BEG
    // Stack length is S + 1
    PUSH X
    PUSH Y
    // Stack length is S + 3
    JMPLT ITS-X    // M = S + 1
    // Stack length is S + 1
    PUSH Y
    // Stack length is S + 2
    POP Z
    // Stack length is S + 1
    JMP DONE       // M = S + 1
    // Stack length is S + 1
    LABEL ITS-X    // JMPLT ITS-X legal, M == S + 1 == S + 1
    PUSH X
    // Stack length is S + 2
    POP Z
    // Stack length is S + 1
    LABEL DONE    // JMP DONE legal, M == S + 1 == S + 1
END
// Stack length is S + 1
\end{verbatim}\end{indpar}



\subsection{MEXAS Instructions}
\label{MEXAS-INSTRUCTIONS}

In the following description of MEXAS instruction syntax and
assembly actions:

\begin{enumerate}
\item When an instruction pushes an
element into the variable or function stacks, the element is given
the lexical level and depth of the instruction.
\item A \emkey{variable-name} is a name of a variable stack element.
If two elements have the same {\em variable-name}, the element nearer
the top of the stack hides the element lower down.
\item A \emkey{function-name} is a name of a function stack element.
If two elements have the same {\em function-name}, the element nearer
the top of the stack hides the element lower down.
\item Stack searches always proceed from the topmost stack element
the bottommost, and accept the first element found with the desired name.
\item Modules are named by the name of the file assembled to produce
the module, with the suffix \TT{.mex} deleted.  Such a name is
a \emkey{module-name}.
\item Some instructions have an optional {\em new-variable-name} argument
that names an element being pushed to the variables stack.
The {\em new-variable-name}
must \underline{not} be the same as the name of any variable of
less lexical level or depth than the instruction, or the same name
as that of an argument of a function (see \TT{BEGF}).  Note that the
\TT{next-} variables of a loop have depth one less than the instructions
in the loop.

If {\em new-variable-name} is missing or `\TT{*}',
the element just gets the name `\TT{*}' to indicate that the
element has no name.

\item A variable cannot be written if it has a lexical level less than
that of the writing instruction, or is a function argument variable,
or has depth equal to the writing instruction.
\item The operands that take integer values must have values in the
range $[0,2^{32})$ (so they will fit into \TT{immedA}, \TT{immedB},
or \TT{immedC} instruction
members).
\item Some instructions have a {\em level}\label{LEVEL} argument, which must
specify a lexical level in the range [1,$L$], where $L$ is the lexical
level of the instruction.  If the argument is missing or \TT{0},
the specified lexical level is $L$.
If the argument is a positive integer, it is the specified lexical level
(and must be in range).  If the argument is a negative integer -$i$,
the specified lexical level is $L-i$ (and must be in range).
\item Some instructions have a {\em trace-message} argument
and some have {\em trace-packet} arguments, where:
\begin{indpar}
\emkey{trace-message} ::= {\em string}
\\[0.5ex]
\emkey{trace-packet} ::= {\em trace-message} {\em trace-variable}\STAR{}
\end{indpar}
These specify the {\em trace-info} for the instructions:
see Trace-Packet Based Trace Messages,
\itemref{TRACE-PACKET-BASED-TRACE-MESSAGES}.
\end{enumerate}

\needspace{15\baselineskip}

Given the above notes, the instruction descriptions are:

{\em aop} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em aop} is any arithmetic operation code from
Figure~\itemref{ARITHMETIC-INSTRUCTIONS}, and the run-time
action of the instruction is specified in that figure.

At assembly-time the same number of elements are popped from the variable stack
as are popped from the process stack during run-time.
Then one element is pushed to the variable stack with
{\em new-variable-name} as its name.
\end{indpar}

\ttkey{POWI} ~ {\em exponent} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run time, performs as indicated in
Figure~\itemref{ARITHMETIC-INSTRUCTIONS}.
Here {\em exponent} is stored in the instruction's \TT{immedA}
member and must be an integer in the range $[0,2^{32})$.

At assembly-time pops one element from the variable stack
Then one element is pushed to the variable stack with
{\em new-variable-name} as its name.
\end{indpar}

\ttkey{PUSHM} ~ {\em variable-name} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
lexical level 0 variable.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em variable-name} is restricted to
elements with the lexical level \TT{0}.
\end{indpar}

\ttkey{PUSHG} ~ {\em module-name} ~ {\em variable-name} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
global variable in the named module.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack searched for {\em variable-name} is the variable
stack of the previously assembled module named, as it is at the
end of the compilation of that module (only level 0 variables
of the module are present in this stack).
\end{indpar}

\ttkey{PUSH} ~ {\em variable-name} ~
             {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the variable
named in the variable stack or global variable vector.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The search for {\em variable-name} begins with the entire variable
stack and proceeds through the variable stacks of previously assembled modules
in the order that the modules were assembled.  \TT{PUSH} assembles
to the runtime instruction \TT{PUSHS}, \TT{PUSHL}, \TT{PUSHG},
or \TT{PUSHA}, depending on the location of the variable.
\end{indpar}

\ttkey{PUSHI} ~ {\em number} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of
the {\em number}\pagnote{NUMBER}.
At assembly time, pushes into the variable stack an element
element with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{POP} ~ {\em variable-name}\QMARK{}
\begin{indpar}
At run-time, pops the process stack and stores the value popped
into the variable named in the variable stack.  Or if the
variable name is not given or is `\TT{*}', discards the value popped.

At assembly time, pops the variable stack.

The variable stack search for {\em variable-name} is restricted to
elements with the same lexical level as the \TT{POP} instruction
that are not arguments to that lexical level and that are of
lesser depth than the \TT{POP} instruction.

\ttkey{POP} assembles to the run-time instruction \TT{POPS}.
Note that \TT{POPL}, \TT{POPG}, and \TT{POPA} do
\underline{not} exist as you cannot write
variables that are arguments, or at a different lexical level,
or in a different module.
\end{indpar}

\ttkey{JMP} ~ {\em jmp-target}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
this instruction adds an element to the pending jump
list (see JMP Targets, \itemref{JMP-TARGETS}).
\end{indpar}

\ttkey{JMP\ldots} ~ {\em jmp-target}
\begin{indpar}
Here \ldots~denotes one of \TT{EQ}, \TT{NE}, etc.

At run-time these instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
these instructions pop two elements from the variable stack
and then add an element to the pending jump list
(see JMP Targets, \itemref{JMP-TARGETS}).

Note that
the pending jump list element
$S$ value is the length of the variable stack \underline{after}
the two elements are popped.
\end{indpar}

\ttkey{BEG} ~ {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
\TT{BEG} just increments the depth.
\end{indpar}

\ttkey{END} ~ {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
it pops from the variable and function stacks all elements with the
same lexical level and depth as the \TT{END} instruction, then
decrements the depth, then updates the jump list
(see JMP Targets, \itemref{JMP-TARGETS}).
\end{indpar}

\ttkey{BEGL} ~ {\em nnext} ~ {\em trace-message}\QMARK{}
\begin{indpar}
Here {\em nnext} is the number of next variables
(see Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}).
At run-time this instruction's action is as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS} with \TT{immedB} equal
to {\em nnext}.

At assembly-time, this instruction first checks that the
top {\em nnext} variable stack elements have the current lexical level
and depth,
then pushes {\em nnext} variable stack elements with current lexical
level and depth
and with names derived from their {\em nnext}'th predecessor
in the stack by adding the prefix `\TT{next-}.' to the predecessor's
name.  Then this instruction increments the current instruction depth.

Thus for example, if the top two stack elements have names
\TT{X} and \TT{Y} and {\em nnext} is \TT{2}, the two elements
pushed would have names \TT{next-X} and \TT{next-Y}, and
all 4 stack elements would have depth one less than the depth
of instructions inside the \TT{BEGL/ENDL} block.
\end{indpar}

\ttkey{ENDL}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
\TT{ENDL} does the same thing as \TT{END}.
\end{indpar}

\ttkey{CONT}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{BEGF}\label{BEGF} ~ {\em function-name} ~ {\em variable-name}\STAR{} ~
	{\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction first pushes an element with the {\em function-name}
into the function stack.
Then this instruction increments the current lexical level
and sets the current depth to zero.
Lastly this instruction pushes one element with each
of the {\em variable-names} into the variable stack (they
represent the arguments to the function).
The number of {\em variable-names} can be less than,
but may \underline{not} be greater than, the number of actual
arguments.

Lastly the instruction saves the current variable stack size
in the assembly-time variable fp[$L$],
where $L$ is the lexical level of the \TT{BEGF}
instruction.  This is used to implement \TT{PUSHA}.
\end{indpar}

\ttkey{ENDF} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
it pops from the variable and function stacks all elements with the
same lexical level as the \TT{ENDF} instruction, and then restores
the current lexical level and depth to what they were before
the associated \TT{BEGF} instruction.
\end{indpar}

\ttkey{CALLM} ~ {\em function-name} ~ {\em nargs} ~
        {\em variable-name}\STAR{} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
it pops from the variable variable stack {\em nargs} values
and pushes into the stack one element for each {\em variable-name}
(representing the results of the function execution).
The number of {\em variable-names} \underline{must} equal
the number of actual results.

The {\em function-name} is searched for in the function stack.
\end{indpar}

\ttkey{CALLG} ~ {\em module-name} ~ {\em function-name} ~
              {\em nargs} ~ {\em variable-name}\STAR{} ~
	      {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
the actions are the same as for \TT{CALL}.

The {\em function-name} is searched for in the function stack of
the previously assembled module named, as it is at the
end of the compilation of that module (only level 1 functions
of the module are present in this stack).
\end{indpar}

\ttkey{CALL} ~ {\em function-name} ~
             {\em nargs} ~ {\em variable-name}\STAR{} ~
	      {\em trace-message}\QMARK{}
\begin{indpar}
This instruction searches for the {\em function-name} first in the function
stack and then in the function stacks of the previously assembled
modules in the order in which they were assembled.  It then
assembles to \TT{CALLM} or \TT{CALLG}.
\end{indpar}

\ttkey{RET} ~ {\em nresults} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction pops {\em nresults} elements from the
variables stack.
\end{indpar}

\ttkey{PUSHNARGS} ~ {\em level}\QMARK{} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS} with \TT{immedB} set
to the lexical level specified by {\em level} (see \pagref{LEVEL}).
At assembly-time,
this instruction pushes into the variable stack an element
with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{PUSHV} ~ {\em level}\QMARK{} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS} with \TT{immedB} set
to the lexical level specified by {\em level} (see \pagref{LEVEL}).

At assembly-time, this instruction first pops an element from the
variable stack, and then pushes into the variable stack an element
with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{SET\_TRACE} ~ \{ {\em trace-class} $|$ {\em trace-class-group} \}\STAR{}
\begin{indpar}
At run-time set the process \TT{trace\_flags} parameter so as
to have a flag for each {\em trace-class} given, or each trace class
in a given {\em trace-class-group}.  This instruction itself has
the \TT{ALWAYS} trace class.
See Instruction Tracing\pagnote{INSTRUCTION-TRACING} for details.

At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{NOP}/\ttkey{TRACE}/\ttkey{WARN}/\ttkey{ERROR} ~
    {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time these instructions do nothing, except that the \TT{ERROR}
instruction terminates the process
(see Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}).  At assembly-time,
these instructions do nothing.

All these instructions except \TT{NOP} are in the \TT{ALWAYS}
trace class.
\end{indpar}

\ttkey{SET\_EXCEPTS} ~ {\em except-name}\STAR{}
\begin{indpar}
At run-time set the process \TT{excepts\_mask} parameter so as
to have a flag for each named except.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{SET\_OPTIMIZE} ~ \{ \TT{ON} $|$ \TT{OFF} \}
\begin{indpar}
At run-time set the process \TT{optimize} parameter on or off.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{TRACE\_EXCEPTS}
\begin{indpar}
At run-time, this instruction is just traced as specified
in Other Instruction Trace Messages,
\itemref{OTHER-INSTRUCTION-TRACE-MESSAGES}.
At assembly-time,
this instruction does nothing.
\end{indpar}

\subsection{MEXAS Declarations}
\label{MEXAS-DECLARATIONS}

\ttkey{LABEL} ~ {\em jmp-target}
\begin{indpar}
See \pagref{LABEL}.
\end{indpar}

\ttkey{STACKS}
\begin{indpar}
Prints the names in the assembly time variables and functions stacks.
Used mostly for testing the assembler.
\end{indpar}

\ttkey{TEST\_INSTRUCTION} ~
    \begin{tabular}[t]{@{}l@{}}
    {\em op-code} ~ {\em trace-class} ~ {\em trace-depth} ~
                 \TT{\textbackslash} \\
    {\em immedA} ~ {\em immedB} ~ {\em immedC} ~ {\em immedD} \\
    \end{tabular}
\begin{indpar}
Outputs an instruction with the given fields, and does nothing
else at assembly time.  Used for testing \TT{FORMAT\_ERROR},
since otherwise such errors are (seem to be, should be) impossible
because of assembler checks.

The {\em op-code} and {\em trace-class} are names.
{\em immedD} may be a number or module name.
The other fields are integers.

Fields may be omitted from the end of the instruction.
\end{indpar}


\subsection{The MEXAS Program}
\label{THE-MEXAS-PROGRAM}

The \key{MEXAS program} executes {\em mexas-operations} that
appear in its arguments.  The syntax is:

\begin{indpar}
\emkey{MEXAS-command} ::= \ttkey{mexas} ~ {\em mexas-operation}\STAR{}
\\[0.5ex]
\emkey{mexas-operation} ::=
    \begin{tabular}[t]{l@{~~~~~}l}
    \emkey{mexas-filename}		& [assemble the file] \\
    \ttkey{-pa} 			& [print assembled instructions] \\
    \ttkey{-pasource}			& [ditto and include source lines] \\
    \ttkey{-paoff}			& [do not print
                                           assembled instructions] \\
    \ttkey{-tcnever}			& [assemble with \TT{NEVER}
                                           trace class] \\
    \ttkey{-tcnormal}			& [assemble with normal trace class] \\
    \ttkey{-tc:}{\em tc-list}		& [run tracing listed trace classes] \\
    \ttkey{-ex:}{\em ex-list}		& [run with given excepts\_mask] \\
    \ttkey{-o:on}			& [run with optimize on] \\
    \ttkey{-o:off}			& [run with optimize off] \\
    \ttkey{-counter} $L$		& [set instruction counter limit] \\
    \ttkey{-stack} $L$		        & [set stack size] \\
    \ttkey{-return-stack} $L$	        & [set return stack size] \\
    \ttkey{-r} {\em function-name}	& [run named function] \\
    \end{tabular}
\\[0.5ex]
\emkey{tc-list} :::= $|$ {\em trace-class-or-group}
                         \{ \TT{,} {\em trace-class-or-group} \}\STAR{} \\
\emkey{trace-class-or-group} :::= {\em trace-class} $|$ {\em trace-group} \\
\emkey{trace-class} :::= trace class
    listed in Figure~\itemref{TRACE-CLASSES-AND-GROUPS} \\
\emkey{trace-group} :::= trace group
    listed in Figure~\itemref{TRACE-CLASSES-AND-GROUPS} \\
\\[0.5ex]
\emkey{ex-list} :::= $|$ {\em exception} \{ \TT{,} {\em exception} \}\STAR{} \\
\emkey{exception} :::= except listed on Figure~\itemref{EXCEPTIONS}

\end{indpar}

Note that the symbol :::= is used to indicate that syntactic components
can\underline{not} be separated by whitespace, whereas ::= indicates
that components can and often should be separated by whitespace.

A {\em mexas-operation} is effective for all subsequent
{\em mexas-operations} until it is overridden.  E.g.,
\TT{-o:on} will cause following all executions to be optimized
until an \TT{-o:off} is encountered.

Details are:
\begin{center}
\begin{tabular}{lp{4.5in}}
{\em mexas-filname} & Name of file, usually ending in \TT{.mex}, containing
                      instructions as described in
                      MEXAS Instructions, \itemref{MEXAS-INSTRUCTIONS}.
		      The file is assembled as a module and given the
		      filename minus any \TT{.mex} extension as its
		      module name.
\\[0.5ex]
\begin{tabular}[t]{@{}l@{}}
\TT{-pa} \\
\TT{-pasource} \\
\TT{-paoff} \\
\end{tabular}	    & Determines whether an instruction is printed after
                      it is assembled, and if so, whether source lines
		      from the file are printed before the instruction.
		      Default is \TT{-paoff}.
		      See Assembled Instruction Printing,
		      \itemref{ASSEMBLED-INSTRUCTION-PRINTING}.
\\[0.5ex]
\TT{-tcnever}	    & Determines the trace class of an assembled instruction. \\
\label{-TCNEVER}
\TT{-tcnormal}	    & \TT{-tcnormal} sets the trace class of the op code
		      given by Figure~\itemref{TRACE-CLASSES-AND-GROUPS}.
                      \TT{-tcnever} sets the class to \TT{NEVER} unless
		      the normal instruction trace class is \TT{ALWAYS}.
		      Default is \TT{-tcnormal}.
\\[0.5ex]
\TT{-tc:}{\em tc-list} \label{-TC:}
		    & Sets the process \TT{trace\_flags} at the start of mex
		      program execution.  \TT{ALWAYS} and \TT{NEVER}
		      can\underline{not} be listed: their flags are always
		      on and off, respectively.
		      Default is \TT{-tc:NONE}.
\\[0.5ex]
\TT{-ex:}{\em ex-list}
		    & Sets the process \TT{excepts\_mask} at the start of mex
		      program execution.
		      Default is \TT{-ex:DIVBYZERO,INVALID,OVERFLOW}.
\\[0.5ex]
\begin{tabular}[t]{@{}l@{}}
\TT{-o:off} \\
\TT{-o:on} \\
\end{tabular}	    & Sets the process \TT{optimize} flag \TT{on} or \TT{off}
                      at the start of mex program execution.
		      Default is \TT{-o:off}.
\\[0.5ex]
\TT{-counter} $L$   & Sets the process \TT{counter\_limit} to integer $L$.
\\[0.5ex]
\TT{-stack} $L$	    & Sets the process \TT{max\_length} (stack size)
                      to integer $L$.
\\[0.5ex]
\TT{-return-stack} $L$
		    & Sets the process \TT{return\_stack->max\_length}
		      (return stack size) to integer $L$.
\\[0.5ex]
\TT{-r} {\em function-name}
                    & Calls the named function, which must be of lexical
		      level 1 in some previously assembled module.
		      To find the function, the name is searched for
		      in the modules, most recently assembled module first.
\\[0.5ex]
		    & The function must take no arguments and return no
		      results.
\end{tabular}
\end{center}


\subsubsection{Assembled Instruction Printing}
\label{ASSEMBLED-INSTRUCTION-PRINTING}

The printout of an assembled instruction begins with the source
lines of the code that contained the instruction, if this is
enabled.  All source lines after the line ending the previous
instruction are printed.

An instruction printout has the syntax:
\begin{indpar}
\emkey{instruction-printout} ::= \\
\hspace*{2em} {\em printout-header}
    \begin{tabular}[t]{l}
    {\em op-code} \TT{T\_}{\em trace-class}
               \{ \TT{[} {\em trace-depth} \TT{]} \}\QMARK{} \\
    {\em immedA} {\em immedB} {\em immedC} {\em immedD}
	       \{ \TT{;} {\em trace-info} \}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{printout-header} ::=
    \TT{[}{\em line-number}\TT{:}{\em code-vector-location}%
                        \TT{,}{\em variables-stack-length} \TT{]}
\end{indpar}
The {\em line-number} is the number of the \underline{last} source code
line containing code that generated the instruction (the first file line is
number \TT{1}).  The first {\em code-vector-location} is \TT{0}.
The {\em variables-stack-length} is the value \underline{before}
the instruction
is assembled. The {\em trace-depth} is printed only if it is not zero,
and the {\em trace-info} is printed only if it is not \TT{min::MISSING()}.

In some cases assembling an instruction or declaration (e.g., \TT{LABEL})
modifies a previously assembled instruction.  In these cases the
modified previously assembled instruction is printed just after it has
been modified, and before any instruction currently being assembled.


\clearpage

\printindex

\end{document}
