% Minimal Runtime System Execution Engine
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{wasysym}
\usepackage{makeidx}
\usepackage{upquote}
\usepackage{needspace}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MEXKEY}[1]%
	   {\TT{#1}\ttindex{mex::#1}\ttindex{#1}}
\newcommand{\MEXLKEY}[2]%
           {\TT{#1#2}\index{mex::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MEXIKEY}[2]%
           {\TT{#1}\ttindex{mex::#2}\ttindex{#2}}
\newcommand{\MEXMKEY}[2]%
           {\TT{#1}\ttmindex{mex::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MEXCOMKEY}[1]%
	   {\TT{#1}\ttindex{mexcom::#1}\ttindex{#1}}
\newcommand{\MEXSTACKKEY}[1]%
	   {\TT{#1}\ttindex{mexstack::#1}\ttindex{#1}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Minimal Run-time System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Version 2)}

\author{Robert L. Walton}

\date{December 10, 2024}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Run-time System Execution Engine.

MEX is layered on top of the Minimal Run-time System.

MEX is stack-oriented and block-oriented.  It computes with
\ttkey{min::gen} values.

\section{Abbreviations}
\label{ABBREVIATIONS}

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{except}{abbreviation}	& exception \\
\ttmkey{fp}{abbreviation}	& frame pointer \\
\ttmkey{immed}{abbreviation}	& immediate \\
\ttmkey{info}{abbreviation}	& information \\
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{jmp}{abbreviation}	& jump (go to) \\
\ttmkey{nargs}{abbreviation}	& number of arguments \\
\ttmkey{nresults}{abbreviation}	& number of results \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{ret}{abbreviation}	& return \\
\ttmkey{sp}{abbreviation}	& stack pointer \\
\end{tabular}
\end{indpar}

In addition abbreviations of the MIN Run-time System are used
in names of types and functions of that system.

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test files such as \TT{Makefile} and
                               \TT{mex\_compile\_test\_1.mex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}

MEX is layered on top of MIN, the Minimal Run-time System, and
includes \ttkey{min.h}.

The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}\ttindex{mex.h}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable vector.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, it is loaded into memory
ready for execution.  There are no MEX `binary' files.

Interfaces are provided by and used by the compiler, and
not by MEX.  Typically a module may reference interfaces
of previously compiled modules.

Immediately after a module is compiled, it is executed.  A copy of the
resulting execution stack (see Stacks, \itemref{STACKS}) becomes the
module's \key{global variable vector}, i.e., its vector of
global variables.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector
and variables are added to the end of
the module's global variable stack.  The compiler should add
interfaces to new global variables and new module functions, but
this is a matter for the compiler, and not for MEX.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called
the function code block instructions are executed.  A function
can itself contain another function.

MEX does \underline{not} itself provide a compiler, but it
assumes a few compilation behaviors.

\section{Stacks}
\label{STACKS}

MEX is stack oriented.  A \key{stack} is a vector of
elements.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Elements may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector. The length of the stack is referred to as the
\key{stack pointer} and is one greater than the vector index of the top of
the stack, unless the stack is empty and its vector length is zero.

The word `stack' without qualification refers to the main
\key{process stack}\label{PROCESS-STACK},
which is a stack of \TT{min::gen} variable values.
MEX supports the programming paradigm
in which variables in this stack are read-only, unless
they are being assigned values by a block of code.  Using this paradigm
variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values that code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.  MEX assumes that to allow
a form of variable update the compiler implements `next variables'
as described in Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.
The arguments and all the values the function pushes into the
stack are called the function's \key{frame}.  The stack pointer
value when the function begins is called the function's
\key{frame pointer}, and points just after the last argument
of the function.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and then pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, the module's
global variable vector is created by making
a copy of the final execution stack.

Backward jumps are only allowed at the end of a loop blocks.
These pop the values pushed into the stack by the loop block.
Forward jumps are the only means of exiting a loop block.  These
pop all values pushed into the stack by blocks that are exited.

There are special considerations involving the stack if the
compiler allows functions to be nested inside other functions.
These considerations are described in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

\subsection{Next Variables and Loops}
\label{NEXT-VARIABLES-AND-LOOPS}

MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler re-points the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\label{EXAMPLE-LOOP}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and re-point the names {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the compiler will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such values
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Nested Functions}
\label{NESTED-FUNCTIONS}

MEX assumes that any compiler compiling into MEX code follows the
rules of lexical scoping.  For our purposes these are as follows.
The compiler maintains a stack of visible variables and a separate
stack of visible functions.  When the compiler outputs a {\tt PUSH\ldots}
instruction that creates a variable, it pushes the name of the variable
into the stack of visible variables.  When the compiler outputs a {\tt BEGF}
instruction that creates a function, it pushes the name of the function
into the stack of visible functions.  Instructions output by the compiler
that read a variable value can only read visible variables, and 
instructions that call a function can only call visible functions.
When a block end instruction ({\tt ENDF}, {\tt ENDL}, or {\tt END}) is
output, the visible variables and visible functions stacks are popped to
remove all variables and function defined within the block just ended.

The \key{lexical level}\label{LEXICAL-LEVEL}
of a function is defined as follows.

If the function $F$ is not inside any other function, $F$ has
level 1.

If the function $F$ is inside a function and $F'$ is the smallest
function containing $F$, and if $F'$ has level $L'$, then $F$
has level $L=L'+1$.

If $F$ is a function lexically inside another function $F'$, then instructions
in $F$ can reference the variables of $F'$ that could be referenced by
an instruction located where $F$ is defined.
To locate these variables, knowing the frame pointer for the
execution of $F'$ is sufficient.  The frame pointer is defined as the
stack pointer that points just after the last argument to $F'$,
or equivalently, the stack
pointer when $F'$ is called.

So how do we compute the frame pointer of $F'$?  To see how,
we need to analyze the situation in more detail.

We define the level of an instruction to be the level of the
smallest function lexically containing the instruction, or \TT{0} if the
instruction is not lexically inside any function.  If $E_I$ is an
execution of an instruction $I$, the level of $E_I$ is the
level of $I$.

\begin{indpar}
{\bf Lemma 1}\label{LEMMA-1}~~~An execution of a \TT{CALL\ldots} instruction of
level $L$ must call a function of level $L'\leq L+1$.
\end{indpar}
\begin{indpar}
{\bf Proof}: To be visible to the \TT{CALL\ldots}
instruction, a function must be either defined within functions
lexically containing the \TT{CALL\ldots} instruction, in which case the
function cannot have a level greater than $L+1$, or the function must be global,
in which case it has level \TT{1}.  QED
\end{indpar}

Let $E$ be the sequence of instruction executions in an
incomplete program execution.
An execution of a function $F$ within $E$ is defined as all the
instruction executions from the first instruction execution
after $F$ is called until the last instruction execution which returns
from the call of $F$.  A function execution can be complete, meaning
it ends with a return from the function, or incomplete.  A function execution
$E_i$ contains the function executions of every function called by a 
a \TT{CALL\ldots} instruction execution in $E_i$.

The lexical level of a function execution is defined as the lexical level
of its function.

The \underline{incomplete} function executions in $E$ are ordered by size, and
identically ordered by the sequence of their first instruction executions.
(This is the same order as the order of their return stack entries
as per the description of \TT{CALLM} and \TT{RET} in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}).

\begin{indpar}
{\bf Corollary 1 of Lemma 1}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of lexical levels
$L_1$ and $L_2$.  Let $E_2$ immediately follow $E_1$ in the size
ordering.  Then $L_2\leq L_1+1$.
\end{indpar}
\begin{indpar}
{\bf Proof}: The \TT{CALL\ldots} to start $E_2$ must be in $E_1$
and cannot be in a complete function execution inside $E_1$ so
the \TT{CALL\ldots} must have level $L_1$.  The corollary follows
from this and Lemma 1. QED
\end{indpar}

\begin{indpar}
{\bf Corollary 2 of Lemma 1}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of lexical levels
$L_1$ and $L_2$, let $E_2\subset E_1$, and let $L_2>L'>L_1$.
Then there must be an incomplete function execution $E'$ in $E$
that is in between $E_1$ and $E_2$ in the sequence of incomplete function
executions of $E$ and that has level $L'$.
\end{indpar}
\begin{indpar}
{\bf Proof}: Stepping through the sequence from $E_1$ to $E_2$,
the levels at each step can increase by at most $1$ (by Corollary 1),
so no level can be skipped over.  QED.
\end{indpar}

\begin{indpar}
{\bf Lemma 2}~~~Within $E$
let $E_1$ and $E_2$ be incomplete function
executions of functions $F_1$ and $F_2$ which have levels $L_1$ and $L_2$
and let  $E_2$ immediately follow $E_1$ in the size
ordering.  If further there is a function $F$ of level $L$ that lexically
contains $F_1$ ($F=F_1$ is allowed), and if $L_2>L$, then $F$ lexically contains
$F_2$.
\end{indpar}
\begin{indpar}
{\bf Proof}: The \TT{CALL\ldots} to start $E_2$ must be in $E_1$
and cannot be in a complete function execution inside $E_1$ so
the \TT{CALL\ldots} must be an instruction of $F_1$.  This \TT{CALL\ldots}
is therefore lexically inside $F$ by hypothesis, and the only functions visible
to the \TT{CALL\ldots} that have levels $>L$ are also inside $F$.
Therefore $F_2$ is lexically inside $F$.
\end{indpar}

\begin{indpar}
{\bf Theorem}~~~If $F'$ is the unique function of level $L' < L$ that lexically
contains function $F$ of level $L$,
then during the execution of instructions in $F$ (and not in any other
function defined inside $F$),
there is a smallest incomplete execution of $F'$ that is also
the smallest incomplete function execution of level $L'$.
\end{indpar}

\begin{indpar}
{\bf Proof of Theorem}: If the currently executing instruction is in $F$
it is in the smallest incomplete function execution, and this has level $L$.
The largest incomplete function execution
must have level $1$ and the last incomplete function execution has level
$L$, and by hypothesis $1\leq L'<L$,
so by Corollary 2 there is an incomplete function execution of level $L'$
and hence a smallest one $E'$.  Let $F''$ be its function.  Then all the
incomplete function executions between $E'$ and the end of the sequence
must have lexical level $>L'$, for otherwise applying Corollary 2 again
there would be a smaller incomplete function execution of level $L'$.

Then by applying Lemma 2 recursively to successive incomplete function
executions after $E'$, we deduce that all are executions of functions
lexically inside $F''$, and therefore $F''$ is a function of
level $L'$ lexically containing $F$ (which is the function of the
last incomplete execution).  As the function of level $L'$
that lexically contains $F$ is unique, $F''=F'$.

QED
\end{indpar}


During execution MEX computes \TT{fp[$L'$]} as the frame pointer
of the smallest (most recently called)
incomplete function execution of level $L'$,
and therefore
during the execution of instructions in $F$, \TT{fp[$L'$]} is the
frame pointer of $F'$.

If follows that during an execution of an instruction in $F$
the variables of $F'$ can be accessed by
\TT{PUSHL} with \TT{immedB} = $L'$
(Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}),
and the arguments of $F'$ can be
accessed by \TT{PUSHA} with \TT{immedB} = $L'$
(Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}).
If we set \TT{fp[0] = 0},
the global variables can be accessed by \TT{PUSHL} with \TT{immedB} = $0$
or by \TT{PUSHG}
(Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}).

\section{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em stack-and-flow-control-instruction} \\
		  $|$ & {\em block-and-function-instruction} \\
		  $|$ & {\em stack-and-housekeeping-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction} ::= \\
\hspace*{3em}
    instructions in Figure \itemref{ARITHMETIC-INSTRUCTIONS}
\\[0.5ex]
\emkey{stack-and-flow-control-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
\\[0.5ex]
\emkey{block-and-function-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}
\\[0.5ex]
\emkey{stack-and-housekeeping-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{instr}
\LABEL{MEX::INSTR} \\
\verb|{                   | \\
\verb|    min::uns8 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_class}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_depth}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{unused}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns32 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::module\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::module\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::module\_header}} \\
\verb|    min::gen | & \TTMKEY{name}{in {\tt mex::module\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::module\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::module\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::module\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{trace\_info}
                                              {in {\tt mex::module\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module\_ins}
\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttmkey{name}{of module} member of the \TT{module} is derived
from the module's file name by removing any \TT{.mex} extension.
If the module is input from the standard input, and not a file,
the \TT{name} is \TT{min::MISSING()}.

The \ttmkey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module} (may be \TT{min::MISSING()} is input was
from standard input).  In particular, the \TT{min::phrase\_\EOL position}
of instruction \TT{m[i]} is \TT{m->position[i]}.
This information can be used to
print trace and error messages.

The \ttmkey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code
(initializing the module).
This stack contains values of global variables exported by the module.

The \ttmkey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.

The \ttmkey{trace\_info}{of module} member of the \TT{module} points
at a vector of \TT{min::gen} values such that for module \TT{m},
\TT{m->\EOL trace\_\EOL info[i]} gives information that can be used
to print trace messages for instruction \TT{m[i]}.  See
Instruction Tracing, \itemref{INSTRUCTION-TRACING}.

\section{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
a return stack, and other parameters.  Specifically:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{pc}%
\LABEL{MEX::PC} \\
\verb|{                   | \\
\verb|mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{ret}%
\LABEL{MEX::ret} \\
\verb|{                   | \\
\verb|mex::pc | & \TTMKEY{saved\_pc}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_level}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_fp}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_nargs}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{nresults}{in {\tt mex::ret}} \\
\verb|}                   | \\
\end{tabular}
\\[1ex]
\verb|const unsigned mex::|\MEXKEY{max\_lexical\_level}\verb| = 16|%
\LABEL{MEX::MAX_LEXICAL_DEPTH}
\\[1ex]
\begin{tabular}{@{}r@{}l}
\verb|struct                         mex::| & \MEXKEY{process\_header}%
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                   | \\
\verb|min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|min::printer | & \TTMKEY{printer}{in {\tt mex::process\_header}} \\
\verb|mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|min::packed_vec_insptr<mex::ret> | & \TTMKEY{return\_stack}%
                                              {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{level}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{fp}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{nargs}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{trace\_depth}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{trace\_flags}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_mask}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_accumulator}%
                         {in {\tt mex::process\_header}} \\
\verb|bool | & \TTMKEY{optimize}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{optimized\_counter}%
                         {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter\_limit}{in {\tt mex::process\_header}} \\
\verb|mex::state | & \TTMKEY{state}%
                                   {in {\tt mex::process\_header}} \\
\verb|}                                    | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|enum         mex::| & \MEXKEY{state}%
\LABEL{MEX::STATE} \\
\verb|{                 | \\
\verb|mex::| & \TTMKEY{NEVER\_STARTED}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RUNNING}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{MODULE\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{CALL\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{COUNTER\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{STACK\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RETURN\_STACK\_LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{ERROR\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{JMP\_ERROR}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{FORMAT\_ERROR}{in {\tt mex::state}} \\
\verb|}                 | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}

\end{indpar}

A \TT{mex::process} \TT{p} is a vector of \TT{min::gen} elements which
is the process \key{stack}, with the last element being the top
of the stack (\TT{p[p->length-1]}) and the first element
being the bottom of the stack (\TT{p[0]}), assuming the stack
is not empty.  The \key{stack pointer} (a.k.a., \TT{sp})
is \TT{p->length}, and is the index of an element of
the process vector which is just beyond the top of the stack,
and is also the length of the stack.

To push a value into the stack,
you store the value in the element \TT{p->length}
indexes, and then add +1 to \TT{p->length}.
To pop a value, you add -1 to \TT{p->length}, and then
read the value indexed by \TT{p->length}.
We require that \TT{0 <= p->length <= p->max\_length} at all times,
and \underline{never} increase \TT{p->max\_length} during execution
(but see Note~\ref{LIMIT-STOP-NOTE} on page~\pageref{LIMIT-STOP-NOTE}).

A \ttkey{pc}, or \key{program counter}, is a pointer to a module,
which is a code vector, and an index in that vector of an instruction.
Thus a \TT{pc} points at an instruction.  The \TT{pc} member of a
process (\TT{p->pc}) is the \key{current program counter} of that process.

The value of \TT{p->level} is the current lexical level of the
process, i.e., the lexical level of the instruction pointed at
by \TT{p->pc}.  \TT{p->fp[$L$]} is the frame pointer for the
most recently started currently executing function of level $L$.
\TT{p->nargs[$L$]} is the number of arguments passed to this
function.  Note that the list of currently executing functions
in order of being called is not monotonic in level: a function
of level $L$ may call a function of level $\leq L+1$.

The process's frame pointer member \TT{fp[\ldots]}
is further explained in Nested Functions,
\itemref{NESTED-FUNCTIONS}.  The value of \TT{fp[0]}, the frame pointer
for lexical level \TT{0} (outside all functions), is always \TT{0}.

The \ttkey{return\_stack} is used by \TT{CALL} and \TT{RET}
instructions.  The value of \TT{return\_stack->\EOL length},
a.k.a.~the \key{return stack pointer}, is the index of the element of
the return stack which is just beyond the top of the stack,
and is also the length of the stack.  If the stack is not empty,
\TT{p->return\_stack[return\_stack->length-1]} is the top of the stack.

A \TT{CALL} instruction pushes a \TT{mex::ret} value
into the return stack.  This contains a \TT{saved\_pc} member
pointing at the \TT{CALL} instruction.
A \TT{RET} instruction pops a \TT{mex::ret} value from
the \TT{return\_stack} and stores its \TT{saved\_pc}
in the current program counter
of the process (\TT{p->pc}), and then increments that program counter
by \TT{1}.

The \TT{CALL} also changes the process \TT{level} to the lexical level
of the function being called (determined by the function's \TT{BEGF}
instruction) and if this level is $L$, changes \TT{fp[$L$]} to the
frame pointer of that function and \TT{nargs[$L$]} to the number of
arguments passed to that function.  Before making changes the \TT{CALL}
saves these values in the \TT{mex::ret} value.
The \TT{nresults} member of \TT{mex::ret}
is the number of function results expected by the call.
See the \TT{CALL} instruction in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}
for specifics.

The process's \TT{counter} is incremented once every time an instruction
finishes execution.  The process stops when
\TT{counter >= counter\_\EOL limit}\label{COUNTER-LIMIT}.
The \TT{optimized\_counter}
is incremented (along with the \TT{counter})
for every instruction executed in optimize mode;
it has no limit and is for information purposes only.

When the process terminates, \TT{state} is set.  For details
see \TT{mex::run\_process}, \pagref{MEX::RUN_PROCESS},

The \TT{trace\_depth}, \TT{trace\_flags}, \TT{excepts\_mask},
\TT{excepts\_accumulator}, and \TT{optimize}
members of a process
are explained in Arithmetic Exceptions, \itemref{ARITHMETIC-EXCEPTIONS}
and Instruction Tracing, \itemref{INSTRUCTION-TRACING}.


\section{Instructions}
\label{INSTRUCTIONS}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code}, \TT{trace\_class}, \TT{trace\_\EOL depth},
and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.
\TT{Trace\_class} is explained in Instruction Tracing,
\itemref{INSTRUCTION-TRACING}, and
\TT{trace\_depth} is explained in Trace Depth,
\itemref{TRACE-DEPTH}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD, mex::T_AOP};
    // Pop 2 values and push their sum.
    // mex::T_AOP is the trace class of all arithmetic
    // operations.
mex::instr an_add_immediate_instruction =
        {mex::ADDI,mex::T_AOP,,,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG, mex::T_BEG};
    // Do nothing.
mex::instr an_end_instruction = {mex::END,mex::T_END,,,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,mex::T_JMP,1,,10,,32};
    // Pop 10 values and discard them, then decrement the process's
    // trace_depth by 1, then add 32 to program counter to skip
    // 32 instructions.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\itemref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations and the C \TT{math.h}
library are used.  See Arithmetic Exceptions,
\itemref{ARITHMETIC-EXCEPTIONS} for error
handling.

The stack and flow control instruction set is in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
See Stacks, \itemref{STACKS}, for an overview of stack handling.

The block and function instruction set is in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.
See Nested Functions, \itemref{NESTED-FUNCTIONS},
for details concerning nested functions.

The stack and housekeeping instruction set is in
Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}.

Some instructions use the values of the following parameters to represent
the logical values `true' and `false':

\hspace*{0.3in}\begin{tabular}{rll}
\tt min::gen mex::& \ttkey{ZERO}  & \tt // Default: the MIN number 0. \\
\tt min::gen mex::& \ttkey{FALSE} & \tt // Default: the MIN string "FALSE". \\
\tt min::gen mex::& \ttkey{TRUE}  & \tt // Default: the MIN string "TRUE".  \\
\end{tabular}

\pagebreak


\begin{boxedfigure}[p!]

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{ADD}/\ttkey{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\ttkey{ADDI}
    & Adds \TT{immedD} to the top value.
\\\hline
\ttkey{MULI}
    & Multiplies the top value by \TT{immedD}.
\\\hline
\ttkey{SUB}/\ttkey{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\ttkey{SUBI}
    & Subtract \TT{immedD} from the top value.
\\\hline
\ttkey{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\ttkey{DIV}/\ttkey{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\ttkey{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\ttkey{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\ttkey{MOD}/\ttkey{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first popped divided by \\
    & the first/second popped.
\\\hline
\ttkey{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\ttkey{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\ttkey{POW}/\ttkey{POWR}
    & Pop 2 values, then push the first/second popped to the \\
    & second/first power.
\\\hline
\ttkey{POWI}
    & Replace the top value by the the top value to the \\
    & \TT{immedD} power.
\\\hline
\ttkey{POWRI}
    & Replace the top value by \TT{immedD} to the top value power.
\\\hline
\ttkey{LSH}/\ttkey{LSHI}/\ttkey{RSH}/\ttkey{RSHI}
    & Pop 2 values, then push the first times 2 to the \\
    & second/\TT{immedD}/minus-second/minus-\TT{immedD} power.
\\\hline
\ttkey{FLOOR}/\ttkey{CEIL}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward minus/plus infinity.
\\\hline
\ttkey{TRUNC}/\ttkey{ROUND}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward zero/the-nearest-integer, \\
    & with nearest halfway cases rounded to the even integer.
\\\hline
\ttkey{NEG}/\ttkey{ABS}
    & Replace the top value by its negation/absolute-value.
\\\hline
\ttkey{LOG}/\ttkey{LOG10}
    & Replace the top value by its log base e/10.
\\\hline
\ttkey{EXP}/\ttkey{EXP10}
    & Replace the top value by e/10 to the top value power.
\\\hline
\ttkey{SIN}/\ttkey{COS}/\ttkey{TAN}
    & Replace the top value by its sin/cos/tan.
\\\hline
\ttkey{ASIN}/\ttkey{ACOS}/\ttkey{ATAN}
    & Replace the top value by its arc- sin/cos/tan.
\\\hline
\ttkey{ATAN2}/\ttkey{ATAN2R}
    & Pop 2 values, then push the arc-tangent of the first/second \\
    & popped (x value) divided by the second/first popped \\
    & (y value).
\\\hline
\end{tabular}
\end{center}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\pagebreak

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{PUSHS}
    & Read the value at \TT{sp[- immedA - 1]} and push it into the \\
    & stack; so \TT{immedA} = 0 duplicates the top value.
\\\hline
\ttkey{PUSHL}
    & Push the stack vector value with index \TT{fp[immedB] + immedA}. \\
    & But if \TT{immedB == 0} and \TT{m->globals} is not \TT{min::NULL\_STUB} \\
    & for the module \TT{m} of the current program counter, push \\
    & \TT{m->globals[immedA]} instead.  Note \TT{fp[0] == 0}.
\\\hline
\ttkey{PUSHI}
    & Push \TT{immedD} into the stack.
\\\hline
\ttkey{PUSHG}
    & Push \TT{m->globals[immedA]} into the stack, where \TT{m} is \\
    & the module pointed at by \TT{immedD}
\\\hline
\ttkey{POPS}
    & Store the top value in the stack into \TT{sp[- immedA - 1]}, and \\
    & then pop the stack once; so \TT{immedA} = 0 discards the top value.
\\\hline
\ttkey{JMP}
    & Subtract \TT{immedA} from \TT{sp} (popping the stack \TT{immedA} times),
      \\
    & then add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
      \\
    & It is illegal for \TT{immedC} = 0 (\TT{JMP} would jump to itself).
\\\hline
\ttkey{JMPEQ}/\ttkey{JMPNEQ}
    & Pop 2 values and arithmetically compare them.  If they are \\
    & equal/not-equal continue as per the \TT{JMP} instruction.  Otherwise \\
    & if \TT{immedB} == 0, do nothing more, but if \TT{immedB} == 1, \\
    & push the first value popped back into the stack.
\\\hline
\ttkey{JMPLT}/\ttkey{JMPLEQ}
    & Ditto, but \TT{JMP} if the second popped is \\
    & less-than/less-than-or-equal-to the first popped.
\\\hline
\ttkey{JMPGT}/\ttkey{JMPGEQ}
    & Ditto, but \TT{JMP} if the second popped is \\
    & greater-than/greater-than-or-equal-to the first popped.
\\\hline
\ttkey{JMPTRUE}
    & Pop 1 value and respectively test whether it equals \TT{mex::TRUE}, \\
\ttkey{JMPFALSE}
    & equals \TT{mex::FALSE}, \\
\ttkey{JMPNONE}
    & equals \TT{min::NONE()}, \\
\ttkey{JMPINT}
    & is an integer in the range (-1e15,+1e15), \\
\ttkey{JMPFIN}/\ttkey{JMPINF}
    & is a finite number, is an infinite number, \\
\ttkey{JMPNUM}
    & is a MIN number (includes NaNs), \\
\ttkey{JMPTRUTH}
    & equals mex::TRUE or mex::FALSE, \\
\ttkey{JMPSTR}/\ttkey{JMPOBJ}
    & is a MIN string, or is a MIN object. \\
    & If yes, continue as per \TT{JMP}, and if no, do nothing, \\
    & provided \TT{immedB} = 0.  However if \TT{immedB} != 0, reverse \\
    & the test, so `no' jumps and `yes' does not.
\\\hline
\ttkey{JMPCNT}
    & Test whether \TT{sp[- immedB - 1]} is arithmetically $\leq 0$, \\
    & and if yes, continue as per \TT{JMP}.  Otherwise subtract \TT{immedD} \\
    & (must be a finite number) from \TT{sp[ - immedB - 1]}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Stack and Flow Control Instructions}
\label{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
\end{boxedfigure}

\pagebreak

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{BEG}/\ttkey{END}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.
\\\hline
\ttkey{BEGL}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.  Then \\
    & take the top \TT{immedB} values in the stack and push a copy of \\
    & them all into the stack, preserving stack ordering.
\\\hline
\ttkey{ENDL}/\ttkey{CONT}
    & First subtract \TT{immedA} from \TT{sp}
      (popping the stack \TT{immedA} times), \\
    & then take the top \TT{immedB} values in the stack and copy them \\
    & to the next lower \TT{immedB} values in the stack, then subtract \\
    & \TT{immedC} from the \TT{pc} (jumping backwards to just after \\
    & the appropriate \TT{BEGL}).
\\\hline
\ttkey{BEGF}
    & Add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
    \\[0.5ex]
    & Also used to provided data for \TT{CALL} as follows: \TT{immedB} is the \\
    & target function's lexical nesting level (\pagref{LEXICAL-LEVEL}),
      and \TT{immedA} is the \\
    & minimum number of arguments expected.
\\\hline
\ttkey{ENDF}
    & Same as a \TT{RET} instruction (below) with \TT{immedC} = 0. 
\\\hline
\ttkey{CALLM}
    & Push a \TT{mex::ret} value $e$ into the return stack, setting
      \TT{$e$.saved\_pc} \\
    & to point to the \TT{CALLM} instruction, and then
      set the \TT{index} \\
    & of \TT{p->pc} to \TT{immedC}, which must reference a
      \TT{BEGF} instruction.
    \\[0.5ex]
    & Check that the \TT{CALL} \TT{immedA} value, the number of arguments \\
    & passed, is at least as great as the \TT{BEGF}
      \TT{immedA}, the minimum \\
    & number of arguments expected.  Take the target 
      function's lexical \\
    & level $L$ from the \TT{BEGF} \TT{immedB} value, and save
      \TT{p->\{level,fp[$L$],} \\
    & \TT{nargs[$L$]\}} in \TT{$e$.saved\_\{level,fp,nargs\}}.
       Next set \TT{p->level} \\
    & to $L$, \TT{p->fp[$L$]} to \TT{sp}, \TT{p->nargs[$L$]} to \TT{immedA},
      and \TT{$e$.nresults} \\
    & to \TT{immedB}.
    \\[0.5ex]
    & Lastly add +1 to the process current \TT{pc} to skip the \TT{BEGF}.
\\\hline
\ttkey{CALLG}
    & Same as \TT{CALLM} but also set the process's \TT{pc} member's 
                                                           \TT{module} \\
    & member from \TT{immedD} (which must convert to a \TT{mex::module}).
\\\hline
\ttkey{RET}
    & Check that \TT{immedB} equals \TT{p->level}.  Then pop element $e$
      from \\
    & the return stack and check that \TT{immedC} equals
       \TT{$e$.nresults}.  Next \\
    & pop \TT{immedC} values from the stack and save them.  Set \TT{sp} to \\
    & \TT{fp[immedB] - nargs[immedB]} (popping the
      current function \\
    & execution stack values).  Then push the saved values into the stack. \\
    & Lastly, restore the process members saved in \\
    & \TT{$e$.saved\_\{pc,level,fp,nargs\}}, and increment the 
      restored \TT{pc} \\
    & by \TT{1}.
\\\hline
\end{tabular}
\end{center}
\caption{Block and Function Instructions}
\label{BLOCK-AND-FUNCTION-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\begin{boxedfigure}

\begin{center}
\small
\begin{tabular}{|l|l|}
\hline
\ttkey{VPUSH}
    & Push the value of the top of the stack to the end of the vector of \\
    & the object pointed at by \TT{sp[- immedA - 1]}. However, if the value \\
    & at the top of the stack is itself an object with 
                    \TT{.initiator == immedD}, \\
    & push instead all the vector elements of this object.  After finishing \\
    & adding to the vector of the object, pop the execution stack once. 
\\\hline
\ttkey{VPOP}
    & Pop one value from the end of the vector of the object pointed at by \\
    & \TT{sp[- immedA - 1]} and then push that value into the stack.
        However, \\
    & if the vector is empty, push \TT{min::NONE()} instead.
\\\hline
\ttkey{GET}
    & Read the attribute labelled by the value X
        of \TT{sp[- immedC - 1]} from \\
    & the object pointed to by \TT{sp[- immedA - 1]} and then push that value \\
    & into the stack.  If X is an integer, read the X+1'st element of the \\
    & vector of the object, while if X is a string or MIN label, read the \\
    & labelled attribute of the object.  If the value to be read does not
    		exist, \\
    & push \TT{min::NONE()} into the stack instead.  If \TT{immedB}
    	is non-zero, \\
    & \TT{immedC} is required to be zero, and the value X is popped from \\
    & the stack after it is read, before the value read is pushed.
\\\hline
\ttkey{GETI}
    & Read the attribute labelled by \TT{immedD}, which must be a string \\
    & or MIN label, from the object pointed to by \TT{sp[- immedA - 1]}, \\
    & and then push that value into the stack.  If the value to be read does \\
    & not exist, push \TT{min::NONE()} into the stack instead.
\\\hline
\ttkey{SET}
    & Write the top value in the stack to the attribute labelled by the value \\
    & X of \TT{sp[- immedC - 1]} in the object pointed to by
    	\TT{sp[- immedA - 1]}. \\
    & If X is an integer, write the X+1'st element of the vector of the \\
    & object, while if X is a string or MIN label, write to the labelled \\
    & attribute in the object.  If X is an integer, the vector element is \\
    & required to exist; otherwise if the attribute does not have a previous \\
    & value, the attribute is created.  After the write, pop one value from \\
    & the stack (the value written), and then if \TT{immedB} is non-zero, 
        require \\
    & \TT{immedC} to equal \TT{1} and pop a second value (X)
	    from the stack.
\\\hline
\ttkey{SETI}
    & Write the top value in the stack to the attribute labelled
        by \TT{immedD}, \\
    & which must be a string or MIN label, in the object pointed to by \\
    & \TT{sp[- immedA - 1]}.  Then pop one value (the value written) from the \\
    & stack.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Object Instructions}
\label{OBJECT-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\begin{boxedfigure}

\begin{center}
\small
\begin{tabular}{|l|l|}
\hline
\ttkey{PUSHA}
    & Push the stack vector value with index \TT{fp[immedB] - immedA}. \\
    & \TT{immedA} must be 
      in the range \TT{[1,p->nargs[immedB]]}.
\\\hline
\ttkey{PUSHNARGS}
    & Push \TT{p->nargs[immedB]} (which is a natural number)
      converted \\
    & to IEEE 64-bit floating point.
\\\hline
\ttkey{PUSHV}
    & Replace the top stack value \TT{V} with the value of the stack element \\
    & with index \TT{p->fp[immedB] - p->nargs[immedB] + V - 1}. \\ 
    & \TT{V} must convert to an integer in the
      range \TT{[1,p->nargs[immedB]]}, \\
    & else an invalid exception is raised and the result is a \TT{NaN}.
\\\hline
\ttkey{SET\_TRACE}
    & The process \TT{trace\_flags} member is set to \TT{immedA} with its\\
    & \TT{T\_ALWAYS} flag turned on and its \TT{T\_NEVER} flag forced off. \\
    & This instruction is in the \TT{ALWAYS} trace class.
\\\hline
\ttkey{NOP}/\ttkey{TRACE}
    & Subtract \TT{immedA} from
      \TT{sp} (popping the stack \TT{immedA} times).  The \\
\ttkey{WARN}/\ttkey{ERROR}
    & values popped are always trace values.  All these instructions \\
    & but \TT{NOP} are in the \TT{ALWAYS} trace class.  All these instructions
      are \\
    & no-operations used only for tracing, except \TT{ERROR} prints \\
    & a `Fatal Error' message before its trace and then terminates \\
    & the process with an \TT{ERROR\_STOP} state.
\\\hline
\ttkey{TRACE\_EXCEPTS}
    & No operation.  When traced prints the process
      \TT{excepts\_accumulator}.  \\
    & This instruction is in the \TT{ALWAYS} trace class.
\\\hline
\ttkey{SET\_EXCEPTS}
    & The process \TT{excepts\_mask} member is set to \TT{immedA}.
\\\hline
\ttkey{SET\_OPTIMIZE}
    & The process \TT{optimize} member is set to the low order bit
      of \TT{immedA}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Stack and Housekeeping Instructions}
\label{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}
\end{boxedfigure}

\section{Arithmetic Exceptions}
\label{ARITHMETIC-EXCEPTIONS}

Arithmetic instructions (Figure~\itemref{ARITHMETIC-INSTRUCTIONS})
may raise the exceptions in Figure~\itemref{EXCEPTIONS}.
When an exception is raised, a flag bit associated with the
exception is turned on the process's \TT{excepts\_\EOL accumulator}
member.  This bit is usually never turned off, and so can be used at the
end of an execution to determine what types of exception
occurred during the execution.

In C/C++ the flag bit associated with exception \TT{XX}
is defined as a bit mask macro \TT{FE\_XX} in \TT{fenv.h}
(see fenv(3) in the UNIX manual):

\begin{boxedfigure}[b!]
\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{DIVBYZERO} &  An operation on finite numbers produces infinity \\
                  &  as a result (e.g., {\tt 5/+0}).
\\\hline
\ttkey{INVALID} & An operation has no well defined result
                  (e.g., {\tt 0/0}). \\
		& \TT{NaN} becomes the result.
\\\hline
\ttkey{OVERFLOW} & An operation produces a finite result too large to
                   store. \\
		 & An infinity becomes the result.
\\\hline
\ttkey{UNDERFLOW} & An operation produces a finite result too small to
                    store. \\
	          & {\tt +0} or {\tt -0} becomes the result.
\\\hline
\ttkey{INEXACT} & An operation produces a finite result that cannot
                  be stored exactly. \\
		& The result is rounded to the nearest value.
\\\hline
\end{tabular}
\end{center}
\caption{Exceptions}
\label{EXCEPTIONS}
\end{boxedfigure}

Only arithmetic instructions in Figure~\itemref{ARITHMETIC-INSTRUCTIONS}
and the \TT{PUSHV} instruction in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS} can raise
exceptions.

In non-optimized mode, i.e.~when a process's \TT{optimize} member is \TT{false},
an instruction that raises an exception prints
an error message if the instruction exception is one whose bit
is on in the process's \TT{excepts\_mask}\label{EXCEPTS-MASK} member.
This error message is always followed by a trace of the instruction
(regardless of the process trace flag settings): see
Instruction Tracing, \itemref{INSTRUCTION-TRACING}.

In optimized mode, instructions do not print error messages
involving exceptions.  However exception flag bits are still
raised in the process's \TT{excepts\_accumulator} member.

In both modes, when a process terminates and there is any exception
bit on in both the process's \TT{excepts\_\EOL accumulator}
and \TT{excepts\_mask} member, an error message is printed.

\needspace{5\baselineskip}

The \TT{mexas} program's (see \itemref{THE-MEXAS-PROGRAM}) initial setting of
a process's \TT{excepts\_mask} member is:
\begin{center}
\TT{DIVBYZERO} ~~ \TT{INVALID} ~~ \TT{OVERFLOW}
\end{center}

\section{Instruction Tracing}
\label{INSTRUCTION-TRACING}

A process has two modes: \key{normal} and \key{optimized}, as
determined by the \TT{optimize}\label{OPTIMIZE} member of the process.
The default setting of the \TT{optimize} member of a process
is \TT{false}.

In normal mode, tracing of an instruction
is controlled by the \key{trace class} $C$ of the instruction
and the \key{trace flags}\label{TRACE-FLAGS} $F$ of the process.  If
\TT{$F$ \& ( 1 <{}< $C$ ) != 0} the instruction is traced.

In optimized mode, instructions are \underline{not} traced,
except that instructions in the \ttkey{ALWAYS} trace class are always
traced.  These include the \TT{TRACE}, \TT{TRACE\_\EOL EXCEPTS},
\TT{SET\_\EOL TRACE},
\TT{WARN}, and \TT{ERROR} instructions.

Instructions in the \ttkey{NEVER} trace class are never
traced.  Typically there are compiler switches that will
change to \TT{NEVER} the trace class stored in every instruction that
does not have the \TT{ALWAYS} class
(see The MEXAS Program \TT{-tcnever} option, page \pageref{-TCNEVER}).

The trace classes are given in Figure \itemref{TRACE-CLASSES-AND-GROUPS}.
Also given there are trace groups that can be used for convenience
to set the trace flags of a process to include
a pre-defined group of trace classes.
Trace class names and trace group names are used by compiler switches
which set the initial trace flags of processes
(see The MEXAS Program \TT{-tc:\ldots} option, page \pageref{-TC:}),
and by the
\TT{SET\_\EOL TRACE} instruction that sets the current trace flags
of a process.

Notice that all arithmetic instructions have the same
trace class, all \TT{PUSH\ldots} instructions have the same trace
class, and all conditional \TT{JMP\ldots} instructions have the
same two trace classes, one for a successful jump and one for
a failed jump.  Other instructions each have their own trace class,
except for those with the \TT{ALWAYS} class.

In C++ code trace class \TT{XX} is a number that is the value of
the \TT{mex::T\_XX} constant.  Thus the trace class of \TT{ADD}
is \TT{mex::T\_AOP}.


\begin{boxedfigure}[!h]

\begin{center}

\bigskip

{\Large \bf Trace Classes}
\\[2ex]
\begin{tabular}{|l|p{5in}|}
\hline
\ttmkey{NEVER}{trace class} & Instruction is never traced.
\\\hline
\ttmkey{ALWAYS}{trace class} & Instruction is always traced.
    The following instructions have this trace class:
    \TT{ERROR}, \TT{WARN}, \TT{TRACE}, \TT{TRACE\_\EOL EXCEPTS},
    \TT{SET\_\EOL TRACE}.
\\\hline
\ttmkey{AOP}{trace class} & Arithmetic instructions in Figure
    \itemref{ARITHMETIC-INSTRUCTIONS}.
\\\hline
\ttmkey{PUSH}{trace class} & All \TT{PUSH\ldots} instructions in Figures
    \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS} and
    \itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}.
\\\hline
\ttmkey{POP}{trace class} & The \TT{POP} instruction in Figure
    \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
\\\hline
\ttmkey{JMP}{trace class} & The \TT{JMP} instruction.
\\\hline
\begin{tabular}[t]{@{}l@{}}
\ttmkey{JMPS}{trace class} \\
\ttmkey{JMPF}{trace class}
\end{tabular} & \TT{JMP\ldots} instructions in
	        Figure \itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.
		When compiled the instruction is given the \TT{JMPS}
		class.  When executed, if the jump test succeeds
		(jump is taken),
		the instruction trace class is left unchanged, but if
		the jump test fails (there is no actual jump),
		the effective trace class is changed
		to \TT{JMPF}.
\\\hline
\ttmkey{SET}{trace class} & The \TT{VPUSH}, \TT{SET},
                            and \TT{SETI} instructions in Figure
                            \itemref{OBJECT-INSTRUCTIONS}.
\\\hline
\ttmkey{GET}{trace class} & The \TT{VPOP}, \TT{GET},
                            and \TT{GETI} instructions in Figure
                            \itemref{OBJECT-INSTRUCTIONS}.
\\\hline
\ttmkey{XXX}{trace class} & Instruction with operation code \TT{XXX},
                            for instructions not mentioned above
			    (e.g., for \TT{NOP}, \TT{BEG}, etc.,
			    but \underline{not} for \TT{ADD},
			    \TT{PUSH}, \TT{JMPEQ}, \TT{ERROR}, etc.).
\\\hline
\end{tabular}
\end{center}

\begin{center}
{\Large \bf Trace Class Groups}
\\[2ex]
\begin{tabular}{|l|l|}
\hline
\ttmkey{ALL}{trace class group} &  All trace classes.
\\\hline
\ttmkey{NONE}{trace class group} &  No trace classes.
\\\hline
\ttmkey{FUNC}{trace class group} &  \TT{CALLM} \TT{CALLG} \TT{RET} \TT{ENDF}
\\\hline
\ttmkey{LOOP}{trace class group} &  \TT{BEGL} \TT{CONT} \TT{ENDL}
\\\hline
\end{tabular}
\end{center}
\caption{Trace Classes and Groups}
\label{TRACE-CLASSES-AND-GROUPS}
\end{boxedfigure}

\subsection{Trace Messages}
\label{TRACE-MESSAGES}

Each instruction trace message begins with:
\begin{indpar}
\emkey{trace-header} ::= \\
\hspace*{0.3in}
\TT{\{}{\em line-number}\TT{:}{\em code-vector-location}%
                        \TT{,}{\em stack-length}%
                        \TT{,}{\em process-counter}\TT{\}} ~ {\em op-code}
\end{indpar}
The {\em line-number} is the number of the \underline{last} source code
line containing code that generated the instruction.
The {\em code-vector-location} is the index of the instruction
in its code vector.
The {\em stack-length} is the number of values in the stack
just \underline{after} the traced instruction executes.
The {\em process-counter} is the number of instruction executions
since the process was originally initialized just \underline{after} the traced
instruction executes.  The {\em op-code} is the instruction operation code.

The rest of the instruction trace message is specific to the type of
instruction and is specified in the following subsections.  However
in all cases it is based on the value of
\TT{module->\EOL trace\_\EOL info[i]} where \TT{i} is the index of
the instruction in its code vector.
If \TT{module->\EOL trace\_\EOL info[i]} does not exist
or is of an unexpected type, the message may be incomplete.

\subsubsection{Arithmetic Tracing}
\label{ARITHMETIC-TRACING}

The trace message of an arithmetic instruction has the form:
\begin{center}
{\em trace-header}\TT{:} {\em new-variable-name} \TT{=} {\em value}
                    \TT{<=} {\em value}\QMARK{}
                    {\em operator} {\em value}
\end{center}
If {\em new-variable-name} is not given in the instruction,
\TT{*} is used instead.
Note that arithmetic instructions are usually not traced.

For an arithmetic instruction the value of
\TT{module->\EOL trace\_\EOL info[i]} is {\em new-variable-name}
as a MIN string (this may be \TT{*}).
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string,
\TT{*} is used as {\em new-variable-name}.

\subsubsection{Jump Tracing}
\label{JUMP-TRACING}

\TT{JMP\ldots} instruction trace messages have the form:

\begin{center}
{\em trace-header} {\em jmp-target} \TT{is successful:~true}
                    \TT{<=} {\em value} \{ {\em operator} {\em value} \}\QMARK{}
\end{center}
or
\begin{center}
{\em trace-header} {\em jmp-target} \TT{is UNsuccessful:~false}
                    \TT{<=} {\em value} \{ {\em operator} {\em value} \}\QMARK{}
\end{center}

or for a plain unconditional \TT{JMP} instruction, just:
\begin{center}
{\em trace-header} {\em jmp-target}
\end{center}

For a jump instruction the value of
\TT{module->\EOL trace\_\EOL info[i]} is {\em jmp-target}
as a MIN string or label.
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string or label,
`\TT{location} {\em target-index}' is used as {\em jump-target}, where
{\em target-index} is the index of the target instruction in its
module's code vector.

For the comparison jump instructions (\TT{JMPGT}, etc.), a \TT{*}
is appended to the {\em op-code} name if the instruction's
\TT{immedB} is non-zero (so that for an unsuccessful jump,
the first value popped is
pushed back into the stack).

\subsubsection{Push/Pop Tracing}
\label{PUSH/POP-TRACING}

\TT{PUSH\ldots} instructions and the \TT{POP} instruction are in essence
value copy instructions and their trace messages
have the form:

\begin{center}
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<=} {\em from-variable} \TT{=} {\em value}
\end{center}

For \TT{PUSH\ldots} the {\em to-variable} is the {\em new-variable}
and the {\em from-variable} is the instruction {\tt variable}.
For \TT{POP} the {\em to-variable} is the instruction {\em variable}
and the {\em from-variable} is the name of the top of the stack.

As always in tracing, `\TT{*}' is used for a missing variable name.

For a \TT{PUSH\ldots} or \TT{POP} instruction
in Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}
the value of
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\TT{[<} {\em from-variable} ~ {\em to-variable} \TT{>]}.
If \TT{module->\EOL trace\_\EOL info[i]} is not a 2 element MIN label,
both {\em from-variable} and {\em to-variable} are taken to be \TT{*}.

However there are two exceptions with different {\em from-variables}
and with {\em trace\_\EOL info[i]} equal to just {\em to-variable}.
They are:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\bf Op Code & \bf \em from-variable
\\\hline
\TT{PUSHNARGS} & \TT{nargs[$L$]} \\
\TT{PUSHV}     & \TT{sp[fp[$L$]-nargs[$L$]+$V$-1]}
\end{tabular}
\\[1ex]
where $L$ is the lexical level \\
and $V$ is the value at the top of the stack
\end{center}
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN string,
{\em to-variable} is taken to be \TT{*}.

\subsubsection{Object Instruction Tracing}
\label{OBJECT-INSTRUCTION-TRACING}

The trace messages for the object instructions in
Figure~\itemref{OBJECT-INSTRUCTIONS} are:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
\TT{VPUSH} &
{\em trace-header}\TT{:} \TT{PUSHED} {\em object-variable}
                    \TT{<=} {\em from-variable}
		    \TT{=} {\em value}
\\[1ex]
\TT{VPOP} &
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<= POPPED} {\em object-variable}
		    \TT{=} {\em value}
\\[1ex]
\TT{GET}/\TT{GETI} &
{\em trace-header}\TT{:} {\em to-variable}
                    \TT{<=} {\em object-variable}\TT{[}{\em label-value}\TT{]}
		    \TT{=} {\em value}
\\[1ex]
\TT{SET}/\TT{SETI} &
{\em trace-header}\TT{:} {\em object-variable}\TT{[}{\em label-value}\TT{]}
		    \TT{<=} {\em from-variable} \TT{=} {\em value}
\end{tabular}
\end{center}

For these instructions,
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\TT{[<} {\em from-variable} ~ {\em to-variable} \TT{>]},
where one of the two variables is {\em object-variable}.
If \TT{module->\EOL trace\_\EOL info[i]} does not have the right form,
{\em from-variable} and {\em to-variable} are taken to be \TT{*}.


\subsubsection{Trace-Packet Based Trace Messages}
\label{TRACE-PACKET-BASED-TRACE-MESSAGES}

A \key{trace packet} is a \key{trace packet message} and a list of
\skey{trace variable}s.\label{TRACE-VARIABLE}
The trace message of a trace packet
instruction has the form:
\begin{indpar}
    {\em trace-header}\TT{:} ~
    {\em trace-packet-message} ~
    \{\TT{,} {\em trace-variable}\TT{=}{\em value} \} \STAR{}
\end{indpar}

For a trace packet instruction
\TT{module->\EOL trace\_\EOL info[i]} is the MIN label
\begin{center}
\vspace*{-1ex}
\TT{[<} {\em trace-packet-message} ~ {\em trace-variable}\STAR{} \TT{>]}
\end{center}
If \TT{module->\EOL trace\_\EOL info[i]} is not a MIN label with at
least one element, then just the {\em trace-header} is output.

The trace packet instructions are:
\begin{center}
\begin{tabular}{ll}
Standard Trace Packet Instructions: &
    \TT{BEG} ~ \TT{END} ~ \TT{TRACE} ~ \TT{NOP} ~ \TT{WARN} ~ \TT{ERROR}
\\[0.5ex]
Special Trace Packet Instructions: &
    \TT{BEGL} ~ \TT{ENDL} ~ \TT{CONT}  \\
  & \TT{BEGF} ~ \TT{ENDF} ~ \TT{CALL\ldots} ~ \TT{RET}
\end{tabular}
\end{center}

For standard trace packet instructions, the compiler must push
the values of the trace variables into the stack just
before the instruction.  Then the instruction is traced before
it is executed, if tracing the instruction is enabled.  Lastly
the instruction execution pops the trace variable
values from the stack, which is why instructions such as \TT{NOP} and
\TT{TRACE}
can pop stack values.  This trace variable pushing and popping are made
invisible to the programmer by the compiler.

The special trace packet instructions do \underline{no} pushing and popping
of trace variable values, and sometimes use the trace packet
of an instruction related to them rather than a trace packet of their
own.  Specifically:

\begin{center}
\begin{tabular}{lp{4.0in}}
\TT{BEGL}  & Uses its own trace packet, with the \TT{immedB} loop variable
             values in the stack when \TT{BEGL} is executed as the trace packet 
	     variable values.
\\[0.5ex]
\TT{ENDL}/\TT{CONT}  & Uses the trace packet of the associated \TT{BEGL},
                       with the \TT{next-\ldots} variable values in the
		       stack \underline{after} the \TT{ENDL} or \TT{CONT}
		       has been executed as the trace variables.
		       At this time these \TT{next-\ldots} variable values
		       are a copy of the loop variable values for the next
		       iteration.
\\[0.5ex]
\TT{CALL\ldots}  & Uses the trace packet of the associated \TT{BEGF},
                   with the argument values in the stack as the trace
		   variable values. 
		   Also the {\em op-code}
		   in the {\em trace-header} is replaced by
		   \TT{CALL\ldots{}~to BEGF}\label{CALL-TO-BEGF}.
\\[0.5ex]
\TT{RET}/\TT{ENDF}  & Uses the trace packet of the associated \TT{CALL},
                   with the return values in the stack as the trace
		   variable values.
		   Also the {\em op-code}
		   in the {\em trace-header} is replaced by
		   \TT{RET to CALL\ldots}\label{RET-TO-CALL}
		   or \TT{ENDF to CALL\ldots}.
\end{tabular}
\end{center}

Note: The compiler should make the trace variables of a \TT{BEGL}
match the names actually used in source code to refer to the loop
variables, and similarly for \TT{BEGF} and arguments and \TT{CALL\ldots}
and return values.
But MEX knows nothing of names used in source code.
To see how MEXAS handles this look at MEXAS Instructions,
\itemref{MEXAS-INSTRUCTIONS}.



\subsubsection{Other Instruction Trace Messages}
\label{OTHER-INSTRUCTION-TRACE-MESSAGES}

\begin{center}
\begin{tabular}{lp{4.5in}}
\bf Op Code     & \bf Trace Message
\\\hline
\ttmkey{SET\_TRACE}{trace message}
		& {\em trace-header}\TT{:} {\em trace-class}\STAR{} \\
                & The {\em trace-classes} being enabled are
	          listed, but they are \underline{not}
		  aggregated into {\em trace-class-groups}.
\\[0.5ex]
\ttmkey{SET\_EXCEPTS}{trace message}
		& {\em trace-header}\TT{:}
                    \{ \TT{*}\QMARK{}{\em except-name} \}\STAR{} \\
                & The names of the excepts being enable in
		  \TT{p->excepts\_mask} are listed, and those that are
		  also in \TT{p->excepts\_accumulator} are starred with
		  \TT{*}.
\\[0.5ex]
\ttmkey{SET\_OPTIMIZE}{trace message}
		& {\em trace-header}\TT{:}
                    {\em new-value} \TT{<=} {\em old-value} \\
                & The new and old values are listed as indicated.
		  The values are denoted as \TT{ON} or \TT{OFF}.
\\[0.5ex]
\ttmkey{TRACE\_EXCEPTS}{trace message}
		& {\em trace-header}\TT{:}
                    \{ \TT{*}\QMARK{}{\em except-name} \}\STAR{} \\
                & The names of the excepts in \TT{p->excepts\_accumulator}
		  are listed, and those that are also in \TT{p->excepts\_mask}
		  are starred with \TT{*}.
\end{tabular}
\end{center}

\subsection{Trace Depth}
\label{TRACE-DEPTH}

Trace messages are indented by the process's \TT{trace\_depth} member
times the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{trace\_indent}\verb|    // Default == 2.|
\end{indpar}
In addition, in the first line of a message all the indent spaces but
the last are replaced by the value of the global variable:
\begin{indpar}
\verb|char mex::|\MEXKEY{trace\_mark}\verb|    // Default == '*'.|
\end{indpar}

A process's \TT{trace\_depth} is initialized to \TT{0} and maintained
by the following instructions:
\begin{center}
\begin{tabular}{l@{~~~~}l}
\TT{BEG} ~ \TT{BEGL} ~ \TT{CALL}+\TT{BEGF} & Increment by 1. \\
\TT{END} ~ \TT{ENDF} ~ \TT{RET} & Decrement by 1. \\
\TT{JMP\ldots} ~ \TT{CONT} & Decrement by the instruction's \\
               & \TT{trace\_depth} member. \\
\end{tabular}
\end{center}
Note: \TT{JMP\ldots} is the only way to exit the current loop (\TT{ENDL} and
\TT{CONT} start a new iteration).

A process's \TT{trace\_depth} is maintained even when the process's
\TT{optimize} switch is \TT{true} (only a few instructions change
the trace depth).

\section{MEX Functions}
\label{MEX Functions}

{\tt mex::module mex::}\MEXKEY{create\_module}
    \verb|( min::file f )|
\begin{indpar}
A \TT{mex::module} is created and returned.  The code vector is empty.
Empty \TT{position} and \TT{trace\_info} vectors are created.
The \TT{globals} member is set to \TT{min::NULL\_STUB} and the
\TT{interface} member is set to \TT{min::MISSING()}.

The \TT{max\_length} of the three empty vectors is initially set to:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{module\_length}\verb|    // Default == 1 << 12.|
\end{indpar}

Note that \TT{mex::module} and its components are read-only, so that
to push instructions, positions, and info into the vectors the module type
must be converted to \TT{mex::module\_ins}.  The following inline
functions can be used to push elements into these vectors and
call \TT{min::acc\_write\_update} as necessary:
\begin{indpar}
{\tt void mex::}\MEXKEY{push\_instr} \\
\hspace*{2em}\verb|( mex::module_ins m, const mex::instr & instr )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_position} \\
\hspace*{2em}\verb|( mex::module m, const min::phrase_position & pp )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_trace\_info} \\
\hspace*{2em}\verb|( mex::module, min::gen info )|
\end{indpar}

These functions will increase the \TT{max\_length} of the vectors
automatically if necessary.

\end{indpar}

{\tt min::locatable\_var<min::printer> mex::}\MEXKEY{default\_printer}
\begin{indpar}
Default printer for \TT{create\_process}.  Initially \TT{min::NULL\_STUB}.
\end{indpar}

{\tt mex::process mex::}\MEXKEY{create\_process} \\
\hspace*{10em}\verb|( min::printer printer = mex::default_printer )|
\begin{indpar}
A \TT{mex::process} is created and returned.  The \TT{printer} argument
must \underline{not} be \TT{min::\EOL NULL\_\EOL STUB}.

The process \TT{length} member (stack size) is set to \TT{0}
and its \TT{max\_length} member (maximum stack size) is set to the
value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{run\_stack\_limit}\verb|    // Default == 16384.|
\end{indpar}

An empty \TT{return\_stack} vector is created and its \TT{max\_size}
is set to the value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{run\_return\_stack\_limit}%
            \verb|    // Default == 4096.|
\end{indpar}

Note: the stack's \TT{max\_length} members are \underline{not} permitted
to change during process execution, but see \TT{mex::\EOL run\_\EOL process}.

The \TT{printer} member is set to the \TT{printer} argument.
The \TT{counter\_\EOL limit}, \TT{trace\_\EOL flags},
\TT{excepts\_\EOL mask}, and \TT{optimize} members
are set respectively from:
\begin{indpar}\begin{tabular}{r@{}l}
\verb|min::uns32 mex::| & \MEXKEY{run\_counter\_limit} \\
                        & \verb|// Default == 1 << 20|
\\[0.5ex]
\verb|min::uns32 mex::| & \MEXKEY{run\_trace\_flags} \\
                        & \verb|// Default == 1 << mex::T_ALWAYS|
\\[0.5ex]
\verb|int mex::| & \MEXKEY{run\_excepts\_mask} \\
            & \verb+// Default == FE_DIVBYZERO|FE_INVALID|FE_OVERFLOW+
\\[0.5ex]
\verb|bool mex::| & \MEXKEY{run\_optimize} \\
            & \verb|// Default == false|
\end{tabular}\end{indpar}

The \TT{pc} member is set to \TT{\{min::NULL\_STUB,0\}}.
The \TT{fp[\ldots]}, \TT{nargs[\ldots]}, \TT{level}, \TT{trace\_\EOL depth},
\TT{counter}, \TT{optimized\_\EOL counter}, and \TT{excepts\_\EOL accumulator}
members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.


\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::module m, mex::process p = min:NULL_STUB )|
\begin{indpar}
Initialize \TT{p} (which is created by \TT{mex::create\_process}
if that is \TT{NULL\_STUB}) to run the code in \TT{m}.
Return the process.

The \TT{pc} member is set to \TT{\{m,0\}}.

The \TT{fp[\ldots]}, \TT{nargs[\ldots]}, \TT{level}, \TT{trace\_\EOL depth},
\TT{counter}, \TT{optimized\_\EOL counter}, and
\TT{excepts\_\EOL accumula\-tor} members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.

The stack sizes, \TT{counter\_limit}, \TT{trace\_flags},
\TT{excepts\_mask}, and \TT{optimize} members are
\underline{not} changed.

\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::pc pc, mex::process p = min:NULL_STUB )|
\begin{indpar}
Ditto, but does not set the process \TT{pc} member.

Then emulates a \TT{CALL} to the \TT{pc} argument
value, which must point at a \TT{BEGF} instruction with \TT{immedB == 1}
(i.e., lexical level = 1).
This creates a \TT{return\_stack} entry whose
\TT{saved\_pc} is \TT{\{min::NULL\_STUB,0\}}, so a return
will terminate the process normally.  The \TT{nargs} and \TT{nresults} members
are set to \TT{0}.

If there is an error in pointing at a \TT{BEGF} instruction of level 1,
then instead the process \TT{pc} member is set to the illegal value
\TT{\{ min::NULL\_STUB, 1 \}} and \TT{min::NULL\_STUB} is returned.
\end{indpar}

{\tt bool mex::}\MEXKEY{run\_process} \verb|( mex::process p )|%
\label{MEX::RUN_PROCESS}
\begin{indpar}
Execute \TT{p} until it terminates.
Returns \TT{true} on normal termination
and \TT{false} otherwise.  The process \TT{state} is
set as follows to indicate cause of termination:
\end{indpar}
\begin{center}
\begin{tabular}{ll}
\multicolumn{2}{c}{\bf States That Return \TT{true}}
\\[1ex]
\verb|mex::|\MEXKEY{MODULE\_END}
    & \TT{pc} equals \TT{\{m,index\}} \\
    & with \TT{index == m->length} \\
\verb|mex::|\MEXKEY{CALL\_END}
    & \TT{pc} equals \TT{\{min::NULL\_STUB,0\}}
\\[1ex]
\multicolumn{2}{c}{\bf States That Return \TT{false}} \\
\multicolumn{2}{c}{\bf But Do NOT print An Error Message}
\\[1ex]
\verb|mex::|\MEXKEY{COUNTER\_LIMIT\_STOP}
    & \TT{p->counter > p->limit} \\
\verb|mex::|\MEXKEY{STACK\_LIMIT\_STOP}
    & \TT{p->length > p->max\_length} \\
\verb|mex::|\MEXKEY{RETURN\_STACK\_LIMIT\_STOP}
    & \TT{p->return\_stack->length >} \\
    & \TT{p->return\_stack->max\_length}
\\[1ex]
\multicolumn{2}{c}{\bf States That Return \TT{false}} \\
\multicolumn{2}{c}{\bf And Also print An Error Message}
\\[1ex]
\verb|mex::|\MEXKEY{ERROR\_STOP}
    & \TT{ERROR} instruction with \TT{immedB != 0} \\
\verb|mex::|\MEXKEY{JMP\_ERROR}
    & conditional \TT{JMP\ldots}~instruction with \\
    & invalid operand(s) (either a \TT{NaN} or \\
    & both infinities of the same sign) \\
\verb|mex::|\MEXKEY{FORMAT\_ERROR}
    & program formatting error \\
    & (likely a compiler error) \\
\end{tabular}
\end{center}

Notes:
\begin{enumerate}
\item For cases where \TT{false} is returned by \TT{mex::run\_process},
the process stops \underline{before} executing the instruction which
would violate the condition.
Thus the process will stop before executing an instruction that would
violate one of the limits, trigger a programming format error, etc.
The \TT{ERROR} instruction stops the process with the program counter
pointing at the \TT{ERROR} instruction.
\item \label{LIMIT-STOP-NOTE}
On \TT{\ldots\_LIMIT\_STOP}, you can increase the limit
and call \TT{run\_process} again to continue execution.
For stacks you must re-size the stack (as per \TT{min::\EOL resize}).
\item You can use \TT{init\_process ( m )} followed by \TT{run\_process}
to run the code of \TT{m}.  Then after \TT{MODULE\_END},
you can add to the end of \TT{m}
and call \TT{run\_process} again to continue the execution of the code
of \TT{m} (i.e., execute the added code).
\end{enumerate}

{\tt bool mex::}\MEXKEY{excepts\_check} \verb|( mex::process p )|%
\label{MEX::EXCEPTS_CHECK}
\begin{indpar}
If \hspace*{0.5in}
\TT{flags = p->excepts\_mask \& p->excepts\_accumulator} \\
is zero,
returns \TT{true}.  Otherwise prints a WARNING message listing
the bits of \TT{flags} that are on and returns \TT{false}.
\end{indpar}

\section{MEX Compiler Components}
\label{MEX-COMPILER-COMPONENTS}

Compilers that compile into MEX have some structure in common,
and the MEX has two compiler components, each with data and
functions that can be shared among all these compilers.

\subsection{MEX Basic Compiler Component}
\label{MEX-BASIC-COMPILER-COMPONENT}

The MEX basic compiler component provides functions that print
compiler error and warning messages and count errors and warnings.
It also provides some data structures including a stack of all the
modules compiled and information tables for op codes, trace classes,
trace flags, and except masks.

The MEX basic compiler component is in the following:

\begin{indpar}
\begin{tabular}{l}
{\tt namespace} \ttkey{mexcom}
\\
{\tt \ldots/mex/include/}\ttkey{mexcom.h}
\\
{\tt \ldots/mex/src/}\ttkey{mexcom.cc}
\end{tabular}
\end{indpar}

\subsubsection{MEX Basic Compiler Data}
\label{MEX-BASIC-COMPILER-DATA}

\begin{tabular}{@{}r@{~~~}l}
\verb|min::locatable_var<mex::module_ins> mexcom::|
	& \MEXCOMKEY{output\_module} \\
\verb|min::locatable_var<min::file> mexcom::|
	& \MEXCOMKEY{input\_file}
\end{tabular}

\begin{indpar}
These must be set by the compiler to
the {\tt mex::module} currently being compiled and
its input file.  The printer used by the compiler is
{\tt mexcom::input\_file->printer}.
\end{indpar}

\begin{tabular}{@{}r@{~~~}l}
\verb|typedef min::packed_vec_insptr<mex::module> mexcom:|
	& \MEXCOMKEY{module\_stack} \\
\verb|min::locatable_var<mexcom::module_stack> mexcom:|
	& \MEXCOMKEY{modules}
\end{tabular}
\begin{indpar}
{\tt Mexcom::modules}
is the list of modules completely compiled so far, organized as
a stack, most recent topmost.  When the compiler finishes compiling
a module, it should execute: \\
\hspace*{3em}{\tt min::push(mexcom::modules) = mexcom::output\_module}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{op\_code\_table}
\begin{indpar}
For {\tt op\_code OP < mex::NUMBER\_OF\_OP\_CODES}
with name {\tt "OP"}:\\
\hspace*{3em}{\tt op\_code\_table[OP] == new\_str\_gen ( "OP" )} \\
and \\
\hspace*{3em}{\tt ~~~min::get ( op\_code\_table, new\_str\_gen ( "OP" ) )} \\
\hspace*{3em}{\tt == new\_num\_gen ( OP )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{trace\_class\_table}
\begin{indpar}
For {\tt trace\_class} {\tt T\_XX < mex::NUMBER\_OF\_TRACE\_CLASSES}
with name {\tt "XX"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_class\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( T\_XX )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{trace\_flag\_table}
\begin{indpar}
For {\tt trace\_class} {\tt T\_XX < mex::NUMBER\_OF\_TRACE\_CLASSES}
with name {\tt "XX"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_class\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( 1 <{}< T\_XX )} \\
For trace group {\tt GG := GG1, GG2, ...}
with name {\tt "GG"}:\\
\hspace*{3em}{\tt ~~~min::get ( trace\_group\_table, new\_str\_gen ( "GG" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( (1 <{}< T\_GG1) $|$ (1 <{}< T\_GG2) $|$ ... )}
\end{indpar}

\verb|min::locatable_gen mexcom::| \MEXCOMKEY{except\_mask\_table}
\begin{indpar}
For except named {\tt "XX"} with mask {\tt M = 1 <{}< FE\_XX}: \\
\hspace*{3em}{\tt ~~~min::get ( except\_mask\_table, new\_str\_gen ( "XX" ) )}
\\
\hspace*{3em}{\tt == new\_num\_gen ( M )}
\end{indpar}

\subsubsection{MEX Basic Compiler Functions}
\label{MEX-BASIC-COMPILER-FUNCTIONS}

\verb|min::uns32 mexcom::| \MEXCOMKEY{error\_count} \\
\verb|min::uns32 mexcom::| \MEXCOMKEY{warning\_count} \\
\verb|void mexcom::| \MEXCOMKEY{compile\_error} \\
\verb|        ( const min::phrase_position & pp,| \\
\verb|          const char * message1,| \\
\verb|          const min::op & message2 = min::pnop,| \\
\verb|          const char * message3    = "",| \\
\verb|          const min::op & message4 = min::pnop,| \\
\verb|          const char * message5,   = ""| \\
\verb|          const min::op & message6 = min::pnop,| \\
\verb|          const char * message7,   = ""| \\
\verb|          const min::op & message8 = min::pnop,| \\
\verb|          const char * message9,   = "" )| \\
\verb|void mexcom::| \MEXCOMKEY{compile\_warn} \\
\verb|        ( const min::phrase_position & pp,| \\
\verb|          const char * message1,| \\
\verb|          const min::op & message2 = min::pnop,| \\
\verb|          const char * message3    = "",| \\
\verb|          const min::op & message4 = min::pnop,| \\
\verb|          const char * message5,   = ""| \\
\verb|          const min::op & message6 = min::pnop,| \\
\verb|          const char * message7,   = ""| \\
\verb|          const min::op & message8 = min::pnop,| \\
\verb|          const char * message9,   = "" )|
\begin{indpar}
Print error message (or warning message).  Increment
{\tt mexcom::error\_count} (or increment {\tt mexcom::\EOL warning\_count}).
If {\tt pp != min::\EOL MISSING\_\EOL PHRASE\_\EOL POSITION},
print source lines after error message, and print the source file name and
source line numbers as part of the error message.  Printing is done using
{\tt mexcom::\EOL input\_\EOL file} and
{\tt mexcom::\EOL input\_\EOL file->\EOL printer}.
\end{indpar}


\subsection{MEX Stack Compiler Component}
\label{MEX-STACK-COMPILER-COMPONENT}

MEX code is organized into blocks: {\tt BEGF/ENDF} \skey{function block}s,
{\tt BEGL/ENDL} \skey{loop block}s, and {\tt BEG/END} \skey{ordinary block}s.
The MEX process stack\pagnote{PROCESS-STACK} is also block organized:
each process stack block consists of all the variables allocated
by a code block (or in the case of function arguments, allocated for
a function code block by code that calls the function).

Each function block is assigned a (lexical) \key{level}.
The entire code of a module is treated as a virtual function block
of level 0.  Other function blocks are assigned the level of their
smallest containing function block plus 1.  Thus
a function block not inside any other non-virtual function block
(but inside the virtual module function block) is assigned level 1.

Each block is also assigned a depth.  Function blocks are assigned depth
0, and the virtual function block of all module code is assigned depth 0.
Non-function blocks are assigned the depth
of their smallest containing block (function or non-function) plus 1.

Instructions are assigned the level and depth of their smallest containing
block.

The MEX stack compiler component ({\tt mexstack}) assumes that the compiler
maintains a variable stack, a function stack, and a function variable stack
(a \key{function variable} is a function with no arguments whose name
behaves like a variable name).
When the compiler outputs a {\tt PUSH\ldots}~instruction
that creates a variable, it pushes the name of the variable
into the variable stack.  When the compiler outputs a {\tt BEGF}
instruction that creates a function, it pushes the name of the function
into the function stack if the function has arguments, or into the
function variable stack if the function has no arguments.
The stack elements are assigned the level and depth
of the instructions output to create them.
When the block end instruction ({\tt ENDF}, {\tt ENDL}, or {\tt END}) for
this level and depth is output, the elements with this level and depth
are popped from their stacks.

The compiler may implement the stacks as symbol tables optimized
for looking up names.  These tables are stacks only in the sense that
elements can be deleted in the reverse order to that which they were added.
The compiler may also combine these tables, so variables and functions
are all in one table.  However for variables it is important for the
compiler to assign to each variable an index specifying its position
in the conceptual variable stack.  When a variable is added to the table,
it is assigned as its index the number of variables in the table before
it is added.

Note that trace values (values of
trace variables\pagnote{TRACE-VARIABLE}) in the process
stack are \underline{not} recorded in the compiler variables stack when their
{\tt PUSH\ldots}~instructions are output.

The MEX stack compiler component is in the following:

\begin{indpar}
\begin{tabular}{l}
{\tt namespace} \ttkey{mexstack}
\\
{\tt \ldots/mex/include/}\ttkey{mexstack.h}
\\
{\tt \ldots/mex/src/}\ttkey{mexstack.cc}
\end{tabular}
\end{indpar}

\subsubsection{MEX Stack Component Data}
\label{MEX-STACK-COMPONENT-DATA}

For stack management the compiler and {\tt mexstack}
communicate through the following variables and functions:

\begin{tabular}{@{}r@{~~~}l}
\verb|min::uns32 mexstack::| & \MEXSTACKKEY{var\_stack\_length}%
    \label{VAR-STACK-LENGTH} \\
\verb|min::uns32 mexstack::| & \MEXSTACKKEY{func\_stack\_length} \\
\verb|min::uns32 mexstack::| & \MEXSTACKKEY{func\_var\_stack\_length} \\
\verb|void mexstack::| & \MEXSTACKKEY{pop\_stacks} {\tt ( void )}
\end{tabular}

\begin{indpar}
These are the lengths of the three compiler stacks: variable, function,
and function variable.  Or alternatively they are the number of
variable, function, and function variable elements in the compiler
symbol table.

These are mostly maintained by the compiler and read by {\tt mexstack}
code.  However, {\tt mexstack} code may \underline{decrease}
(or leave untouched) the values in these variables and then,
\underline{before} returning control to the compiler, call the
{\tt pop\_stacks} function which is provided by the compiler and which
will remove elements from the stacks until the stack lengths match
the values in the above variables.

The {\tt mexstack::init} function (see below) zeros these variables.
\end{indpar}

{\tt Mexstack} also maintains the following:

\begin{tabular}{@{}l@{~~~}l}
\verb|min::uns8 mexstack::| & \MEXSTACKKEY{lexical\_level} \\
\verb|min::uns8 mexstack::| &
    \MEXSTACKKEY{depth}\verb|[mex::max_lexical_level+1]| \\
\verb|min::uns32 mexstack::| &
    \MEXSTACKKEY{lp}\verb|[mex::max_lexical_level+1]| \\
\verb|min::uns32 mexstack::| &
    \MEXSTACKKEY{fp}\verb|[mex::max_lexical_level+1]| \\
\verb|min::uns32 mexstack::| & \MEXSTACKKEY{stack\_limit} \\
\end{tabular}
\begin{indpar}
{\tt Lexical\_level} is the current lexical level, i.e., the lexical
level of the next instruction to be output by the compiler.
{\tt Depth[$L$]} is the current depth of level $L\leq${lexical\_level}.

{\tt Lp[$L$]}\label{LP} is the index of the first variable of level $L$ in the
variable stack, or more specifically, for any variable of index $i$,
$i<${\tt lp[$L$]} if and only if the variable has level $<L$.

{\tt Fp[$L$]}\label{FP} is the index of the frame pointer in the variable
stack of the function of level $L$ currently being compiled.  More
specifically, {\tt fp[$L$] = lp[$L$]} + the minimum number of arguments
expected by this function.

Recall that level $0$ is the module code outside all functions,
so {\tt lp[0] = fp[0] = 0}.

{\tt Stack\_limit} is set so that for a variable of index
{\tt $i$ < stack\_limit}\label{STACK-LIMIT}:
\begin{enumerate}
\item The variable cannot be popped from the stack by instructions
that do \underline{not} decrease either {\tt lexical\_level} or
{\tt depth[lexical\_level]}.
\item A new variable of the same name (i.e., a '{\tt next}' variable)
cannot be pushed into the stack.
\end{enumerate}

These rules must be enforced by the compiler -- they are not enforced
by {\tt mexstack}.

An intuitive way of putting this is that the working part of the
stack consists of variables of index {\tt $i$ $\geq$ stack\_limit}.

More specifically, {\tt stack\_limit} is set by {\tt BEG\ldots}
instructions (via the {\tt mexstack::begx} function below) as follows: \\
\hspace*{3em}\begin{tabular}{@{}ll}
\tt BEG & \tt var\_stack\_length \\
\tt BEGL & \tt var\_stack\_length + {\rm instruction} immedB \\
         & ({\tt immedB} is number of loop next variables) \\
\tt BEGF & \tt var\_stack\_length + {\rm instruction} immedA \\
         & ({\tt immedA} is minimum number of expected arguments) \\
\end{tabular} \\
Here {\tt var\_stack\_length} is the value just before the {\tt BEG\ldots}
instruction is compiled.
The {\tt END\ldots} instructions (via the {\tt mexstack::endx} function below)
restore {\tt stack\_\EOL limit} to its previous value, the value
just before the corresponding {\tt BEG\ldots} was compiled.

The {\tt mexstack::init} function (see below) zeros {\tt lexical\_level},
{\tt depth[0]}, {\tt lp[0]}, {\tt fp[0]}, and {\tt stack\_limit}.
\end{indpar}

\subsubsection{MEX Stack Component Utility Functions}
\label{MEX-STACK-COMPONENT-UTILITY-FUNCTIONS}

\verb|enum mexstack::| \MEXCOMKEY{print} \\
\verb|{| \\
\verb|    mexstack::| \MEXCOMKEY{NO\_PRINT}, \\
\verb|    mexstack::| \MEXCOMKEY{PRINT}, \\
\verb|    mexstack::| \MEXCOMKEY{PRINT\_WITH\_SOURCE} \\
\verb|}| \\
\verb|mexstack::print mexstack::| \MEXCOMKEY{print\_switch}
    \verb|= mexstack::NO_PRINT| \\
\verb|void mexstack::| \MEXCOMKEY{print\_instr}\label{PRINT-INSTR} \\
\verb|        ( min::uns32 location,| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
Print the {\tt mexcom::output\_module[location]} instruction,
as per {\tt mexstack::\EOL print\_\EOL switch},
except do not print source lines if
{\tt no\_source} is {\tt true}.
Printing is done using {\tt mexcom::\EOL input\_\EOL file} and
{\tt mexcom::\EOL input\_\EOL file->\EOL printer}.

The instruction printout has the syntax:
\begin{indpar}
\emkey{instruction-printout} ::= \\
\hspace*{2em} {\em printout-header}
    \begin{tabular}[t]{l}
    {\em op-code} \TT{T\_}{\em trace-class}
               \{ \TT{[} {\em trace-depth} \TT{]} \}\QMARK{} \\
    {\em immedA} {\em immedB} {\em immedC} {\em immedD}
	       \{ \TT{;} {\em trace-info} \}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{printout-header}\label{PRINTOUT-HEADER} ::=
    \TT{[}{\em line-number}\TT{:}{\em code-vector-location}%
                        \TT{,}{\em var-stack-length} \TT{]}
\end{indpar}
The source code is defined by {\tt mexcom::ouput\_module->position[location]}.
The {\em line-number} is the number of the \underline{last} source code
line (the first file line is
number \TT{1}).  The first {\em code-vector-location} is \TT{0}.
{\em Var-stack-length} equals {\tt var\_stack\_length}\pagnote{VAR-STACK-LENGTH}
plus {\tt stack\_offset} and is the compiler variable stack length
\underline{after} the instruction is ouput.  In particular,
for {\tt PUSH\ldots} instructions
that push {\em trace-variables}\pagnote{TRACE-VARIABLE}
{\tt stack\_offset} is set to
the number of {\em trace-variables} pushed so far, as
these instructions do not update {\tt var\_stack\_length}.
{\em Trace-depth} is printed only if it is not zero,
{\em immedD} is printed only if it is not \TT{min::MISSING()},
and {\em trace-info} is printed only if it is not \TT{min::MISSING()}.

In some cases assembling an instruction or declaration
(e.g., \TT{MEXAS LABEL}\pagnote{LABEL})
modifies a previously assembled instruction.  In these cases the
convention is to print the
modified previously assembled instruction (without its source)
just before the instruction currently being assembled.
\end{indpar}

\verb|bool mexstack::| \MEXCOMKEY{trace\_never} \verb|= false| \\
\verb|inline void mexstack::| \MEXCOMKEY{push\_instr} \\
\verb|        ( mex::instr & instr,| \\
\verb|          const min::phrase_position & pp =| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          min::gen trace_info = min::MISSING(),| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
If {\tt instr.trace\_class} is {\tt 0} set it to \\
\hspace*{3em}{\tt mex::op\_\EOL infos[instr.op\_\EOL code].trace\_\EOL class}.
\\
Then if {\tt mexstack::\EOL trace\_\EOL never} is {\tt true} and
additionally {\tt instr.trace\_class != mex::\EOL T\_ALWAYS}, set
{\tt instr.trace\_class} to {\tt mex::T\_NEVER}.

Then push the given parts of an instruction into the corresponding
{\tt mexcom::\EOL output\_\EOL module} stacks.

Lastly call {\tt mexstack::print\_instr} with the instruction
location and the {\tt no\_source} and {\tt stack\_offset}
arguments.  For this to work, {\tt mex::var\_stack\_length}
must be set \underline{before} {\tt push\_instr} is called
so that it plus {\tt stack\_offset} (usually {\tt 0})
is the variable stack length
\underline{after} the instruction is ouput.
\end{indpar}

\verb|void mexstack:| \MEXSTACKKEY{push\_push\_instr}
                      \label{PUSH-PUSH-INSTR} \\
\verb|    ( min::gen new_name, min::gen old_name,| \\
\verb|      min::ins32 index,| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION,| \\
\verb|      bool no_source = false,| \\
\verb|      min::int32 stack_offset = 0 )|
\begin{indpar}
This function creates a {\tt PUSH\ldots} instruction that pushes
into the process stack\pagnote{PROCESS-STACK}
the value of the variable referenced by the variable stack entry
with the given {\tt index}, and executes {\tt mexstack::push\_instr}
to push that instruction into the {\tt mexcom::\EOL output\_\EOL module}
code vector.  The {\tt pp}, {\tt no\_source},
and {\tt stack\_offset} parameters
are passed to {\tt mexstack::\EOL push\_\EOL instr}.

More specifically, the created instruction is always given
trace class {\tt mex::T\_PUSH}, phrase position {\tt pp},
trace info equal to a label whose components are {\tt old\_name}
and {\tt new\_name} in that order, and the following:

If {\tt lp[L] <= index}: \\
\hspace*{3em}\verb|op_code = mex::PUSHS, immedA = SP + stack_offset - index - 1|

If for {\tt K<L},~~~{\tt fp[$K$] <= index < lp[$K$+1]}: \\
\hspace*{3em}\verb|op_code = mex::PUSHL, immedA = index - fp[K], immedB = K|

If for {\tt K<L},~~~{\tt lp[$K$] <= index < fp[$K$]}: \\
\hspace*{3em}\verb|op_code = mex::PUSHA, immedA = fp[K] - index, immedB = K|

where \\
\hspace*{3em}\verb|L = mexstack::lexical_level| \\
\hspace*{3em}\verb|SP = mexstack::var_stack_length| \\
\hspace*{3em}({\tt stack\_offset} corrects {\tt SP} when pushing trace values
							      because \\
\hspace*{3em}~trace values are not recorded in the compiler variable stack)
\end{indpar}

The following function initializes the {\tt mexstack} data described above:

\verb|void mexstack:| \MEXSTACKKEY{init} \verb|( void )|
\begin{indpar}
This function initializes {\tt mexstack} data at the beginning
of the compilation of a module.  Specifically this function zeros:
\begin{indpar}\begin{verbatim}
mexstack::var_stack_length
mexstack::func_stack_length
mexstack::func_var_stack_length
mexstack::lexical_level
mexstack::depth[0]
mexstack::lp[0]
mexstack::fp[0]
mexstack::stack_limit
\end{verbatim}\end{indpar}

It also empties and re-initializes
the block and jump stacks described in subsequent sections.
However it does \underline{not} change any {\tt mexcom} data,
such as the error and warning counts.
\end{indpar}

\subsubsection{MEX Stack Component Block Management}
\label{MEX-STACK-COMPONENT-BLOCK-MANAGEMENT}

{\tt BEG\ldots}, {\tt END\ldots}, or {\tt CONT} instructions make
adjustments to the process value stack and process return stack,
and the sizes of these adjustments must be encoded in the instructions.
This encoding is done by {\tt mexstack} functions described below.
To output a {\tt BEG\ldots}, {\tt END\ldots}, or {\tt CONT} instruction,
the compiler must call one of these functions.

\verb|void mexstack:| \MEXSTACKKEY{begx} \label{BEGX} \\
\verb|    ( mex::instr & instr,| \\
\verb|      min::uns32 nvars, min::uns32 tvars,| \\
\verb|      min::gen trace_info = min::MISSING(),| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION )|
\\[0.5ex]
\verb|void mexstack:| \MEXSTACKKEY{endx} \label{ENDX} \\
\verb|    ( mex::instr & instr,| \\
\verb|      min::uns32 tvars,| \\
\verb|      min::gen trace_info = min::MISSING(),| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION )|
\\[0.5ex]
\verb|bool mexstack:| \MEXSTACKKEY{cont} \label{CONT} \\
\verb|    ( mex::instr & instr,| \\
\verb|      min::uns32 loop_depth,| \\
\verb|      min::uns32 tvars,| \\
\verb|      min::gen trace_info = min::MISSING(),| \\
\verb|      const min::phrase_position & pp =| \\
\verb|          min::MISSING_PHRASE_POSITION )|
\begin{indpar}
To output a {\tt BEG\ldots}, {\tt END\ldots}, or {\tt CONT} instruction
the compiler must first create the {\tt mex:instr} instruction and set
its {\tt op\_code} and {\tt trace\_class} (which can be set to {\tt 0}
so it will then be set by {\tt mexstack::push\_instr}).  The compiler must then
compute the instruction's position {\tt pp} and {\tt trace\_info}.
If the {\tt trace\_info} has
trace variables\pagnote{TRACE-VARIABLE}, the
compiler must output push instructions using
{\tt mexstack::\EOL push\_\EOL push\_\EOL instr}
to push the corresponding trace values into the process stack.
Note that these trace values are \underline{not} recorded in the
compiler variable stack.  The number of these trace values becomes
the {\tt tvars} parameter of the above functions.

Also, in the case of the {\tt BEGL} instruction, the compiler must
push the `{\tt next}' variables into the variables stack.
This is done before calling {\tt begx} because these variables should
be given the value of {\tt mexstack::depth[.]} \underline{before} it is
incremented by {\tt begx}.

Then the compiler must call {\tt begx} for an {\tt BEG\ldots} instruction,
{\tt endx} for an {\tt END\ldots} instruction, and {\tt cont} for
a {\tt CONT} instruction.  For {\tt BEGF} {\tt nvars} is the minimum number
of arguments expected (will become value of instruction {\tt immedA}).
For {\tt BEGL} {\tt nvars} is the number of loop `{\tt next}' variables
(will become value of instruction {\tt immedB}).  For {\tt BEG} {\tt nvars}
is ignored.

After calling {\tt begx} for an {\tt BEGF} instruction, the compiler
must push variables into the variable stack for the minimum number of
expected argments (equals {\tt nargs} parameter to the {\tt begx} function).
This is done after calling {\tt begx} because these variables should
be given the value of {\tt mexstack::lexical\_level} \underline{after} it is
incremented by {\tt begx}.

All these functions fill in parts of {\tt instr} and end by calling
{\tt mexstack::push\_instr}.  To do this, {\tt begx} pushes into the
block stack a block description containing:
\begin{enumerate}
\item The {\tt BEG\ldots}~{\tt op\_code}
\item The corresponding {\tt END\ldots}~{\tt op\_code} for checking purposes.
\item Saved values of the {\tt stack\_limit}, {\tt func\_stack\_length},
and {\tt func\_var\_stack\_\EOL length}
\item The {\tt nvars} argument
\item The location of the {\tt BEG\ldots} instruction
\end{enumerate}
This block description is popped from the block stack by the {\tt endx}
function, which uses information in the description to fill in parts of the
{\tt BEG\ldots}~and {\tt END\ldots}~instructions and to restore the compiler's
values of {\tt stack\_limit}, {\tt var\_stack\_length} (which equals
{\tt stack\_limit} - {\tt nvars} for {\tt ENDF} and {\tt ENDL}
and {\tt stack\_limit} for {\tt END}), {\tt func\_stack\_length},
and {\tt func\_var\_stack\_length} (by calling the
{\tt mexstack::pop\_\EOL stacks}
function provided by the compiler).

The {\tt cont} function searches back through block descriptions to find
the {\tt loop\_depth}'th {\tt BEGL} description and uses it
to fill in parts of the {\tt CONT} instruction.  The {\tt cont} instruction
also increments {\tt instr.trace\_depth} (assumed initially {\tt 0})
once for very block description
it skips over in this search.  This function returns {\tt true} on success,
but if it cannot find {\tt loop\_depth} {\tt BEGL} descriptions, it does
nothing but return {\tt false}.

{\tt Begx} and {\tt endx} also adjust the current lexical level and
depth as required by the {\tt BEG\ldots}~and {\tt END\ldots}~instructions
(e.g., {\tt BEGL} increments the depth and {\tt ENDL} decrements it).
\end{indpar}


\subsubsection{MEX Stack Component JMP Management}
\label{MEX-STACK-COMPONENT-JMP-MANAGEMENT}

A {\em jmp-target} is a MIN name (number, identifier string, or
label whose components are MIN names) that identifies
a code vector index value which can be used by \TT{JMP\ldots}
instructions as the point in the code vector to jump to.

\TT{JMP\ldots} instructions are pushed into the code vector
using the {\tt mexstack::jmpx} function, and their targets are
declared by the {\tt mexstack::jmp\_target} function.
\TT{JMP\ldots} instructions are forward-referencing: their
{\em jmp-targets} are declared after the \TT{JMP\ldots} instruction
(only {\tt ENDL} instructions can jump backwards).
To manage \TT{JMP\ldots} instructions and their targets,
{\tt mexstack::jumpx} pushes an element into a list of \skey{pending jumps}:
that is, jumps whose {\em jmp-target} has not yet been
declared.  When {\tt mexstack::jmp\_target} is called,
the pending jump list is searched for jumps with the given
{\em jmp-target},
and those that are found are resolved and removed from
the list.  Resolving involves calculating the distance
between the \TT{JMP\ldots} and its target, and the number of
process stack elements the \TT{JMP\ldots} should pop.
\TT{JMP\ldots} instructions
are allowed to pop stack elements, but cannot push them.

To permit this, an element of the pending jump list contains:
\begin{enumerate}
\item The location of the jump instruction so it can be updated
when its target is found.
\item The {\em jmp-target} MIN name.
\item The lexical level $L$ of the {\tt JMP\ldots} instruction.
\item The depth $D$ of the {\tt JMP\ldots} instruction.
\item The minimum $MD$ of $D$ and
      the depths immediately after any {\tt END} or {\tt ENDL} instructions
      encountered since the {\tt JMP\ldots} instruction was encountered.
      $MD\le D$.
\item The length $S$ of the variable stack (i.e., the value of
      {\tt var\_stack\_length}) just after the {\tt JMP\ldots}
      instruction pops its operands from the stack.
\item The minimum $MS$ of $S$ and all the variable stack lengths immediately
      after any {\tt END} or {\tt ENDL} instructions encountered
      since the {\tt JMP\ldots} instruction was encountered.
      $MS\le S$.
\end{enumerate}

A call to {\tt jmp\_target} is legal if each of its
corresponding {\tt JMP\ldots} instructions (there can be more than one)
is such that:
\begin{enumerate}
\item
There is no {\tt ENDF} instruction between the
{\tt JMP\ldots}~and the {\tt jmp\_target}.
Equivalently, the smallest function containing the {\tt jmp\_target}
is the same as the smallest function containing the {\tt JMP\ldots}
(or both are outside any function).
\item The depth when {\tt jmp\_target} is called is \underline{equals} $MD$.
Equivalently, the smallest block containing the {\tt jmp\_target}
also contains the {\tt JMP\ldots}~instruction (which may be in an even
smaller block).
\item The value of {\tt var\_stack\_length} when {\tt jmp\_target}
is called \underline{equals} $MS$.
\end{enumerate}

A \TT{JMP\ldots} instruction for which a legal target exists
is called \key{resolvable}.  Other \TT{JMP\ldots} instructions
are \key{unresolvable} and are in error.

The following MEXAS assembler programs illustrate this
rule when the jump does \underline{not}
reduce depth and $M$ = the variables stack length just after the
\TT{JMP\ldots} is compiled (in MEXAS a {\tt LABEL} statement
just calls {\tt jmp\_target}):

Example 1:
\begin{indpar}\begin{verbatim}
// Program to calculate minimum ( X, Y ) in stack.
//
// Stack length is S
PUSH X
PUSH Y
// Stack length is S + 2
JMPLT ITS-X    // MS = S
// Stack length is S
PUSH Y
// Stack length is S + 1
JMP DONE       // MS = S + 1
// Stack length is S + 1
LABEL ITS-X    // JMPLT ITS-X *illegal*, MS == S != S + 1
PUSH X
// Stack length is S + 2
LABEL DONE     // JMP DONE *illegal*, MS == S + 1 != S + 2
// Stack length is S + 2
\end{verbatim}\end{indpar}

Example 2:
\begin{indpar}\begin{verbatim}
// Program to calculate minimum ( X, Y ) in stack.
//
// Stack length is S
PUSH 0 Z
// Stack length is S + 1
BEG
    // Stack length is S + 1
    PUSH X
    PUSH Y
    // Stack length is S + 3
    JMPLT ITS-X    // MS = S + 1
    // Stack length is S + 1
    PUSH Y
    // Stack length is S + 2
    POP Z
    // Stack length is S + 1
    JMP DONE       // MS = S + 1
    // Stack length is S + 1
    LABEL ITS-X    // JMPLT ITS-X legal, MS == S + 1 == S + 1
    PUSH X
    // Stack length is S + 2
    POP Z
    // Stack length is S + 1
    LABEL DONE    // JMP DONE legal, MS == S + 1 == S + 1
END
// Stack length is S + 1
\end{verbatim}\end{indpar}

The following are the {\tt mexstack} {\tt JMP}
management functions:

\verb|void mexstack:| \MEXSTACKKEY{push\_jmp\_instr}
		      \label{PUSH-JMP-INSTR} \\
\verb|        ( mex::instr & instr,| \\
\verb|          min::gen target,| \\
\verb|          const min::phrase_position & pp =| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
{\tt Instr.op\_code} must be set to {\tt JMP\ldots}
and {\tt instr.trace\_class} may be set or may be {\tt 0}.
This function executes {\tt mexstack::push\_instr}
to push that instruction into the {\tt mexcom::\EOL output\_\EOL module}
code vector.  The {\tt pp}, {\tt no\_source}, and {\tt stack\_offset}
parameters are passed to {\tt mexstack::\EOL push\_\EOL instr}.
The instruction {\tt trace\_info} is set equal to the {\tt target}.

If the {\tt JMP\ldots} instruction takes operands from the process stack,
these should be popped from the compiler variables stack before this
function is called,  and {\tt stack\_\EOL offset} should be allowed
to default to {\tt 0}.

Lastly this function creates an element of the pending jump list
for the newly output {\tt JMP\ldots} instruction.
\end{indpar}

\verb|min::uns32 mexstack:| \MEXSTACKKEY{jmp\_target}
    \verb|( min::gen target )|
\begin{indpar}
Resolve all pending jumps that have the current lexical level, a minimum
depth $MD$ equal to the current depth, and the
given {\tt target}.
Resolved jumps transfer to the current location: \\
\hspace*{3em}\verb|mexcom::output_module->length|

The {\em trace\_depth} of a resolved {\tt JMP\ldots}~is set to the the depth 
of the {\tt JMP\ldots}~minus the current depth.

Resolved jumps are removed from the list
of pending jumps.  The number of resolved jumps is returned.
\end{indpar}

\verb|void mexstack::| \MEXCOMKEY{print\_label}\label{PRINT-LABEL} \\
\verb|        ( min::gen name,| \\
\verb|          const min::phrase_position & phrase_position| \\
\verb|              min::MISSING_PHRASE_POSITION,| \\
\verb|          bool no_source = false,| \\
\verb|          min::int32 stack_offset = 0 )|
\begin{indpar}
Print a label with the given {\em name} just \underline{prior} to calling
{\tt mexstack::jmp\_target} with that {\em name}.
Print as per {\tt mexstack::\EOL print\_\EOL switch},
except do not print source lines if
{\tt no\_source} is {\tt true} or {\em phrase\_position} is missing.
Printing is done using {\tt mexcom::\EOL input\_\EOL file} and
{\tt mexcom::\EOL input\_\EOL file->\EOL printer}.

The label printout has the syntax:
\begin{indpar}
\emkey{label-printout} ::=
    {\em printout-header} \ttkey{LABEL} {\em name}
\end{indpar}
In {\em printout-header}\pagnote{PRINTOUT-HEADER}
the {\em code-vector-location} is
{\tt mexcom::ouput\_module->length} and
the {\em var-stack-length} equals the current value of
{\tt mexstack::var\_stack\_length}\pagnote{VAR-STACK-LENGTH}
plus {\tt stack\_offset} (usually {\tt 0}).
\end{indpar}

\verb|min::uns32 mexstack:| \MEXSTACKKEY{jmp\_clear} \verb|( void )|
\begin{indpar}
Delete all pending jumps with the current lexical level (making these
jumps unresolved and in error), and
call {\tt mexcom::compile\_error} to indicate which pending jumps
were deleted.  Return the number of deleted pending jumps.

This is called by {\tt mexstack::endx} for each {\tt ENDF} instruction.

It must also be called by the compiler at the end of compiling a
module.

Pending jumps are added at the end of the pending jump list, and
as this function is called whenever the lexical level decreases by one,
pending jumps are sorted by ascending lexical level in the pending jump list.
\end{indpar}

\verb|min::uns32 mexstack:| \MEXSTACKKEY{jmp\_update} \verb|( void )|
\begin{indpar}
For all pending jumps with the current lexical level $L$ decrease
their minimum depth $MD$ if necessary to {\tt mexstack::depth[$L$]}
and decrease their minimum stack $MS$ if necessary to 
{\tt mexstack::var\_stack\_length}.  Return the number of elements
of lexical level $L$, even those not modified.

This function is called by {\tt mexstack::endx} for {\tt END} and
{\tt ENDL} instructions just after {\tt mexstack::depth[$L$]}
and {\tt mexstack::var\_stack\_length} have been decremented
(restored to their values just before the corresponding {\tt BEG} or
{\tt BEGL} instructions were output).

This function need \underline{not} be called by the compiler, but
could be called to count the number of pending jumps with the
current lexical level (without modifying any pending jumps).
\end{indpar}


\section{MEXAS Language}
\label{MEXAS Language}

\key{MEXAS} is an assembly language for MEX.  The \ttkey{mexas}
assembler can be use as a MEX compiler.

MEXAS serves as a prototype for more advanced MEX compilers
and as a tool for debugging MEX and the {\tt mexcom} and
{\tt mexstack} compiler components.

\subsection{MEXAS Syntax}
\label{MEXAS-SYNTAX}

MEXAS programs are written in ASCII.
Non-ASCII bytes and
control characters other than whitespace
are illegal and are
replaced by `\#'.

A MEXAS program consists of statements which are instructions
or declarations, each encoded as a sequence of lexemes.

If a lexeme begins with `\ttkey{//}', it and the rest of the
line are a \key{comment} and are ignored (except for detecting
illegal characters).  A line containing only a comment is a
\key{comment line}.  Blank lines have no effect.

If the last lexeme on a line is `\ttkey{\textbackslash}',
the current statement
is \key{continued} on the next line (the `\TT{\textbackslash}' is
discarded).

A \key{statement} is a sequence of lines beginning with the first
line after the previous statement (or the first line of a file)
and ending with a non-blank, non-comment line that is
\underline{not} continued.  Statements are either instructions or
declarations.

Instructions begin with an op code lexeme, and the program syntax
of all the instructions taken together
is that of a code vector: see Code Vectors,
\itemref{CODE-VECTORS}.

Declarations define jump instruction targets or print assembly
information.

When `\ttkey{::=}' is used in a syntax equation, the
items of the equation are lexemes and \underline{not}
characters.
When `\ttkey{:::=}' is used, the
items of the equation are characters and \underline{not}
lexemes.

\subsection{Lexemes}

A MEXAS \key{lexeme} is a sequence of non-whitespace characters
surrounded by whitespace, or a single quote (\TT{'}) followed
by a sequence of non-single-quote characters followed by a
single quote, or a double quote (\TT{"}) followed by a 
sequence of non-double-quote characters followed by a
double quote.

A \key{number}\label{NUMBER} is a lexeme acceptable as an IEEE floating point
number to the POSIX \TT{strtod} function.

A \key{name}\label{NAME} is a lexeme beginning with a letter that is
\underline{not} a number (\TT{nan}, \TT{InF}, etc. are numbers
and not names) and is not longer than 32 characters.

A \key{string}\label{STRING} is a lexeme beginning with quote and ending
with the same kind of quote.

All lexemes must be on a single line: they cannot be continued to the
next line.  Strings not terminated by an end of line are automatically
terminated with an error message.

A comment beginning lexeme (\TT{//\ldots}) and a continuation
lexeme (\TT{\textbackslash}) must be lexemes surrounded by whitespace.

Illegal characters are replaced by \TT{\#} and become part of the
current lexeme or comment.  An error message accompanies such replacement.

\subsection{Interface with MEX Compiler Components}
\label{INTERFACE-WITH-MEX-COMPILER-COMPONENTS}

{\tt MEXAS} uses the concepts, data, and functions of the
{\tt mexcom} and {\tt mexstack} MEX compiler components

Specifically {\tt MEXAS} implements a variable stack and a function stack.
{\tt MEXAS} does not have function variables, but does permit functions
with no arguments to be referenced in {\tt CALL} statements.

A variable in the variable stack has an index as specified by the
{\tt mexstack} component.  A function in the function stack
has an index equal the location of its {\tt BEGF} instruction.
After a module is assembled,
it is executed, and then the variable and function stacks are
encoded in the module interface that maps variable and function names
to indices.


\subsection{MEXAS Instructions}
\label{MEXAS-INSTRUCTIONS}

In the following description of MEXAS instruction syntax and
assembly actions:

\begin{enumerate}
\item When an instruction pushes an
element into the variable or function stacks, the element is given
the lexical level and depth of the instruction.
\item A \emkey{variable-name} is a name of a variable stack element.
If two elements have the same {\em variable-name}, the element nearer
the top of the stack hides the element lower down.
\item A \emkey{function-name} is a name of a function stack element.
If two elements have the same {\em function-name}, the element nearer
the top of the stack hides the element lower down.
\item Stack searches always proceed from the topmost stack element
to the bottom-most, and accept the first element found with the desired name.
\item Modules are named by the name of the file assembled to produce
the module, with the suffix \TT{.mex} deleted.  Such a name is
a \emkey{module-name}.
\item Some instructions have an optional \emkey{new-variable-name} argument
that names an element being pushed to the variables stack.
The {\em new-variable-name}
must \underline{not} be the same as the name of any variable of
less lexical level or depth than the instruction, or the same name
as that of an argument of a function (specifically, must not have the same
name as a variable whose index is
{\tt < mexas::stack\_limit}\pagnote{STACK-LIMIT}).
Note that the
\TT{next-} variables\pagnote{NEXT-VARIABLE}
of a loop have depth one less than the instructions
in the loop.

If {\em new-variable-name} is missing or `\TT{*}',
the element just gets the name `\TT{*}' to indicate that the
element has no name.

\item A variable cannot be written if it has a lexical level less than
that of the writing instruction, or is a function argument variable,
or has depth equal to the writing instruction.
\item The operands that take integer values must have values in the
range $[0,2^{32})$ (so they will fit into \TT{immedA}, \TT{immedB},
or \TT{immedC} instruction
members).
\item Some instructions have a \emkey{level}\label{LEVEL} argument, which must
specify a lexical level in the range [1,$L$], where $L$ is the lexical
level of the instruction.  If the argument is missing or \TT{0},
the specified lexical level is $L$.
If the argument is a positive integer, it is the specified lexical level
(and must be in range).  If the argument is a negative integer -$i$,
the specified lexical level is $L-i$ (and must be in range).
\item Some instructions have an \emkey{attribute-label}\label{ATTRIBUTE-LABEL}
argument which may be a {\em string} or may have the form
\begin{indpar}
\TT{[} {\em string}\PLUS{} \TT{]}
\end{indpar}
This latter form specifies a MIN label whose elements are the {\em string}s.
\item Some instructions have a \emkey{trace-message} argument
and some have \emkey{trace-packet} arguments, where:
\begin{indpar}
\emkey{trace-message} ::= {\em string}
\\[0.5ex]
\emkey{trace-packet} ::= {\em trace-message} {\em trace-variable}\STAR{}
\\[0.5ex]
\emkey{trace-variable} ::= {\em variable-name}
\end{indpar}
These specify the {\em trace-info} for the instructions:
see Trace-Packet Based Trace Messages,
\itemref{TRACE-PACKET-BASED-TRACE-MESSAGES}.
\item To assemble a run-time instruction, MEXAS first adjusts the
variable stack to correspond its desired state \underline{after}
the instruction executes, and \underline{then} calls a {\tt mexstack} function
(such as {\tt push\_instr} or {\tt begx}) to push the instruction
into the module code vector.

One exception is the {\tt BEGF} instruction: the argument variables are
pushed into the variables stack \underline{after} calling {\tt begx}
(which calls {\tt push\_instr}).

The other exception involves trace variables.  These are handled by
calling {\tt push\_push\_\EOL instr} for each trace variable \underline{before}
assembling the run-time instruction.  Trace variables are \underline{not}
pushed into the assembler variable stack.
Each call to {\tt push\_push\_instr} has a {\tt stack\_offset} argument
equal to the number of trace variables pushed so far for the run-time
instruction, beginning with the number {\tt 1} for the first trace variable.
\item
In describing the MEXAS statements that output a run-time instruction,
we describe what the assembler does to the variable stack, pending
jump list, etc., but omit reference to outputting the instructions to the
module code vector (including instructions to push trace variable values).
Thus when we say that the assembler does nothing for {\tt NOP}, {\tt TRACE},
{\tt WARN}, and {\tt ERROR},
we mean nothing but outputting instructions to the module code vector.
\end{enumerate}


Given the above notes, the instruction descriptions are:

{\em aop} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em aop} is any non-immediate
arithmetic operation code (e.g. {\tt ADD} but not {\tt ADDI}) from
Figure~\itemref{ARITHMETIC-INSTRUCTIONS}.
The run-time
action of the instruction is specified in that figure.

At assembly-time the same number of elements are popped from the variable stack
as are popped from the process stack during run-time.
Then one element is pushed to the variable stack with
{\em new-variable-name} as its name.
\end{indpar}

{\em aop}\TT{I} ~ {\em number} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em aop}\TT{I} is any immediate arithmetic operation code from
Figure~\itemref{ARITHMETIC-INSTRUCTIONS} (e.g., {\tt ADDI})
with \TT{immedD} is set to {\tt number}.
The run-time
action of the instruction is specified in
Figure~\ref{ARITHMETIC-INSTRUCTIONS}.

At assembly-time one element is popped from the variable stack and then
one element is pushed to the variable stack with
{\em new-variable-name} as its name.
\end{indpar}

\ttkey{PUSHM} ~ {\em variable-name} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
lexical level 0 variable.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em variable-name} is restricted to
elements with the lexical level \TT{0}.
\end{indpar}

\ttkey{PUSHG} ~ {\em module-name} ~ {\em variable-name} ~
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
global variable in the named module.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack searched for {\em variable-name} is the variable
stack of the previously assembled module named, as it is at the
end of the assembly of that module (only level 0, depth 0 variables
of the module are present in this stack).
\end{indpar}

\ttkey{PUSH} ~ {\em variable-name} ~
             {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the variable
named in the variable stack or previously assembled module variable stack.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The search for {\em variable-name} begins with the entire variable
stack and proceeds through the variable stacks of previously assembled modules
in most recently assembled first order.
\TT{PUSH} assembles
to the run-time instruction \TT{PUSHS}, \TT{PUSHL}, \TT{PUSHG},
or \TT{PUSHA}, depending on the location of the variable.

(If the variable name is in the variable stack,
{\tt mexstack::push\_\EOL push\_instr}\pagnote{PUSH-PUSH-INSTR}
is called.  Otherwise {\tt PUSHG} is used.)
\end{indpar}

\ttkey{PUSHI} ~ {\em number} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ {\em string} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{TRUE} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{FALSE} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{NONE} ~ {\em new-variable-name}\QMARK{} \\
\ttkey{PUSHI} ~ \TT{OBJ} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of
the {\em number}\pagnote{NUMBER}, or the {\em string}\pagnote{STRING},
or \TT{mex::TRUE}, or \TT{mex::FALSE}, or \TT{min::NONE()},
or an empty MIN object.
At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{POP} ~ {\em variable-name}\QMARK{}
\begin{indpar}
At run-time, pops the process stack and stores the value popped
into the variable named in the variable stack.  Or if the
variable name is not given or is `\TT{*}', discards the value popped.

At assembly time, pops the variable stack.

The variable stack search for {\em variable-name} is restricted to
elements with the same lexical level as the \TT{POP} instruction
that are not arguments to that lexical level and that are of
lesser depth than the \TT{POP} instruction.

\ttkey{POP} assembles to the run-time instruction \TT{POPS}.
Note that \TT{POPL}, \TT{POPG}, and \TT{POPA} do
\underline{not} exist as you cannot write
variables that are arguments, or at a different lexical level,
or in a different module.
\end{indpar}

\ttkey{JMP} ~ {\em jmp-target}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}.  At assembly-time,
this instruction 
calls {\tt mexstack::push\_\EOL jmp\_instr}\pagnote{PUSH-JMP-INSTR}
to add an element to the pending jump list.
\end{indpar}

\ttkey{JMPEQ}/\ttkey{JMPNEQ}/\ttkey{JMPLT}/\ttkey{JMPLEQ}/%
     \ttkey{JMPGT}/\ttkey{JMPGEQ} ~ \TT{*}\QMARK{} {\em jmp-target}
\begin{indpar}
At run-time these instruction's actions are as described in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}, where the \TT{*}
option sets \TT{immedB} = 1 (otherwise it is 0).  At assembly-time,
these instructions first pop two elements from the variable stack,
then
call {\tt mexstack::\EOL push\_\EOL jmp\_instr}\pagnote{PUSH-JMP-INSTR}
to add an element to the pending jump list, then if \TT{*} is present
push the first element popped back onto the variable stack.

Note that
the pending jump list element
$S$ value is the length of the variable stack \underline{after}
the two elements are popped (and before any element is pushed back).
\end{indpar}

\ttkey{JMPTRUE}/\ttkey{JMPFALSE}/\ttkey{JMPNONE}/\ttkey{JMPINT}/%
    \ttkey{JMPFIN}/\ttkey{JMPINF}/\ttkey{JMPNUM}/\ttkey{JMPTRUTH}/%
    \ttkey{JMPSTR}/\ttkey{JMPOBJ} \\
\hspace*{1in}\ttkey{*}\QMARK{} {\em jmp-target}
\begin{indpar}
At run-time these instructions' actions are as described in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}, where the \TT{*}
option sets \TT{immedB} = 1 (otherwise it is 0).  At assembly-time,
these instructions first pop one element from the variable stack and
then call {\tt mexstack::\EOL push\_\EOL jmp\_instr}\pagnote{PUSH-JMP-INSTR}
to add an element to the pending jump list.

Note that
the pending jump list element
$S$ value is the length of the variable stack \underline{after}
the one element is popped.
\end{indpar}

\ttkey{JMPCNT} ~ {\em variable-name} ~ {\em number}\QMARK{} ~ {\em jmp-target}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{STACK-AND-FLOW-CONTROL-INSTRUCTIONS}, where {\em variable-name}
names the stack location affected and {\em number} (defaults to
{\tt 1}) is the value of {\tt immedD}.
At assembly-time,
these instructions
call {\tt mexstack::\EOL push\_\EOL jmp\_instr}\pagnote{PUSH-JMP-INSTR}
to add an element to the pending jump list.
\end{indpar}

\ttkey{BEG} ~ {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
calls {\tt mexstack::begx}\pagnote{BEGX} to
increment the depth and set the {\tt stack\_limit}\pagnote{STACK-LIMIT}.
\end{indpar}

\ttkey{END} ~ {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.
At assembly-time,
calls {\tt mexstack::endx}\pagnote{ENDX} to
pop from the variable and function stacks all elements with the
same lexical level and depth as the \TT{END} instruction, reset
{\tt stack\_limit} to its value when the companion {\tt BEG} was encountered,
decrement the depth, and update the pending jmp list.
\end{indpar}

\ttkey{BEGL} ~ {\em nnext} ~ {\em trace-message}\QMARK{}
\begin{indpar}
Here {\em nnext} is the number of next variables
(see Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}).
At run-time this instruction's action is as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS} with \TT{immedB} equal
to {\em nnext}.

At assembly-time, this instruction first checks that the
top {\em nnext} variable stack elements have the current lexical level
and depth,
then pushes {\em nnext} variable stack elements with current lexical
level and depth
and with names derived from their {\em nnext}'th predecessor
in the stack by adding the prefix `\TT{next-}'\label{NEXT-VARIABLE}
to the predecessor's
name.

Then this instruction calls
{\tt mexstack::begx}\pagnote{BEGX} to increment
the current instruction depth and set the
{\tt stack\_limit}\pagnote{STACK-LIMIT}.

Thus for example, if the top two stack elements have names
\TT{X} and \TT{Y} and {\em nnext} is \TT{2}, the two elements
pushed would have names \TT{next-X} and \TT{next-Y}, and
all 4 stack elements would have depth one less than the depth
of instructions inside the \TT{BEGL/ENDL} block.
\end{indpar}

\ttkey{ENDL}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
\TT{ENDL} does the same thing as \TT{END}.
\end{indpar}

\ttkey{CONT} ~ {\em loop\_depth}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction does nothing (i.e., it calls {\tt mexstack::cont}\pagnote{CONT}
which does nothing but fill in instruction fields and push the instruction
into the module code vector).

The {\tt mexstack::cont} function
searches the block stack for the {\tt loop\_depth}'th {\tt BEGL ...~ENDL}
loop block and uses that to create an appropriate instruction.
{\tt Loop\_depth} defaults to {\tt 1}, which continues the innermost
loop (exiting any non-loop blocks inside the innermost loop).
A value of {\tt 2} would exit the innermost loop and continue
the next to innermost loop, etc.
\end{indpar}

\ttkey{BEGF}\label{BEGF} ~ {\em function-name} ~ {\em variable-name}\STAR{} ~
	{\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction first pushes into the function stack
an element with the {\em function-name} and location of the {\tt BEGF}
instruction.

This instruction then computes its {\tt trace-info}
consisting of the {\em trace-message} followed by the list of
{\em variable-names} (which are the function argument names).
This {\tt trace-info} is used at run-time by the
{\tt CALL\ldots} instruction to trace the arguments
to the function\pagnote{CALL-TO-BEGF}.

Next this instruction calls {\tt mexstack::begx}\pagnote{BEGX}
to increment the current lexical level to $L$, set the current depth to zero,
and set {\tt stack\_limit}\pagnote{STACK-LIMIT},
{\tt lp[$L$]}\pagnote{LP}, and {\tt fp[$L$]}\pagnote{FP}.

Lastly this instruction pushes one element with each
of the {\em variable-names} into the variable stack (they
represent the arguments to the function).
The number of {\em variable-names} can be less than,
but may \underline{not} be greater than, the number of actual
arguments.
\end{indpar}

\ttkey{ENDF} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.
At assembly-time,
calls {\tt mexstack::endx}\pagnote{ENDX} to
pop from the variable and function stacks all elements with the
same lexical level as the \TT{ENDF} instruction,
restore 
{\tt stack\_limit} and
the current lexical level and depth to what they were before
the associated \TT{BEGF} instruction, and clear the pending jmp list.
\end{indpar}

\ttkey{CALLM} ~ {\em function-name} ~ {\em nargs} ~
        {\em variable-name}\STAR{} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS} with {\tt immedA} equal to
{\tt nargs} (the number of arguments).  At assembly-time,
it pops from the variable variable stack {\em nargs} variables
and pushes into the stack one element for each {\em variable-name}
(representing the results of the function execution).
The number of {\em variable-names} \underline{must} equal
the number of actual results.

The {\tt trace-info} for this instruction
consists of the {\em trace-message} followed by the list of
{\em variable-names} (which are the function result names).
This {\tt trace-info} is used at run-time by the
{\tt RET} or {\tt ENDF} instruction to trace the results
of the function\pagnote{RET-TO-CALL}.

The {\em function-name} is searched for in the function stack.
\end{indpar}

\ttkey{CALLG} ~ {\em module-name} ~ {\em function-name} ~
              {\em nargs} ~ {\em variable-name}\STAR{} ~
	      {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
the actions are the same as for \TT{CALLM}.

The {\em function-name} is searched for in the function stack of
the previously assembled module named, as it is at the
end of the compilation of that module (only level 1 functions
of the module are present in this stack).
\end{indpar}

\ttkey{CALL} ~ {\em function-name} ~
             {\em nargs} ~ {\em variable-name}\STAR{} ~
	      {\em trace-message}\QMARK{}
\begin{indpar}
This instruction searches for the {\em function-name} first in the function
stack and then in the function stacks of the previously assembled
modules, in most recently assembled first order.  It then
assembles to \TT{CALLM} or \TT{CALLG}.
\end{indpar}

\ttkey{RET} ~ {\em nresults} ~ {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{BLOCK-AND-FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction pops {\em nresults} elements from the
variables stack.
\end{indpar}

\ttkey{VPUSH} ~ {\em object-variable-name} {\em string}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer, and
{\em string} specifies the MIN string that is the \TT{immedD} value
(default, \TT{min::NONE()}).

At assembly time, pops the variable stack.

The variable stack search for {\em object-variable-name} is restricted to
elements with the same lexical level as the \TT{VPUSH} instruction.
\end{indpar}

\ttkey{VPOP} ~ {\em object-variable-name} {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer.

At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em object-variable-name} is restricted to
elements with the same lexical level as the \TT{VPOP} instruction.
\end{indpar}

\ttkey{GET} ~ {\em object-variable-name} {\em attribute-label-variable-name}
	      {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label-variable-name} specifies the variable containing the
attribute label value \EOL (\TT{immedC} value).
If {\em attribute-label-variable-name}
is \TT{*}, the attribute name is popped from the stack
(\TT{immedB} != 0, \TT{immedC} == 0).

At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack searches for {\em object-variable-name} 
and {\em attribute-label-variable-name} are restricted to
elements with the same lexical level as the \TT{GET} instruction.
\end{indpar}

\ttkey{GETI} ~ {\em object-variable-name} {\em attribute-label}
	       {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label}\pagnote{ATTRIBUTE-LABEL}
names the attribute (\TT{immedD} value).

At assembly time, pushes into the variable stack an
element with {\em new-variable-name} as its name.

The variable stack search for {\em object-variable-name} 
is restricted to
elements with the same lexical level as the \TT{GETI} instruction.
\end{indpar}

\ttkey{SET} ~ {\em object-variable-name} {\em attribute-label-variable-name}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label-variable-name} specifies the variable containing the
attribute label value \EOL (\TT{immedC} value).
If {\em attribute-label-variable-name} is \TT{*},
the attribute label is popped from the stack
(\TT{immedB} != 0, \TT{immedC} == 1).

At assembly time, pops the variable stack twice if
{\tt attribute-label-variable-name} is \TT{*}, or once otherwise.

The variable stack searches for {\em object-variable-name} 
and {\em attribute-label-variable-name} are restricted to
elements with the same lexical level as the \TT{SET} instruction.
\end{indpar}

\ttkey{SETI} ~ {\em object-variable-name} {\em attribute-label}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{OBJECT-INSTRUCTIONS}, where {\em object-variable-name}
specifies the variable containing the object pointer (\TT{immedA} value), and
{\em attribute-label} names the attribute being written
(\TT{immedD} value).

At assembly time, pops the variable stack once.

The variable stack search for {\em object-variable-name} 
is restricted to
elements with the same lexical level as the \TT{SETI} instruction.
\end{indpar}

\ttkey{PUSHNARGS} ~ {\em level}\QMARK{} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS} with \TT{immedB} set
to the lexical level specified by {\em level} (see \pagref{LEVEL}).
At assembly-time,
this instruction pushes into the variable stack an element
with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{PUSHV} ~ {\em level}\QMARK{} ~ {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS} with \TT{immedB} set
to the lexical level specified by {\em level} (see \pagref{LEVEL}).

At assembly-time, this instruction first pops an element from the
variable stack, and then pushes into the variable stack an element
with {\em new-variable-name} as its name.
\end{indpar}

\ttkey{SET\_TRACE} ~ \{ {\em trace-class} $|$ {\em trace-class-group} \}\STAR{}
\begin{indpar}
At run-time set the process \TT{trace\_flags} parameter so as
to have a flag for each {\em trace-class} given, or each trace class
in a given {\em trace-class-group}.  This instruction itself has
the \TT{ALWAYS} trace class.
See Instruction Tracing\pagnote{INSTRUCTION-TRACING} for details.

At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{NOP}/\ttkey{TRACE}/\ttkey{WARN}/\ttkey{ERROR} ~
    {\em trace-packet}\QMARK{}
\begin{indpar}
At run-time these instructions do nothing except produce trace messages
(if there is a {\em trace-packet}),
except that the \TT{ERROR}
instruction terminates the process
(see Figure~\itemref{STACK-AND-HOUSEKEEPING-INSTRUCTIONS}).  At assembly-time,
these instructions do nothing.

All these instructions except \TT{NOP} are in the \TT{ALWAYS}
trace class.
\end{indpar}

\ttkey{SET\_EXCEPTS} ~ {\em except-name}\STAR{}
\begin{indpar}
At run-time set the process \TT{excepts\_mask} parameter so as
to have a flag for each named except.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{SET\_OPTIMIZE} ~ \{ \TT{ON} $|$ \TT{OFF} \}
\begin{indpar}
At run-time set the process \TT{optimize} parameter on or off.
At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{TRACE\_EXCEPTS}
\begin{indpar}
At run-time, this instruction is just traced as specified
in Other Instruction Trace Messages,
\itemref{OTHER-INSTRUCTION-TRACE-MESSAGES}.
At assembly-time,
this instruction does nothing.
\end{indpar}

\subsection{MEXAS Declarations}
\label{MEXAS-DECLARATIONS}

\ttkey{LABEL}\label{LABEL} ~ {\em jmp-target}
\begin{indpar}
This statement just calls {\tt mexstack::jmp\_target} with the given
{\tt jmp-target} name.
\end{indpar}

\ttkey{STACKS}
\begin{indpar}
Prints the names in the assembly time variables and functions stacks.
Used mostly for testing the assembler.
\end{indpar}

\ttkey{TEST\_INSTRUCTION} ~
    \begin{tabular}[t]{@{}l@{}}
    {\em op-code} ~ {\em trace-class} ~ {\em trace-depth} ~
                 \TT{\textbackslash} \\
    {\em immedA} ~ {\em immedB} ~ {\em immedC} ~ {\em immedD} \\
    \end{tabular}
\begin{indpar}
Outputs an instruction with the given fields, and does nothing
else at assembly time.  Used for testing \TT{FORMAT\_ERROR},
since otherwise such errors are (seem to be, should be) impossible
because of assembler checks.

The {\em op-code} and {\em trace-class} are names.
{\em immedD} may be a number or module name.
The other fields are integers.

Fields may be omitted from the end of the instruction.
\end{indpar}


\subsection{The MEXAS Program}
\label{THE-MEXAS-PROGRAM}

The \key{MEXAS program} executes {\em mexas-operations} that
appear in its arguments.  The syntax is:

\begin{indpar}
\emkey{MEXAS-command} ::= \ttkey{mexas} ~ {\em mexas-operation}\STAR{}
\\[0.5ex]
\emkey{mexas-operation} ::= \\
\hspace*{3em}\begin{tabular}[t]{l@{~~~~~}l}
    \emkey{mexas-filename}		& [assemble the file] \\
    \ttkey{-pa} 			& [print assembled instructions] \\
    \ttkey{-pasource}			& [ditto and include source lines] \\
    \ttkey{-paoff}			& [do not print
                                           assembled instructions] \\
    \ttkey{-tcnever}			& [assemble with \TT{NEVER}
                                           trace class] \\
    \ttkey{-tcnormal}			& [assemble with normal trace class] \\
    \ttkey{-tc:}{\em tc-list}		& [set process {\tt trace\_flags}] \\
    \ttkey{-ex:}{\em ex-list}		& [set process {\tt excepts\_mask}] \\
    \ttkey{-o:on}			& [set process optimize on] \\
    \ttkey{-o:off}			& [set process optimize off] \\
    \ttkey{-counter} $L$		& [set process instruction
                                           {\tt counter\_limit}] \\
    \ttkey{-stack} $L$		        & [set process stack size] \\
    \ttkey{-return-stack} $L$	        & [set process return stack size] \\
    \ttkey{-r} {\em function-name}	& [run named function] \\
    \end{tabular}
\\[0.5ex]
\emkey{tc-list} :::= $|$ {\em trace-class-or-group}
                         \{ \TT{,} {\em trace-class-or-group} \}\STAR{} \\
\emkey{trace-class-or-group} :::= {\em trace-class} $|$ {\em trace-group} \\
\emkey{trace-class} :::= trace class
    listed in Figure~\itemref{TRACE-CLASSES-AND-GROUPS} \\
\emkey{trace-group} :::= trace group
    listed in Figure~\itemref{TRACE-CLASSES-AND-GROUPS} \\
\\[0.5ex]
\emkey{ex-list} :::= $|$ {\em exception} \{ \TT{,} {\em exception} \}\STAR{} \\
\emkey{exception} :::= except listed on Figure~\itemref{EXCEPTIONS}

\end{indpar}

Note that the symbol :::= is used to indicate that syntactic components
can\underline{not} be separated by whitespace, whereas ::= indicates
that components can and often should be separated by whitespace.

A {\em mexas-operation} is effective for all subsequent
{\em mexas-operations} until it is overridden.  E.g.,
\TT{-o:on} will cause following all executions to be optimized
until an \TT{-o:off} is encountered.

Details are:
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
{\em mexas-filename} & Name of file, usually ending in \TT{.mex}, containing
                      instructions as described in
                      MEXAS Instructions, \itemref{MEXAS-INSTRUCTIONS}.
		      The file is assembled as a module and given the
		      filename minus any \TT{.mex} extension as its
		      module name.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\begin{tabular}[t]{@{}l@{}}
\TT{-pa} \\
\TT{-pasource} \\
\TT{-paoff} \\
\end{tabular}	    & Determines whether an instruction is printed after
                      it is assembled, and if so, whether source lines
		      from the file are printed before the instruction.
		      Default is \TT{-paoff}.
		      See {\tt mexstack::print\_instr}\pagnote{PRINT-INSTR}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-tcnever}	    & Determines the trace class of an assembled instruction. \\
\label{-TCNEVER}
\TT{-tcnormal}	    & \TT{-tcnormal} sets the trace class of an op code
                      to that
		      given by Figure~\itemref{TRACE-CLASSES-AND-GROUPS}.
                      \TT{-tcnever} sets the class to \TT{NEVER} unless
		      the normal instruction trace class is \TT{ALWAYS}.
		      Default is \TT{-tcnormal}.
\\[0.5ex]
\TT{-tc:}{\em tc-list} \label{-TC:}
		    & Sets the process \TT{trace\_flags}\pagnote{TRACE-FLAGS}
		      at the start of mex
		      program execution.  \TT{ALWAYS} and \TT{NEVER}
		      can\underline{not} be listed: their flags are always
		      on and off, respectively.
		      Default is \TT{-tc:NONE}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-ex:}{\em ex-list}
		    & Sets the process \TT{excepts\_mask}\pagnote{EXCEPTS-MASK}
		      at the start of mex
		      program execution.
		      Default is \TT{-ex:DIVBYZERO,INVALID,OVERFLOW}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\begin{tabular}[t]{@{}l@{}}
\TT{-o:off} \\
\TT{-o:on} \\
\end{tabular}	    & Sets the process \TT{optimize} flag\pagnote{OPTIMIZE}
                     \TT{on} or \TT{off}
                      at the start of mex program execution.
		      Default is \TT{-o:off}.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-counter} $L$   & Sets the process
                      \TT{counter\_limit}\pagnote{COUNTER-LIMIT}
		      to integer $L$.
\\[0.5ex]
\TT{-stack} $L$	    & Sets the process \TT{max\_length} (stack size)
                      to integer $L$.
\\[0.5ex]
\TT{-return-stack} $L$
		    & Sets the process \TT{return\_stack->max\_length}
		      (return stack size) to integer $L$.
\end{tabular}\end{indpar}
\begin{indpar}\begin{tabular}{p{1.3in}p{4.4in}}
\TT{-r} {\em function-name}
                    & Calls the named function, which must be of lexical
		      level 1 in some previously assembled module.
		      To find the function, the name is searched for
		      in the modules, most recently assembled module first.
\\[0.5ex]
		    & The function must take no arguments and return no
		      results.
\end{tabular}\end{indpar}

\clearpage

\printindex

\end{document}
