% Minimal Runtime System
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{wasysym}
\usepackage{makeidx}
\usepackage{upquote}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\LAQUOTEBOX}
\begin{lrbox}{\LAQUOTEBOX}
{\tt \guillemotleft}
\end{lrbox}
\newcommand{\LAQUOTE}{\usebox{\LAQUOTEBOX}}

\newsavebox{\RAQUOTEBOX}
\begin{lrbox}{\RAQUOTEBOX}
{\tt \guillemotright}
\end{lrbox}
\newcommand{\RAQUOTE}{\usebox{\RAQUOTEBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MEXKEY}[1]%
	   {\TT{#1}\ttindex{mex::#1}\ttindex{#1}}
\newcommand{\MEXLKEY}[2]%
           {\TT{#1#2}\index{mex::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MEXIKEY}[2]%
           {\TT{#1}\ttindex{mex::#2}\ttindex{#2}}
\newcommand{\MEXMKEY}[2]%
           {\TT{#1}\ttmindex{mex::#1}{#2}\ttmindex{#1}{#2}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Minimal Runtime System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Draft 1)}

\author{Robert L. Walton}

\date{June 22, 2023}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Runtime System Execution Engine.

MEX is a stack-oriented assembly language with some higher level
language features.

TBD

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{prog}{abbreviation}	& program \\
\end{tabular}
\end{indpar}

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test scripts such as \TT{mex\_interface\_test.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}



The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace}\label{mex::} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable stack.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, it is loaded into memory
ready for execution.  There is no MEX `binary' language.

Interfaces are provided by and used by the compiler, and
not by MEX.  Typically a module may reference the interface
of pre-existing modules.

Immediately after a module is compiled, it is executed.  The
resulting execution stack (see \itemref{STACKS}) becomes the
module's global variable stack.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector
and variables are pushed into the
the module's global variable stack.  Adding to interfaces is
a matter for the compiler, and not for MEX.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called
the function code block instructions are executed.  A function
can itself contain another function.

MEX does \underline{not} itself provide a compiler, but it
assumes a few compilation behaviors.

\section{Stacks}
\label{STACKS}

MEX is stack oriented.  A stack is a vector of \TT{min::gen}
values.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Values may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector.

MEX assumes that variables in the stack are read-only, unless
they are being assigned values by a block of code.  MEX assumes
that the variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values that code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.  MEX assumes that to allow
a form of variable update the compiler implements `next variables'
as described in \itemref{NEXT-VARIABLES-AND-LOOPS}.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and then pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, it does not pop its stack, but
leaves the stack as the module's global variable stack.

The number of values above the current function arguments in the
stack (or the number above the beginning of the stack for a
module execution) is a parameter of the current instruction known
to the compiler.  To maintain this rule, forward jumps must push
null values into the stack to take the place of the values that would be
pushed by the code being skipped.  Backward jumps are only allowed when
a loop block ends.

Forward jumps that leave a block may pop values from the stack
instead of pushing values.  In general a jump may first pop
values from the stack, and then push null values.

There are special considerations involving the stack if the
compiler allows functions to be nested inside other functions.
These considerations are described in \itemref{NESTED-FUNCTIONS}.

\subsection{Next Variables and Loops}
\label{NEXT-VARIABLES-AND-LOOPS}

MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler repoints the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and repoint {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the complier will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such vallues
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Nested Functions}
\label{NESTED-FUNCTIONS}

The lexical nesting level\label{LEXICAL-NESTING-LEVEL}
of a function is defined as follows.

If the function $F$ is not inside any other function, $F$ has
level 1.

If the function $F$ is inside a function and $F'$ is the smallest
function containing $F$, and if $F'$ has level $L'$, then $F$
has level $L=L'+1$.

If $F$ is a function inside another function $F'$, then $F$ can
reference the variables that $F'$ can reference when $F$ is
defined.  To locate these variables, knowing the frame pointer for the
execution of $F'$ is sufficient.  The frame pointer is defined as the
stack index of the last argument to $F'$, or equivalently, the stack
pointer when $F'$ is called.

MEX keeps track of the needed frame pointers using the following:
\begin{indpar}
{\bf Theorem}~~~If $F$ is a function of level $L$ and $1\le L'<L$,
then every execution of $F$ is contained in a unique execution of some
function $F'$ of level $L'$, and $F'$ is the unique function of
level $L'$ that lexically contains $F$.

{\bf Corollary}~~~If \TT{fp[$L'$]} is the frame pointer of the last
\underline{incomplete} execution of a function of level $L'$, then
it is the frame pointer of the unique function execution of level $L'$
that contains the function execution of $F$.
\end{indpar}

\section{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em non-arithmetic-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction} ::=
    instructions in Figure \ref{ARITHMETIC-INSTRUCTIONS}
\\[0.5ex]
\emkey{non-arithmetic-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \ref{ARITHMETIC-INSTRUCTIONS}
     excepting \TT{BEG\ldots} and \TT{END\ldots}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{instr}
\LABEL{MEX::INSTR} \\
\verb|{                                  | \\
\verb|    min::uns8 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_index}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                                  | \\
\end{tabular}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::code\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::code\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module\_insptr}

\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttikey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module}.  This information can be used to
print trace and error messages.

The \ttikey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code.
This stack contains global variables exported by the module.

The \ttikey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.

\section{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
a return stack, and other parameters.  Specifically:

\begin{indpar}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{pc}
\LABEL{MEX::PC} \\
\verb|{                                  | \\
\verb|    mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|    min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                                  | \\
\end{tabular}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{ret}
\LABEL{MEX::ret} \\
\verb|{                                  | \\
\verb|    mex::pc | & \TTMKEY{saved\_pc}{in {\tt mex::ret}} \\
\verb|    min::uns32 | & \TTMKEY{saved\_fp}{in {\tt mex::ret}} \\
\verb|    min::uns32 | & \TTMKEY{nargs}{in {\tt mex::ret}} \\
\verb|}                                  | \\
\end{tabular}

\begin{tabular}{r@{}l@{~~~~~~~~}l}
\verb|struct                        mex::| & \MEXKEY{process\_header}
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|    mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{sp}{in {\tt mex::process\_header}} \\
\verb|    min::packed_vec_insptr<mex::ret> | & \TTMKEY{return\_stack}
                                              {in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{rp}{in {\tt mex::process\_header}} \\
\verb|    min::uns32 | & \TTMKEY{fp}{in {\tt mex::process\_header}}\TT{[16]} \\
\verb|    min::uns64 | & \TTMKEY{trace\_flags}{in {\tt mex::process\_header}} \\
\verb|    int | & \TTMKEY{excepts}{in {\tt mex::process\_header}} \\
\verb|    int | & \TTMKEY{excepts\_accumulator}
                         {in {\tt mex::process\_header}} \\
\verb|    bool | & \TTMKEY{optimize}{in {\tt mex::process\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_ptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}
\\[0.5ex]
\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process\_insptr}

\end{indpar}

A \ttkey{pc}, or \key{program counter}, is a pointer to a module,
which is a code vector, and an index in that vector of an instruction.
Thus a \TT{pc} points at an instruction.  The \TT{pc} member of a
process is the current program counter of that process.

An \ttkey{sp}, or \key{stack pointer}, is the index of an element of
the process vector which is the stack.  To push a value into you add
+1 to the \TT{sp} and store the value in the element it now indexes.
To pop a value, you remove the value indexed by \TT{sp}, and then
add -1 to the \TT{sp}.  The \TT{sp} member of a
process is the current stack pointer of that process.

The \ttkey{return\_stack} is used by \TT{CALL} and \TT{RET}
instructions, with \TT{rp} being the index of the element at the
top of the stack (the last element pushed).
A \TT{CALL} instruction pushes a \TT{mex::ret} value
into the return stack.  This contains a \TT{saved\_pc} member
pointing at the instruction after the \TT{CALL} into the
\TT{return\_stack}.  A \TT{RET} instruction pops a \TT{mex::ret} value from
the \TT{return\_stack} and stores its \TT{saved\_pc}
in the current program counter
of the process (the \TT{pc} member of the \TT{process}).
See Figure~\ref{FUNCTION-INSTRUCTIONS} for more details.

The frame pointer vector, \TT{fp}, is explained in
\itemref{NESTED-FUNCTIONS}.

The \TT{trace\_flags}, \TT{excepts}, \TT{excepts\_accumuator}, and \TT{optimize}
members of a process
are explained in \itemref{TRACING-AND-EXCEPTIONS}.

\section{Instructions}
\label{INSTRUCTIONS}


\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{ADD}/\TT{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\TT{ADDI}
    & Adds \TT{immedD} to the top value.
\\\hline
\TT{MULI}
    & Multiplies the top value by \TT{immedD}.
\\\hline
\TT{SUB}/\TT{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\TT{SUBI}
    & Subtract \TT{immedD} from top value.
\\\hline
\TT{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\TT{DIV}/\TT{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\TT{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\TT{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\TT{MOD}/\TT{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first popped divided by \\
    & the first/second popped.
\\\hline
\TT{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\TT{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\TT{FLOOR}/\TT{CEILING}
    & Replace the top value by the and integer equal to the \\
    & top value rounded toward minus/plus infinity.
\\\hline
\TT{TRUNC}/\TT{ROUND}
    & Replace the top value by the and integer equal to the \\
    & top value rounded toward zero/the-nearest-integer.
\\\hline
\TT{NEG}/\TT{ABS}
    & Replace the top value by its negation/absolute-value.
\\\hline
\TT{LOG10}/\TT{LOGE}
    & Replace the top value by its log base 10/e.
\\\hline
\TT{LOG}/\TT{LOGR}
    & Pop 2 values, then push the log of the first/second popped \\
    & base the second/first popped.
\\\hline
\TT{EXP10}/\TT{EXPE}
    & Replace the top value by 10/e to the top value power.
\\\hline
\TT{EXP}/\TT{EXPR}
    & Pop 2 values, then push the first/second popped to the \\
    & second/first popped power.
\\\hline
\TT{COS}/\TT{SIN}/\TT{TAN}
    & Replace the top value by its sin/cos/tan.
\\\hline
\TT{ASIN}/\TT{ACOS}/\TT{TAN}
    & Replace the top value by its arc- sin/cos/tan.
\\\hline
\TT{ATAN2}/\TT{ATAN2R}
    & Pop 2 values, then push the arc-tangent of the \\
    & first/second popped divided by the second/first popped.
\\\hline
\TT{POWER}
    & Replace the top value by the top value to the \TT{immedA} power.
\\\hline
\end{tabular}
\end{center}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{PUSH}
    & Push the \TT{immedA}'th value in the stack below the top value \\
    & into the stack (\TT{immedA} = 0 duplicates the top value).
\\\hline
\TT{PUSHI}
    & Push \TT{immedD} into the stack.
\\\hline
\TT{PUSHG}
    & Push into the stack the \TT{immedA}'th value from the end of the \\
    & global value stack of the module pointed at by \TT{immedD}.
\\\hline
\TT{POP}
    & Pop 1 value and store it in the \TT{immedA}'th value in the stack below \\
    & the value popped (\TT{immedA} = 0 effectively discards the value).
\\\hline
\TT{JMP}
    & Add \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times), \\
    & then push \TT{immedD} into the stack \TT{immedB} times, \\
    & then add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
\\\hline
\TT{JMPEQ/JMPNE}
    & Pop 2 values and compare them.  If they are equal/not-equal \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{JMPLT/JMPLEQ}
    & Pop 2 values and compare them.  If the first popped is \\
    & less-than/less-than-or-equal-to the second popped, \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{JMPGT/JMPGEQ}
    & Pop 2 values and compare them.  If the first popped is \\
    & greater-than/greater-than-or-equal-to the second popped, \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{BEG}/\TT{NOP}
    & Do nothing.
\\\hline
\TT{END}
    & Add \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times).
\\\hline
\TT{BEGL}
    & Take the top \TT{immedB} values in the stack and push a copy of \\
    & them all into the stack, preserving stack ordering.
\\\hline
\TT{ENDL}/\TT{CONT}
    & First add \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times), \\
    & then take the top \TT{immedB} values in the stack and copy them \\
    & to the next lower \TT{immedB} values in the stack, then subtract \\
    & \TT{immedC} from the \TT{pc} (jumping backwards).
\\\hline
\end{tabular}
\end{center}
\caption{Housekeeping Instructions}
\label{HOUSEKEEPING-INSTRUCTIONS}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{BEGF}
    & Add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
\\\hline
\TT{ENDF}
    & Add \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times),
    					then pop \\
    & the return stack, set the process \TT{fp[immedB]} member \\
    & to the \TT{saved\_fp} member of the value popped, and set \\
    & the process \TT{pc} member to the \TT{pc} member of the value popped.
\\\hline
\TT{CALL}
    & Push a \TT{mex::ret} value into the return stack, setting its \\
    & \TT{saved\_pc} member to point to the instruction after the \TT{CALL}, \\
    & setting its \TT{saved\_fp} member to the processes \TT{fp[immedB]} \\
    & member, and setting its \TT{nargs} member to \TT{immedA}.  Then set \\
    & the \TT{index} of the process's \TT{pc} member to \TT{immedC} \\
    & (this should be the first instruction \underline{after} the
      \TT{BEGF} of the function. \\
    & \\
    & Here \TT{immedA} is the number of arguments and \TT{immedB} is the \\
    & lexical nesting level (\pagref{LEXICAL-NESTING-LEVEL}) of the
      target function.
\\\hline
\TT{CALLG}
    & Same as \TT{CALL} but also set the process's \TT{pc} member's 
                                                           \TT{module} \\
    & member from \TT{immedD} (which must convert to a \TT{mex::module}).
\\\hline
\TT{RET}
    & Pop \TT{immedC} values from the stack and save them.  Then add \\
    & \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times), then push \\
    & the saved values into the stack, then pop the return stack \\
    & and set the the process's \TT{pc} and \TT{fp[immedB]} members from the \\
    & \TT{saved\_pc} and \TT{saved\_fp} members of the value popped.
\\\hline
\TT{PUSHM}
    & Push the stack vector value with index \TT{immedA} \\
    & (i.e., \TT{current\_process[immedA]}).
\\\hline
\TT{PUSHL}
    & Push the stack vector value with index \TT{fp[immedB] + immedA}.
\\\hline
\TT{POPM}
    & Pop 1 value and store it into the stack vector element with index \\
    & \TT{immedA} (i.e., \TT{current\_process[immedA]}).
\\\hline
\TT{POPL}
    & Pop 1 value and store it into the stack vector element with index \\
    & \TT{fp[immedB] + immedA}.
\\\hline
\TT{PUSHA}
    & Push the stack vector value with index \TT{fp[immedB] - immedA}.
\\\hline
\TT{PUSHNARGS}
    & Push the \TT{nargs} member of the top value of the \TT{return\_stack} \\
    & (which is a natural number) converted to IEEE 64-bit floating point.
\\\hline
\TT{PUSHV}
    & Replace the top stack value \TT{V} with the value of \\
    & the stack vector element with index \TT{fp[immedB] - V}. \\
    & \TT{V} must convert to a non-negative integer.
\\\hline
\end{tabular}
\end{center}
\caption{Function Instructions}
\label{FUNCTION-INSTRUCTIONS}
\end{boxedfigure}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code}, a \TT{trace\_index},
and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.
The \TT{trace\_index} is explained in \itemref{TRACING-AND-EXCEPTIONS}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD};
    // Pop 2 values and push their sum.
mex::instr an_add_immediate_instruction = {mex::ADDI,,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG};
    // Do nothing.
mex::instr an_end_instruction = {mex::END,,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,,10,5,32,min::MISSING()};
    // Pop 10 values and discard them, then push min::MISSING()
    // 5 times, then add 32 to program counter to skip 32 instructions.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\ref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations and the C \TT{math.h}
library are used.  See \itemref{TRACING-AND-EXCEPTIONS} for error
handling.

The housekeeping instruction set is in
Figure~\ref{HOUSEKEEPING-INSTRUCTIONS}.
See \itemref{STACKS} for an overview of stack handling.

The function instruction set is in
Figure~\ref{FUNCTION-INSTRUCTIONS}.
See \itemref{NESTED-FUNCTIONS} for details concerning nested functions.

\section{Tracing and Exceptions}
\label{TRACING-AND-EXCEPTIONS}

A process has two modes: \key{normal} and \key{optimized}, as
determined by the \TT{optimize} member of the process.
The default setting of the \TT{optimize} member of a process
is \TT{false}.

In normal mode, if an instruction's \TT{trace\_index} value
\TT{I} is such that the bit \TT{1ull <{}< I} in the process's
\TT{trace\_flags} is on, the instruction is traced.  In optimized mode,
no tracing is done.  The default setting of the \TT{trace\_flags}
member of a process is \TT{0}.

When an instruction is traced, the instruction prints source lines
using \TT{min::\EOL print\_\EOL phrase\_\EOL lines} and the
instruction's \TT{min::phrase\_position} value from its module's
\TT{min::phrase\_\EOL position\_\EOL vec}, followed by
a description of the value produced by the instruction.

Arithmetic nstructions (Figure~\ref{ARITHMETIC-INSTRUCTIONS})
may raise the following exceptions, each
associated with a flag bit defined in \TT{fenv.h}
(see fenv(3) in the unix manual):
\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{FE\_DIVBYZERO} &  An operation on finite numbers produces infinity \\
                      &  as a result (e.g., {\tt 5/+0}).
\\\hline
\ttkey{FE\_INVALID} & An operation has no well defined result
                      (e.g., {\tt 0/0}). \\
		    & \TT{NaN} becomes the result.
\\\hline
\ttkey{FE\_OVERFLOW} & An operation produces a finite result too large to
                       store. \\
		     & An infinity becomes the result.
\\\hline
\ttkey{FE\_UNDERFLOW} & An operation produces a finite result too small to
                        store. \\
	              & {\tt +0} or {\tt -0} becomes the result.
\\\hline
\ttkey{FE\_INEXACT} & An operation produces a finite result that cannot
                      be stored exactly. \\
		    & The result is rounded to the nearest value.
\\\hline
\end{tabular}
\end{center}

In normal mode, an instruction that raises an exception prints
an error message if the instruction raises any exception whose bit
is on in the process's \TT{excepts} member.
The error message ends with source lines printed
using \TT{min::\EOL print\_\EOL phrase\_\EOL lines} and the
instruction's \TT{min::phrase\_position} value from its module's
\TT{min::phrase\_\EOL position\_\EOL vec}.

In optimized mode, instructions do not print error messages
involving exceptions.

In both modes, if any instruction raised an exception whose bit
is on in the process's \TT{excepts} member, a notice message is
printed when the process terminates.

The default setting of a process's \TT{excepts} member
is:
\begin{center}
\TT{FE\_DIVBYZERO|FE\_INVALID|FE\_OVERFLOW}
\end{center}

The process has a register that is the logical OR of all exceptions
raised during the process.  This is stored partly in hardware
and partly in the process's \TT{excepts\_\EOL accumulator} member.
When the process is not running, it is stored in the latter.  When
a process is optimized and is running and has not been interrupted,
it is store in the hardware register.

\clearpage

\printindex

\end{document}
