% Minimal Runtime System
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{wasysym}
\usepackage{makeidx}
\usepackage{upquote}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newsavebox{\LAQUOTEBOX}
\begin{lrbox}{\LAQUOTEBOX}
{\tt \guillemotleft}
\end{lrbox}
\newcommand{\LAQUOTE}{\usebox{\LAQUOTEBOX}}

\newsavebox{\RAQUOTEBOX}
\begin{lrbox}{\RAQUOTEBOX}
{\tt \guillemotright}
\end{lrbox}
\newcommand{\RAQUOTE}{\usebox{\RAQUOTEBOX}}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MEXKEY}[1]%
	   {\TT{#1}\ttindex{mex::#1}\ttindex{#1}}
\newcommand{\MEXLKEY}[2]%
           {\TT{#1#2}\index{mex::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MEXIKEY}[2]%
           {\TT{#1}\ttindex{mex::#2}\ttindex{#2}}
\newcommand{\MEXMKEY}[2]%
           {\TT{#1}\ttmindex{mex::#1}{#2}\ttmindex{#1}{#2}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Minimal Runtime System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Draft 1)}

\author{Robert L. Walton}

\date{July 5, 2023}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Runtime System Execution Engine.

MEX is layered on top of the Minimal Runtime System.

MEX is stack-oriented and block-oriented.  It computes with
\ttkey{min::gen} values.

\section{Abbreviations}
\label{ABBREVIATIONS}

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{immed}{abbreviation}	& immediate \\
\ttmkey{info}{abbreviation}	& information \\
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{fp}{abbreviation}	& frame pointer \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{sp}{abbreviation}	& stack pointer \\
\ttmkey{ret}{abbreviation}	& return \\
\end{tabular}
\end{indpar}

In addition abbreviations of the MIN Runtime System are used
in names of types and functions of that system.

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test scripts such as \TT{mex\_interface\_test.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}

MEX is layered on top of MIN, the Minimal Runtime System, and
includes \ttkey{min.h}.

The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}\ttindex{mex.h}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable stack.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, it is loaded into memory
ready for execution.  There is no MEX `binary' language.

Interfaces are provided by and used by the compiler, and
not by MEX.  Typically a module may reference interfaces
of previously compiled modules.

Immediately after a module is compiled, it is executed.  The
resulting execution stack (see Stacks, \itemref{STACKS}) becomes the
module's \key{global variable stack}, i.e., its vector of
global variables.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector
and variables are added to the end of
the module's global variable stack.  The compiler should add
interfaces to new global variables and new module functions, but
this is a matter for the compiler, and not for MEX.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called
the function code block instructions are executed.  A function
can itself contain another function.

MEX does \underline{not} itself provide a compiler, but it
assumes a few compilation behaviors.

\section{Stacks}
\label{STACKS}

MEX is stack oriented.  A stack is a vector of \TT{min::gen}
values.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Values may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector.

MEX assumes that variables in the stack are read-only, unless
they are being assigned values by a block of code.  MEX assumes
that the variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values that code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.  MEX assumes that to allow
a form of variable update the compiler implements `next variables'
as described in Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and then pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, it does not pop its stack, but
leaves the stack as the module's global variable stack.

The number of values above the current function arguments in the
stack (or the number above the beginning of the stack for a
module execution) is a parameter of the current instruction known
to the compiler.  To maintain this rule, forward jumps must push
null values into the stack to take the place of the values that would be
pushed by the code being skipped.  Backward jumps are only allowed when
a loop iteration block ends, and these pop values that were pushed
during the iteration block.

Forward jumps that leave a block may pop values from the stack
instead of pushing values.  In general a jump may first pop
values from the stack, and then push null values.

There are special considerations involving the stack if the
compiler allows functions to be nested inside other functions.
These considerations are described in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

\subsection{Next Variables and Loops}
\label{NEXT-VARIABLES-AND-LOOPS}

MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler repoints the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\label{EXAMPLE-LOOP}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and repoint {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the complier will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such vallues
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Nested Functions}
\label{NESTED-FUNCTIONS}

The \key{lexical nesting level}\label{LEXICAL-NESTING-LEVEL}
of a function is defined as follows.

If the function $F$ is not inside any other function, $F$ has
level 1.

If the function $F$ is inside a function and $F'$ is the smallest
function containing $F$, and if $F'$ has level $L'$, then $F$
has level $L=L'+1$.

If $E$ is the execution of a function $F$ of level $L$, we will
say that $E$ has level $L$.

If $F$ is a function inside another function $F'$, then $F$ can
reference the variables that $F'$ can reference when $F$ is
defined.  To locate these variables, knowing the frame pointer for the
execution of $F'$ is sufficient.  The frame pointer is defined as the
stack index of the last argument to $F'$, or equivalently, the stack
pointer when $F'$ is called.

MEX keeps track of the needed frame pointers using the following:%
\footnote{This method is the similar to that used in Ada.}
\begin{indpar}
{\bf Theorem}~~~If $F$ is a function of level $L$ and $1\le L'<L$,
and if $E$ is an execution of $F$, then there exists a smallest
execution $E'$ of some function of level $L'$ such that $E\subset E'$,
and $E'$ is an execution
of the unique function $F'$ of level $L'$ that lexically contains $F$.

{\bf Corollary}~~~During $E$ the frame pointer \TT{fp[$L'$]} is the
the frame pointer of $E'$.
\end{indpar}

\begin{indpar}
{\bf Proof of Theorem}:
The set of current \underline{in}completed function executions is a
list ordered by size (this order is the same as the order in the
return stack of the \TT{mex::ret} values created by the \TT{CALL}s
to the functions).

Suppose $E_1$ and $E_2$ are two consecutive
elements in this list with $E_2\subset E_1$, $E_1$ an execution of
$F_1$ of lexical level $L_1$, and $E_2$ and execution of
$F_2$ of lexical level $L_2$.  $E_2$ is initiated by a \TT{CALL}
in $E_1$.  This \TT{CALL}
\underline{cannot} be inside some function $F_3$ that is lexically
inside $F_1$, else the execution of $F_3$ would be between $E_1$
and $E_2$ in the list.  So in order for the \TT{CALL} to be in the
scope of the definition of $F_2$, we must have $L_2 = L_1+1$ or
$L_2\leq L_1$, or in short, $L_2\leq L_1+1$.

The first element of a list is an execution of a function of level
1, and $E$ has level $L$.  Since levels may increase by at most
+1 for each step from one element to the next, an execution of
every level in $[1,L)$ must exist in the list
before $E$.  Then there exists a smallest such execution $E'\supset E$ of
some function $F'$ of level $L'$.

Now we must prove that $F'$ is the unique function of level $L'$ that
lexically contains $F$.
It will be sufficient to just prove that $F'$ lexically contains $F$,
as the level $L'$ lexical container of $F$ is unique.

Consider the sublist of executions beginning with $E'$ and ending with
$E$.  All these executions but the first have level $\neq L'$.
If any had a level $<L'$, then by the proceeding argument there
would be a non-first element with level $L'$, which is not true,
so all these executions but the first have level $>L'$.

Consider two consective elements in this list, $E_1$ and $E_2$,
$E_2\subset E_1$, $E_1$ an execution of $F_1$ known to be lexically
inside $F'$, and $E_2$ and execution of
$F_2$ of lexical level $L_2>L'$.  $E_2$ is initiated by a \TT{CALL}
inside $F_1$ and therefore inside $F'$.
In order for this \TT{CALL}
to be in the scope of the definition of $F_2$, either $L_2\leq L'$,
or $F_2$ is lexically inside $F'$ and $L_2>L'$.
The first is not true,
so $F_2$ is lexically inside $F'$.  By recursion we get that all
elements of the sublist but the first are executions of functions
lexically inside $F'$, therefore $F$ is lexically inside $F'$.

QED

{\bf Proof of Corollary}:  By inspection of the actions of the \TT{CALL}
and \TT{RET} statements of Figure~\ref{FUNCTION-INSTRUCTIONS},
the frame pointer \TT{fp[$L'$]} is the frame pointer
of the \underline{last} \TT{CALL}ed \underline{in}complete execution
of any function of level $L'$, and is therefore the frame pointer
of the smallest execution of any function of level $L'$ that contains $E$.
\end{indpar}

If follows that during $E$ the variables of $F'$ can be accessed by
\TT{PUSHL} with \TT{immedB} = $L'$, the arguments of $F'$ can be
accessed by \TT{PUSHA} with \TT{immedB} = $L'$:
see Figure~\ref{FUNCTION-INSTRUCTIONS}.
The global variables can be accessed by \TT{PUSHM} or \TT{PUSHG}:
see Figure~\ref{HOUSEKEEPING-INSTRUCTIONS}.

\section{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em housekeeping-instruction} \\
		  $|$ & {\em function-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction} ::=
    instructions in Figure \ref{ARITHMETIC-INSTRUCTIONS}
\\[0.5ex]
\emkey{housekeeping-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \ref{HOUSEKEEPING-INSTRUCTIONS}
     excepting \TT{BEG}, \TT{END}, \TT{BEGL}, and \TT{ENDL}
\\[0.5ex]
\emkey{function-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \ref{FUNCTION-INSTRUCTIONS}
     excepting \TT{BEGF} and \TT{ENDF}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{instr}
\LABEL{MEX::INSTR} \\
\verb|{                   | \\
\verb|    min::uns8 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_flags}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{~}l}
\verb|enum         mex::| & \MEXKEY{trace\_flag}
\LABEL{MEX::TRACE_FLAG} \\
\verb|{                   | \\
\verb|mex:|\TTMKEY{TRACE\_DEPTH}{in {\tt mex::trace\_flag}} & \tt = 7 <{}< 0
\label{MEX::TRACE_DEPTH} \\
\verb|mex:|\TTMKEY{TRACE\_PHRASE}{in {\tt mex::trace\_flag}} & \tt = 1 <{}< 3 \\
\verb|mex:|\TTMKEY{TRACE\_NOJMP}{in {\tt mex::trace\_flag}} & \tt = 1 <{}< 4 \\
\verb|mex:|\TTMKEY{TRACE}{in {\tt mex::trace\_flag}} & \tt = 1 <{}< 7 \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::code\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{trace\_info}
                                              {in {\tt mex::code\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}

\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttikey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module}.  This information can be used to
print trace and error messages.

The \ttikey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code.
This stack contains global variables exported by the module.

The \ttikey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.

The \ttikey{trace\_info}{of module} member of the \TT{module} points
at a vector of \TT{min::gen} values such that for module \TT{m},
\TT{m->\EOL trace\_\EOL info[i]} gives information that can be used
to print trace messages for instruction \TT{m[i]}.  See
Tracing and Exceptions, \itemref{TRACING-AND-EXCEPTIONS}.

\section{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
a return stack, and other parameters.  Specifically:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{pc}%
\LABEL{MEX::PC} \\
\verb|{                   | \\
\verb|mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{ret}%
\LABEL{MEX::ret} \\
\verb|{                   | \\
\verb|mex::pc | & \TTMKEY{saved\_pc}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_fp}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{nargs}{in {\tt mex::ret}} \\
\verb|}                   | \\
\end{tabular}
\\[1ex]
\verb|typedef (* mex::|\MEXKEY{trace\_function}\verb|) ( mex::process p )|%
\LABEL{MEX::TRACE_FUNCTION} \\
\\[1ex]
\begin{tabular}{@{}r@{}l}
\verb|struct                         mex::| & \MEXKEY{process\_header}%
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                   | \\
\verb|min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{sp}{in {\tt mex::process\_header}} \\
\verb|min::packed_vec_insptr<mex::ret> | & \TTMKEY{return\_stack}%
                                              {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{rp}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{fp}{in {\tt mex::process\_header}}\TT{[16]} \\
\verb|mex::trace_function | & \TTMKEY{trace\_function}%
                                     {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{trace\_depth}{in {\tt mex::process\_header}} \\
\verb|min::uns8 | & \TTMKEY{trace\_flags}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_accumulator}%
                         {in {\tt mex::process\_header}} \\
\verb|bool | & \TTMKEY{optimize}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{limit}{in {\tt mex::process\_header}} \\
\verb|mex::finish_state | & \TTMKEY{finish\_state}%
                                   {in {\tt mex::process\_header}} \\
\verb|}                                    | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|enum         mex::| & \MEXKEY{finish\_state}%
\LABEL{MEX::FINISH_STATE} \\
\verb|{                 | \\
\verb|mex::| & \TTMKEY{MODULE\_END}{in {\tt mex::finish\_state}} \\
\verb|mex::| & \TTMKEY{CALL\_END}{in {\tt mex::finish\_state}} \\
\verb|mex::| & \TTMKEY{LIMIT\_STOP}{in {\tt mex::finish\_state}} \\
\verb|mex::| & \TTMKEY{ERROR\_STOP}{in {\tt mex::finish\_state}} \\
\verb|mex::| & \TTMKEY{JMP\_ERROR}{in {\tt mex::finish\_state}} \\
\verb|mex::| & \TTMKEY{FORM\_ERROR}{in {\tt mex::finish\_state}} \\
\verb|}                 | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}

\end{indpar}

A \TT{mex::process} is a vector of \TT{min::gen} elements which
is the process \key{stack}, with the last element being the top
of the stack (\TT{process[sp]}) and the first element
being the bottom of the stack (\TT{process[0]}).

An \ttkey{sp}, or \key{stack pointer}, is the index of an element of
the process vector which is just beyond the top of the stack.
It is also the length of the stack.  If the stack is not empty,
\TT{process[sp-1]} is the top of the stack.
To push a value into you store the value in the element \TT{sp}
indexes, and then +1 to \TT{sp}.
To pop a value, you add -1 to \TT{sp}, and then
remove the value indexed by \TT{sp}.
\TT{sp} member of a
process is the \key{current stack pointer} of that process.

A \ttkey{pc}, or \key{program counter}, is a pointer to a module,
which is a code vector, and an index in that vector of an instruction.
Thus a \TT{pc} points at an instruction.  The \TT{pc} member of a
process is the \key{current program counter} of that process.

The \ttkey{return\_stack} is used by \TT{CALL} and \TT{RET}
instructions, with \TT{rp} being the index of the element at the
top of the stack (the last element pushed).
A \TT{CALL} instruction pushes a \TT{mex::ret} value
into the return stack.  This contains a \TT{saved\_pc} member
pointing at the instruction after the \TT{CALL} into the
\TT{return\_stack}.  A \TT{RET} instruction pops a \TT{mex::ret} value from
the \TT{return\_stack} and stores its \TT{saved\_pc}
in the current program counter
of the process (the \TT{pc} member of the \TT{process}).
The \TT{nargs} member is the number of function arguments.
See the \TT{CALL} instruction in Figure~\ref{FUNCTION-INSTRUCTIONS}
for more details.

The process's frame pointer member, \TT{fp[16]} and the \TT{met::ret}
value's \TT{saved\_fp} member are explained in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

The process's \TT{counter} is incremented once every time an instruction
finishes execution.  The process stops when \TT{counter >= limit}. 
When the process terminates, \TT{finish\_state} is set.  For details
see \TT{mex::run\_process}, \pagref{MEX::RUN_PROCESS},

The \TT{trace\_function}, \TT{trace\_depth}, \TT{trace\_flags}, \TT{excepts},
\TT{excepts\_accumuator}, and \TT{optimize}
members of a process
are explained in Tracing and Exceptions, \itemref{TRACING-AND-EXCEPTIONS}.


\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{ADD}/\TT{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\TT{ADDI}
    & Adds \TT{immedD} to the top value.
\\\hline
\TT{MULI}
    & Multiplies the top value by \TT{immedD}.
\\\hline
\TT{SUB}/\TT{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\TT{SUBI}
    & Subtract \TT{immedD} from top value.
\\\hline
\TT{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\TT{DIV}/\TT{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\TT{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\TT{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\TT{MOD}/\TT{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first popped divided by \\
    & the first/second popped.
\\\hline
\TT{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\TT{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\TT{FLOOR}/\TT{CEILING}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward minus/plus infinity.
\\\hline
\TT{TRUNC}/\TT{ROUND}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward zero/the-nearest-integer.
\\\hline
\TT{NEG}/\TT{ABS}
    & Replace the top value by its negation/absolute-value.
\\\hline
\TT{LOG10}/\TT{LOGE}
    & Replace the top value by its log base 10/e.
\\\hline
\TT{LOG}/\TT{LOGR}
    & Pop 2 values, then push the log of the first/second popped \\
    & base the second/first popped.
\\\hline
\TT{EXP10}/\TT{EXPE}
    & Replace the top value by 10/e to the top value power.
\\\hline
\TT{EXP}/\TT{EXPR}
    & Pop 2 values, then push the first/second popped to the \\
    & second/first popped power.
\\\hline
\TT{COS}/\TT{SIN}/\TT{TAN}
    & Replace the top value by its sin/cos/tan.
\\\hline
\TT{ASIN}/\TT{ACOS}/\TT{TAN}
    & Replace the top value by its arc- sin/cos/tan.
\\\hline
\TT{ATAN2}/\TT{ATAN2R}
    & Pop 2 values, then push the arc-tangent of the \\
    & first/second popped divided by the second/first popped.
\\\hline
\TT{POWER}
    & Replace the top value by the top value to the \TT{immedA} power.
\\\hline
\end{tabular}
\end{center}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{PUSH}
    & Push the \TT{immedA}'th value in the stack below the top value \\
    & into the stack (i.e., \TT{sp[- immedA - 1]},
      so \TT{immedA} = 0 \\
    & duplicates the top value).
\\\hline
\TT{PUSHI}
    & Push \TT{immedD} into the stack.
\\\hline
\TT{PUSHG}
    & Push into the stack the \TT{immedA}+1'st value of the \\
    & global value stack of the module pointed at by \TT{immedD} \\
    & (i.e., \TT{m->globals[immedA]} where \TT{m} is the module)
\\\hline
\TT{PUSHM}
    & Push the stack vector value with index \TT{immedA} \\
    & (i.e., \TT{current\_process[immedA]}).
\\\hline
\TT{POP}
    & Pop 1 value and store it in the \TT{immedA}'th value in the stack \\
    & below the value popped (i.e., store to \TT{sp[- immedA - 1]}, \\
    & so \TT{immedA} = 0 discards the top value).
\\\hline
\TT{POPM}
    & Pop 1 value and store it into the stack vector element with \\
    & index \TT{immedA} (i.e., \TT{current\_process[immedA]}).
\\\hline
\TT{JMP}
    & Subtract \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times), \\
    & then push \TT{immedD} into the stack \TT{immedB} times, \\
    & then add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
\\\hline
\TT{JMPEQ/JMPNE}
    & Pop 2 values and compare them.  If they are equal/not-equal \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{JMPLT/JMPLEQ}
    & Pop 2 values and compare them.  If the first popped is \\
    & less-than/less-than-or-equal-to the second popped, \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{JMPGT/JMPGEQ}
    & Pop 2 values and compare them.  If the first popped is \\
    & greater-than/greater-than-or-equal-to the second popped, \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{BEG}/\TT{NOP}
    & Do nothing.
\\\hline
\TT{END}
    & Subtract \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times).
\\\hline
\TT{BEGL}
    & Take the top \TT{immedB} values in the stack and push a copy of \\
    & them all into the stack, preserving stack ordering.
\\\hline
\TT{ENDL}/\TT{CONT}
    & First subtract \TT{immedA} to \TT{sp}
      (popping the stack \TT{immedA} times), \\
    & then take the top \TT{immedB} values in the stack and copy them \\
    & to the next lower \TT{immedB} values in the stack, then subtract \\
    & \TT{immedC} from the \TT{pc} (jumping backwards to just after \\
    & the associated \TT{BEGL}).
\\\hline
\TT{SET\_TRACE}
    & The process \TT{trace\_flags} member is set from the low order \\
    & 8 bits of \TT{immedA}.
\\\hline
\TT{ERROR}
    & This instruction is always traced.  If \TT{immedB} is not zero, \\
    & the process terminates.
      Otherwise \TT{immedA} is subtracted \\
    & from \TT{sp} (popping the stack \TT{immedA} times).
      See \itemref{ERROR-INSTRUCTION}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Housekeeping Instructions}
\label{HOUSEKEEPING-INSTRUCTIONS}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{BEGF}
    & Add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
    \\[0.5ex]
    & Also used to provided data for \TT{CALL} as follows: \TT{immedB} is the \\
    & target functions lexical nesting level (\pagref{LEXICAL-NESTING-LEVEL}).
\\\hline
\TT{ENDF}
    & Add \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times),
    					then pop \\
    & the return stack, set the process \TT{fp[immedB]} member to the \\
    & \TT{saved\_fp} member of the value popped, and set the process \TT{pc} \\
    & member to the \TT{saved\_pc} member of the value popped.
\\\hline
\TT{CALL}
    & Push a \TT{mex::ret} value into the return stack, setting its
      \TT{saved\_pc} \\
    & member to point to the instruction after the \TT{CALL},
      and setting its \\
    & \TT{nargs} member to \TT{immedA}.  Then set
      the \TT{index} of the process's \TT{pc} \\
    & member to \TT{immedC}, which must reference a \TT{BEGF} instruction.
    \\[0.5ex]
    & Then take the target function's lexical level $L$ from the \TT{BEGF} \\
    & \TT{immedB} value, set the \TT{mex:ret} value's \TT{saved\_fp} member
      to the \\
    & process's \TT{fp[$L$]} member, and set the process's \TT{fp[$L$]}
      member to \\
    & the process's \TT{sp} member.
    \\[0.5ex]
    & Lastly add +1 to the process current \TT{pc} to skip the \TT{BEGF}.
\\\hline
\TT{CALLG}
    & Same as \TT{CALL} but also set the process's \TT{pc} member's 
                                                           \TT{module} \\
    & member from \TT{immedD} (which must convert to a \TT{mex::module}).
\\\hline
\TT{RET}
    & Pop \TT{immedC} values from the stack and save them.  Then add \\
    & \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times), then push \\
    & the saved values into the stack, then pop the return stack \\
    & and set the the process's \TT{pc} and \TT{fp[immedB]} members from the \\
    & \TT{saved\_pc} and \TT{saved\_fp} members of the value popped.
\\\hline
\TT{PUSHL}
    & Push the stack vector value with index \TT{fp[immedB] + immedA}.
\\\hline
\TT{POPL}
    & Pop 1 value and store it into the stack vector element with index \\
    & \TT{fp[immedB] + immedA}.
\\\hline
\TT{PUSHA}
    & Push the stack vector value with index \TT{fp[immedB] - immedA}.
\\\hline
\TT{PUSHNARGS}
    & Push the \TT{nargs} member of the top value of the \TT{return\_stack} \\
    & (which is a natural number) converted to IEEE 64-bit floating \\
    & point.
\\\hline
\TT{PUSHV}
    & Replace the top stack value \TT{V} with the value of \\
    & the stack vector element with index \TT{fp[immedB] - V}. \\
    & \TT{V} must convert to a non-negative integer.
\\\hline
\end{tabular}
\end{center}
\caption{Function Instructions}
\label{FUNCTION-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\section{Instructions}
\label{INSTRUCTIONS}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code}, \TT{trace\_flags},
and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.
The \TT{trace\_flags} are explained in Tracing and Exceptions,
\itemref{TRACING-AND-EXCEPTIONS}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD};
    // Pop 2 values and push their sum.
mex::instr an_add_immediate_instruction = {mex::ADDI,,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG};
    // Do nothing.
mex::instr an_end_instruction = {mex::END,,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,,10,5,32,min::MISSING()};
    // Pop 10 values and discard them, then push min::MISSING()
    // 5 times, then add 32 to program counter to skip 32 instructions.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\ref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations and the C \TT{math.h}
library are used.  See Tracing and Exceptions,
\itemref{TRACING-AND-EXCEPTIONS} for error
handling.

The housekeeping instruction set is in
Figure~\ref{HOUSEKEEPING-INSTRUCTIONS}.
See Stacks, \itemref{STACKS}, for an overview of stack handling.

The function instruction set is in
Figure~\ref{FUNCTION-INSTRUCTIONS}.
See Nested Functions, \itemref{NESTED-FUNCTIONS},
for details concerning nested functions.

\section{Tracing and Exceptions}
\label{TRACING-AND-EXCEPTIONS}

A process has two modes: \key{normal} and \key{optimized}, as
determined by the \TT{optimize} member of the process.
The default setting of the \TT{optimize} member of a process
is \TT{false}.

In normal mode, tracing of an instruction
is controlled by the \key{effective trace flags},
which are the logical AND of the instruction's \TT{trace\_flags}
member and the process's \TT{TRACE\_flags} member.
An instruction is traced if its \TT{TRACE} flag is on
in its effective trace flags.

In optimized mode, instructions are \underline{not} traced.

As an exception, \TT{ERROR} instructions are traced in all cases.

Arithmetic instructions that have errors raise exception flags.
In normal mode, an error message is also produced.  In both
normal and optimized modes, an error message is produced
when the process terminates if any exception flags have been raised.

\subsection{Arithmetic Tracing}
\label{ARITHMETIC-TRACING}

When an arithmetic instruction is traced and the effective
trace flag's \TT{TRACE\_PHRASE} flag is on,
the instruction source lines are output
using \TT{min::\EOL print\_\EOL phrase\_\EOL lines} and the
instruction's \TT{min::\EOL phrase\_\EOL position} value from its module's
\TT{min::phrase\_\EOL position\_\EOL vec}, followed by
a message such as:
\begin{center}
\tt 1 + 2 ===> 3
\end{center}
If the \TT{TRACE\_PHRASE} flag is off, a message such as:
\begin{center}
\tt Line 53: 1 + 2 ===> 3
\end{center}
is output instead.
Note that arithmetic instructions are usually not traced.

\subsection{Arithmetic Exceptions}
\label{ARITHMETIC-EXCEPTIONS}

Arithmetic instructions (Figure~\ref{ARITHMETIC-INSTRUCTIONS})
may raise the following exceptions, each
associated with a flag bit defined in \TT{fenv.h}
(see fenv(3) in the unix manual):
\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{FE\_DIVBYZERO} &  An operation on finite numbers produces infinity \\
                      &  as a result (e.g., {\tt 5/+0}).
\\\hline
\ttkey{FE\_INVALID} & An operation has no well defined result
                      (e.g., {\tt 0/0}). \\
		    & \TT{NaN} becomes the result.
\\\hline
\ttkey{FE\_OVERFLOW} & An operation produces a finite result too large to
                       store. \\
		     & An infinity becomes the result.
\\\hline
\ttkey{FE\_UNDERFLOW} & An operation produces a finite result too small to
                        store. \\
	              & {\tt +0} or {\tt -0} becomes the result.
\\\hline
\ttkey{FE\_INEXACT} & An operation produces a finite result that cannot
                      be stored exactly. \\
		    & The result is rounded to the nearest value.
\\\hline
\end{tabular}
\end{center}

In normal mode, an instruction that raises an exception prints
an error message if the instruction raises any exception whose bit
is on in the process's \TT{excepts} member.
The error message ends with source lines printed
using \TT{min::\EOL print\_\EOL phrase\_\EOL lines} and the
instruction's \TT{min::phrase\_\EOL position} value from its module's
\TT{min::phrase\_\EOL position\_\EOL vec}.

In optimized mode, instructions do not print error messages
involving exceptions.

In both modes, if any instruction raised an exception whose bit
is on in the process's \TT{excepts} member, a notice message is
printed when the process terminates.

The default setting of a process's \TT{excepts} member
is:
\begin{center}
\TT{FE\_DIVBYZERO|FE\_INVALID|FE\_OVERFLOW}
\end{center}

The process has a register that is the logical OR of the flag bits
of all exceptions
raised during the process.  This is stored partly in hardware
and partly in the process's \TT{excepts\_\EOL accumulator} member.
When the process is not running, it is stored in the latter.  When
a process is optimized and is running and has not been interrupted,
it is store in the hardware register.

\subsection{Non-Arithmetic Tracing}
\label{NON-ARITHMETIC-TRACING}

Tracing non-arithmetic functions calls the process's
\TT{trace\_function} member if that is not \TT{NULL},
or the \TT{mex::\EOL default\_\EOL trace\_\EOL function}
otherwise.  This is called before the instruction is
executed.  For conditional \TT{JMP\ldots} instructions,
the call is suppressed if the condition is false (so there
will be no jump) and the instruction's \TT{TRACE\_NOJMP}
flag is off.  For \TT{CALL} instructions, there are two
calls to \TT{trace\_function}, one before the \TT{CALL}
executes, and one with the program counter pointing
to the \TT{BEGF} instruction, just before the program
counter is incremented at the end of \TT{CALL} execution.

The remainder of this section describes the behavior of
the \TT{mex::\EOL default\_\EOL trace\_\EOL function}.

Default tracing uses the \TT{TRACE\_PHRASE} flag in the
same manner as Arithmetic Tracing, \itemref{ARITHMETIC-TRACING}.

To produce the companion message,
default tracing of the instruction \TT{module[i]} uses
$I$ = \TT{module->trace\_info[i]}.  If this is missing
or equals \TT{min::MISSING()}, a minimal message
is produced, such as:
\begin{center}
\tt POP 1.527 to sp[-6]
\end{center}
Otherwise $I$ is used to produce the message as follows.

For instructions that reference a single stack or global location,
namely \TT{PUSH\ldots} and \TT{POP\ldots} instructions,
$I$ should be a MIN string, and a message such
as:
\begin{center}
\tt $I$ 1.527
\end{center}
is produced.  Here $I$ would be expected to something
like `{\tt my variable =}' or `{\tt POP: my variable =}'.
Note that \TT{PUSH\ldots} instructions are usually
\underline{not} traced.

For other functions $I$ needs to be a \TT{min::object}
whose vector elements are MIN strings naming of stack
elements.  Specifically, $I$\TT{[i]} names \TT{sp[-i]}.
If this name is a \underline{non-empty} MIN string,
then the message contains `$I$\TT{[i]} = <value of \TT{sp[-i]}'.
These stack value parts of the message, if they exist, are separated
by commas and are all appended to the message prefix followed by a `\TT{:}'.

The message prefix $P$ is the value of the \TT{"prefix"} attribute
of $I$.  For \TT{JMP\ldots} instructions, the prefix is modified as
follows.  For a successful jump, the prefix is like
`$P$ because 5.8 < 7.2'.  For an unsuccessful jump the prefix
is like `no $P$ because not 5.8 < 7.2'.

The following are examples.

For the \TT{BEGF} instruction of a function names {\tt sum} with
two arguments, {\tt X} and {\tt Y}, if
\begin{center}
$I$ = {\tt \{"": prefix = "ENTRY TO SUM"|"X","Y"|\}}
\end{center}
the message would be something like:
\begin{center}
\tt ENTRY TO SUM: X = 5.89, Y = 12
\end{center}

For a \TT{JMPGEQ} instruction used to break out of a loop
at a time when the only variables were two loop variables,
{\tt i} and {\tt sum}, as in the example on \pagref{EXAMPLE-LOOP}, if
\begin{center}
$I$ = {\tt \{"": prefix = "BREAK"|"", "", "", "", "i","sum"|\}}
\end{center}
the message would be something like:
\begin{center}
\tt BREAK because 5 > 4: i = 5, sum = 10
\end{center}
The 4 {\tt ""}'s skip the two values being compared and the two \TT{next}
values in the stack.

Trace messages are indented by the process's \TT{trace\_depth} member
times the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{trace\_indent}\verb|    // Default == 2.|
\end{indpar}
In addition, in the first line of a message all the indent spaces but
the last are replaced by the value of the global variable:
\begin{indpar}
\verb|char mex::|\MEXKEY{trace\_mark}\verb|    // Default == '*'.|
\end{indpar}

A process's \TT{trace\_depth} is initialized to \TT{0} and maintained
by the following instructions:
\begin{center}
\begin{tabular}{l@{~~~~}l}
\TT{BEG} ~ \TT{BEGL} ~ \TT{CALL}+\TT{BEGF} & Increment by 1. \\
\TT{END} ~ \TT{ENDL} ~ \TT{ENDF} ~ \TT{RET} & Decrement by 1. \\
\TT{JMP\ldots} & Decrement by low order 3 bits of instruction's \\
               & \TT{trace\_flags} member (the bits masked by \\
               & \TT{mex::TRACE\_DEPTH}: \pagref{MEX::TRACE_DEPTH}). \\
\end{tabular}
\end{center}

\subsection{ERROR Instruction}
\label{ERROR-INSTRUCTION}

The \TT{ERROR} instruction is always traced, even in optimized mode.
The effective trace flags for this instruction are just the
\TT{trace\_flags} member of the instruction with the \TT{TRACE} flag forced on.

The trace message for the \TT{ERROR} instruction is thus in effect an
error message.

\subsection{Fatal Errors}
\label{FATAL-ERRORS}

\ikey{Fatal errors}{fatal error} are errors that terminate the current
process.  A fatal error produces an error message that describes the
error.  If a \TT{min::phrase\_position} is available for the instruction
that had the fatal error, it will be used to specify the location
of the error in source code.

The following is a complete list of fatal errors;
\begin{enumerate}
\item \TT{ERROR} instruction with non-zero \TT{immedB}.
\item A \TT{JMP\ldots} instruction comparing values
(A) one of which is not a number or an infinity, or
(B) both of which are infinities with the same sign.
\item Attempting to increase stack size to above the \TT{max\_length}
member of the process.
\item Attempting to increase the \TT{return\_stack}
size to above the \TT{max\_length} member of the process \TT{return\_stack}.
\item Attempt to pop a value off an empty stack.
\item Setting the process \TT{pc} to \TT{\{min::NULL\_STUB,$I$\}} where
$I$ is \underline{not} \TT{0}.
\item Attempt to decrement \TT{trace\_depth} when that is \TT{0}.

\end{enumerate}

Note that arithmetic exceptions (see \itemref{ARITHMETIC-EXCEPTIONS})
are \underline{not} fatal errors.

\section{MEX Functions}
\label{MEX Functions}

{\tt mex::module mex::}\MEXKEY{create\_module}
    \verb|( min::file f = min::NULL_STUB )|
\begin{indpar}
A \TT{mex::module} is created and returned.  The code vector is empty.
Empty \TT{position} and \TT{trace\_info} vectors are created.
The \TT{globals} member is set to \TT{min::NULL\_STUB} and the
\TT{interface} member is set to \TT{min::MISSING()}.
\end{indpar}

{\tt mex::process mex::}\MEXKEY{create\_process} \\
\hspace*{10em}\verb|( min::printer printer = mex::default_printer )|
\begin{indpar}
A \TT{mex::process} is created and returned.
The process \TT{length} member (stack size) is set to \TT{0}
and its \TT{max\_length} member (maximum stack size) is set to the
value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{stack\_limit}\verb|    // Default == 16384.|
\end{indpar}

An empty \TT{return\_stack} vector is created and its \TT{max\_size}
is set to the value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{return\_stack\_limit}%
            \verb|    // Default == 4096.|
\end{indpar}

Note: the stack's \TT{max\_length} members are \underline{not} permitted
to change during process execution.

The \TT{pc} member is set to \TT{\{min::NULL\_STUB,0\}}.
The \TT{optimize} member is set to \TT{false}.
The \TT{trace\_function} member is set to \TT{NULL}.
The \TT{sp}, \TT{rp}, \TT{fp[16]}, \TT{trace\_depth},
\TT{trace\_flags}, \TT{excepts}, and \TT{excepts\_accumulator}
members are set to \TT{0}.
\end{indpar}

{\tt min::locatable\_var<min::printer> mex::}\MEXKEY{default\_printer}
\begin{indpar}
See \TT{mex::create\_process}.
\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::module m, mex::process p = min:NULL_STUB )|
\begin{indpar}
Initialize \TT{p} (which is created by \TT{mex::create\_process}
if that is \TT{NULL\_STUB}) to run the code in \TT{m}.
Return the process.

The process stack and \TT{return\_stack} are set to empty.
The \TT{optimize} member is set to \TT{false}.
The \TT{trace\_function} member is set to \TT{NULL}.
The \TT{sp}, \TT{rp}, \TT{fp[0]}, \TT{trace\_depth},
\TT{excepts}, and \TT{excepts\_accumulator}
members are set to \TT{0}.

The \TT{pc} member is set to \TT{\{m,0\}}.

The \TT{optimize} and \TT{trace\_flags} members are not set
(but \TT{mex::create\_process} will set them to \TT{false} and
\TT{0} respectively).
\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::pc pc, mex::process p = min:NULL_STUB )|
\begin{indpar}
Ditto, but does not set the process \TT{pc} member.

Then emulates a \TT{CALL} to the \TT{pc} argument
value, which must point at a \TT{BEGF} instruction.
This creates a \TT{return\_stack} entry whose
\TT{saved\_pc} is \TT{\{min::NULL\_STUB,0\}}, so a return
will terminate the process normally.  The \TT{nargs} member
is set to \TT{0}.
\end{indpar}

{\tt bool mex::}\MEXKEY{run\_process} \verb|( mex::process p )|%
\label{MEX::RUN_PROCESS}
\begin{indpar}
Execute \TT{p} until it terminates.
Returns \TT{true} on normal termination
and \TT{false} otherwise.  The process \TT{finish\_state} is
set as follows to indicate cause of termination:
\begin{center}
\begin{tabular}{lp{3.0in}l}
\verb|mex::|\MEXKEY{MODULE\_END}
    & \raggedright \TT{pc} equals \TT{\{m,index\}} with \TT{index == m->length}
    & returns \TT{true} \\
\verb|mex::|\MEXKEY{CALL\_END}
    & \TT{pc} equals \TT{\{min::NULL\_STUB,0\}}
    & returns \TT{true} \\
\verb|mex::|\MEXKEY{LIMIT\_STOP}
    & \TT{p->counter >= p->limit}
    & returns \TT{false} \\
\verb|mex::|\MEXKEY{ERROR\_STOP}
    & \TT{ERROR} instruction with \TT{immedB != 0}
    & returns \TT{false} \\
\verb|mex::|\MEXKEY{JMP\_ERROR}
    & \raggedright conditional \TT{JMP\ldots}~instruction with
      invalid operand(s)
      (either a \TT{NaN} or both infinities of the same sign)
    & returns \TT{false} \\
\verb|mex::|\MEXKEY{FORM\_ERROR}
    & \raggedright program formatting error (likely a compiler
      error)
    & returns \TT{false} \\
\end{tabular}
\end{center}
\end{indpar}

Notes:
\begin{enumerate}
\item On \TT{LIMIT\_STOP}, you can increase \TT{p->limit}
and call \TT{run\_process} again to continue execution.
\item You can use \TT{init\_process ( m )} followed by \TT{run\_process}
to run the code of \TT{m}.  Then after \TT{MODULE\_END},
you can add to the end of \TT{m}
and call \TT{run\_process} again to continue the execution of the code
of \TT{m} (i.e., execute the added code).
\end{enumerate}

\clearpage

\printindex

\end{document}
