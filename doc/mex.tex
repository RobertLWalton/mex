% Minimal Runtime System
%
% File:         mex.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{wasysym}
\usepackage{makeidx}
\usepackage{upquote}

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\bf \em #1}\index{#1}}
\newcommand{\lkey}[2]{{\bf \em #1 #2}\index{#1!#2}}
\newcommand{\mkey}[2]{{\bf \em #1}\index{#1!#2}}
\newcommand{\lmkey}[3]{{\bf \em #1 #2}\index{#1!#2!#3}}

\newcommand{\skey}[2]{{\bf \em #1#2}\index{#1}}
\newcommand{\slkey}[3]{{\bf \em #1 #2#3}\index{#1!#2}}
\newcommand{\smkey}[3]{{\bf \em #1#2}\index{#1!#3}}

\newcommand{\ikey}[2]{{\bf \em #1}\index{#2}}

\newcommand{\ttkey}[1]{\TT{#1}\index{#1@{\tt #1}}}
\newcommand{\ttikey}[2]{\TT{#1}\index{#2@{\tt #2}}}
\newcommand{\ttlkey}[2]{\TT{#1 #2}\index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\ttmkey}[2]{\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttdkey}[1]{\TT{.#1}\index{#1@{\tt .#1}}}
\newcommand{\ttdmkey}[2]{\TT{.#1}\index{#1@{\tt .#1}!#2}}

\newcommand{\ttbkey}[1]{\TT{[#1]}\index{[]@{\tt [#1]}}}
\newcommand{\ttbmkey}[2]{\TT{[#1]}\index{[]@{\tt [#1]}!#2}}

\newcommand{\tttkey}[1]{\TT{<#1>}\index{#1@{\tt <#1>}}}
\newcommand{\tttmkey}[2]{\TT{<#1>}\index{#1@{\tt <#1>}!#2}}

\newcommand{\tttbkey}[1]{{\TT {<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}}}
\newcommand{\tttbmkey}[2]{{\TT{<#1|}\ldots\TT{|#1>}}%
    \index{#1@\TT{<#1|}\ldots\TT{|#1>}!#2}}

\newcommand{\ttarmkey}[2]{{\tt ->}\TT{#1}\index{#1@{\tt #1}!#2}}

\newcommand{\ttindex}[1]{\index{#1@{\tt #1}}}
\newcommand{\ttmindex}[2]{\index{#1@{\tt #1}!#2}}
\newcommand{\ttlindex}[2]{\index{#1#2@{\tt #1}!{\tt #2}}}

\newcommand{\emkey}[1]{{\bf \em #1}\index{#1@{\em #1}}}
\newcommand{\emlkey}[2]{{\bf \em #1#2}\index{#1@{\em #1}!#2@{\em #2}}}
\newcommand{\emskey}[2]{{\bf \em #1#2}\index{#1@{\em #1}}}
\newcommand{\emikey}[2]{{\bf \em #1}\index{#2}}
\newcommand{\emindex}[1]{\index{#1@{\em #1}}}

\newcommand{\ttomkey}[3]{\TT{operator #2}\index{#1@{\tt operator #2}!{#3}}}
\newcommand{\ttmokey}[2]{\TT{#1}\index{#1@{\tt operator #1}!{#2}}}

\newcommand{\ttfkey}[2]{\TT{#1}\index{#1@{\tt #1}!for #2@for {\tt #2}}}

\newcommand{\ttakey}[2]{\TT{#1}\index{#2@{\tt #1}}}
\newcommand{\ttamkey}[3]{\TT{#1}\index{#2@{\tt #1}!#3}}

\newcommand{\subskey}[1]{$\mathbf{^{#1}}$\index{#1@$^{#1}$}}
\newcommand{\subsmkey}[2]{$\mathbf{^{#1}}$\index{#1@$^{#1}$!#2}}

\newcommand{\minkey}[1]%
           {\TT{min::#1}\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minlkey}[2]%
           {\TT{min::#1#2}\index{min::#1@{\tt min::#1}!#2@{\tt #2}}%
                          \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\minikey}[2]%
           {\TT{min::#1}\ttindex{min::#2}\ttindex{#2}}
\newcommand{\minmkey}[2]%
           {\TT{min::#1}\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPkey}[1]{\TT{MUP::#1}\ttindex{MUP::#1}\ttindex{#1}}
\newcommand{\MUPmkey}[2]%
           {\TT{MUP::#1}\ttmindex{MUP::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\minindex}[1]{\ttindex{min::#1}\ttindex{#1}}
\newcommand{\minmindex}[2]{\ttmindex{min::#1}{#2}\ttmindex{#1}{#2}}
\newcommand{\MUPindex}[1]{\ttindex{MUP::#1}\ttindex{#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\newcommand{\LABEL}[1]{\label{#1}}
\newlength{\ARGBREAKLENGTH}
\settowidth{\ARGBREAKLENGTH}{\tt ~~~~}
\newcommand{\ARGBREAK}[1][\ARGBREAKLENGTH]{\\&\hspace*{#1}}
\newcommand{\ARGSKIP}[2][\ARGBREAKLENGTH]{\\[#2]&\hspace*{#1}}
\newcommand{\TTKEY}[1]{\ttkey{#1}}
\newcommand{\TTARMKEY}[2]{\ttarmkey{#1}{#2}}
\newcommand{\TTBKEY}[1]{\ttbkey{#1}}
\newcommand{\TTBMKEY}[2]{\ttbmkey{#1}{#2}}
\newcommand{\TTOMKEY}[3]{\ttomkey{#1}{#2}{#3}}
\newcommand{\TTMOKEY}[2]{\ttmokey{#1}{#2}}
\newcommand{\TTDKEY}[1]{\ttdkey{#1}}
\newcommand{\TTDMKEY}[2]{\ttdmkey{#1}{#2}}
\newcommand{\TTMKEY}[1]{\ttmkey{#1}}
\newcommand{\MEXKEY}[1]%
	   {\TT{#1}\ttindex{mex::#1}\ttindex{#1}}
\newcommand{\MEXLKEY}[2]%
           {\TT{#1#2}\index{mex::#1@{\tt min::#1}!#2@{\tt #2}}%
                     \index{#1@{\tt #1}!#2@{\tt #2}}}
\newcommand{\MEXIKEY}[2]%
           {\TT{#1}\ttindex{mex::#2}\ttindex{#2}}
\newcommand{\MEXMKEY}[2]%
           {\TT{#1}\ttmindex{mex::#1}{#2}\ttmindex{#1}{#2}}

\newcommand{\REL}{$\,^R$}
\newcommand{\COMPACT}{$\,^C$}
\newcommand{\LOOSE}{$\,^L$}
\newcommand{\RESIZE}{$\,^S$}
\newcommand{\REORG}{$\,^O$}

\begin{document}
        
\title{Minimal Runtime System\\[2ex]Execution Engine\\[2ex]MEX\\[2ex]
       (Draft 1)}

\author{Robert L. Walton}

\date{August 13, 2023}
 
\maketitle

\begin{center}
\large \bf Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes MEX,
the Minimal Runtime System Execution Engine.

MEX is layered on top of the Minimal Runtime System.

MEX is stack-oriented and block-oriented.  It computes with
\ttkey{min::gen} values.

\section{Abbreviations}
\label{ABBREVIATIONS}

A modest number of \skey{abbreviation}s are used throughout this document
and the corresponding code:

\begin{indpar}
\begin{tabular}{p{0.8in}l}
\ttmkey{immed}{abbreviation}	& immediate \\
\ttmkey{info}{abbreviation}	& information \\
\ttmkey{instr}{abbreviation}	& instruction \\
\ttmkey{fp}{abbreviation}	& frame pointer \\
\ttmkey{pc}{abbreviation}	& program counter \\
\ttmkey{sp}{abbreviation}	& stack pointer \\
\ttmkey{ret}{abbreviation}	& return \\
\end{tabular}
\end{indpar}

In addition abbreviations of the MIN Runtime System are used
in names of types and functions of that system.

\section{C++ Interfaces}
\label{C++-INTERFACES}

MEX code and documentation is organized within the following
directories:

\begin{center}
\begin{tabular}{ll}
\ldots\TT{/}\ttkey{mex/include} & \TT{*.h} files such as \TT{mex.h}
\\[1ex]
\ldots\TT{/}\ttkey{mex/src} & \TT{*.cc} files such as \TT{mex.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/test} & test scripts such as \TT{mex\_interface\_test.cc}
\\[1ex]
\ldots\TT{/}\ttkey{mex/doc} & documentation files such as \TT{mex.tex}
\\[1ex]
\ldots\TT{/}\ttkey{mex/lib} & contains \TT{libmex.a} library of MEX binary files
\end{tabular}
\end{center}

MEX is layered on top of MIN, the Minimal Runtime System, and
includes \ttkey{min.h}.

The C++ data and functions described in this document can be
accessed by C++ code that contains the following inclusion:

\begin{center}\ttindex{mex.h}
\verb|#include  <mex.h>|
\end{center}

External MEX data and functions are placed in the
\ttmkey{mex}{namespace} namespace.

\section{Program Structure}
\label{PROGRAM-STRUCTURE}

A MEX \key{program} consists of one or more modules.
A MEX \key{module} is a data structure compiled from
a source code file.  A module has a code vector,
an interface, and a global variable stack.  A \key{code vector} is a vector
of instructions.  An \key{interface} is a data structure
that allows the compilation of references to the
global variables of the module and function calls to the
functions in the module code vector.

When a module is compiled, it is loaded into memory
ready for execution.  There is no MEX `binary' language.

Interfaces are provided by and used by the compiler, and
not by MEX.  Typically a module may reference interfaces
of previously compiled modules.

Immediately after a module is compiled, it is executed.  The
resulting execution stack (see Stacks, \itemref{STACKS}) becomes the
module's \key{global variable stack}, i.e., its vector of
global variables.

Each module is compiled sequentially, and it is possible to add
to the end of a pre-existing module.  Instructions are
just added to the end of the module's code vector
and variables are added to the end of
the module's global variable stack.  The compiler should add
interfaces to new global variables and new module functions, but
this is a matter for the compiler, and not for MEX.

A function is a sequential block of code in a module code vector.
When the module code vector is executed, just after compiling
the module, its functions are skipped over, as if they were not
there.  When a function is called
the function code block instructions are executed.  A function
can itself contain another function.

MEX does \underline{not} itself provide a compiler, but it
assumes a few compilation behaviors.

\section{Stacks}
\label{STACKS}

MEX is stack oriented.  A stack is a vector of \TT{min::gen}
values.  The end of this vector is referred to as the
\ikey{top}{of stack} of the stack.  Values may be \ikey{pushed}{into stack}
into the stack, meaning they are added to the end of the stack vector,
or \ikey{popped}{from stack} from the stack,
meaning that they are removed from the
end of the stack vector.

MEX assumes that variables in the stack are read-only, unless
they are being assigned values by a block of code.  MEX assumes
that the variables to be assigned by a block are pushed into the stack
by the compiler and made write-only.  Then the block is executed
and writes these variables.  When the block finishes, it pops
all the values that code inside the block has pushed into the stack,
leaving the write-only variables pushed before the block executed.
These variables are then made read-only by the compiler.

Note that MEX itself has no notion of read-only or write-only.
The compiler must enforce these.  MEX assumes that to allow
a form of variable update the compiler implements `next variables'
as described in Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}.

When a function executes, it begins with just its arguments
in the stack.  When it returns, it pops these and everything
else the function pushed into the stack, and then pushes
the return values of the function into the stack.

Builtin instructions behave like function calls: for example,
the \TT{ADD} instruction pops its two arguments from the stack
and then pushes their sum into the stack.

Immediately after it compiles, a module executes as if it were a function
of no arguments.  At its end, it does not pop its stack, but
leaves the stack as the module's global variable stack.

The number of values above the current function arguments in the
stack (or the number above the beginning of the stack for a
module execution) is a parameter of the current instruction known
to the compiler.  To maintain this rule, forward jumps must push
null values into the stack to take the place of the values that would be
pushed by the code being skipped.  Backward jumps are only allowed when
a loop iteration block ends, and these pop values that were pushed
during the iteration block.

Forward jumps that leave a block may pop values from the stack
instead of pushing values.  In general a jump may first pop
values from the stack, and then push null values.

There are special considerations involving the stack if the
compiler allows functions to be nested inside other functions.
These considerations are described in Nested Functions,
\itemref{NESTED-FUNCTIONS}.

\subsection{Next Variables and Loops}
\label{NEXT-VARIABLES-AND-LOOPS}

MEX assumes that the compiler will implement \skey{next variables}.
Consider the code:
\begin{indpar}\begin{verbatim}
x = 53
next x = x + 1      // Now x == 54
next x = x + 1      // Now x == 55
\end{verbatim}\end{indpar}
First {\tt x} is set to {\tt 53}, which is pushed into the stack.
The compiler points the name
{\tt x} at the stack location containing this value,
but this location is read-only and cannot be changed.
Then \TT{next x} is set to {\tt x + 1}, which is pushed into the stack.
At this point the compiler repoints the name {\tt x} at this new
stack location.  And so forth.

MEX assumes that loop blocks are implemented with next variables.
Consider the code:
\begin{indpar}\label{EXAMPLE-LOOP}\begin{verbatim}
i = 1
sum = 0
next i, next sum = while i <= 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which MEX assumes is equivalent to:
\begin{indpar}\begin{verbatim}
i = 1
sum = 0
next i, next sum:
    // First loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Second loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Third loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fourth loop iteration
    next sum = sum + i
    next i = i + 1
next i, next sum:
    // Fifth iteration does nothing but exit loop
\end{verbatim}\end{indpar}
However MEX assumes that the compiler prepares for a loop
block a bit differently than the preparation for
a non-loop block.

MEX assumes that to implement the example loop, the compiler
will first push copies of {\tt i} and {\tt sum} into
the stack, and repoint {\tt i} and {\tt sum} to these
copies, which will be read-only.
Then the complier will push {\tt i} and {\tt sum}
into the stack again, point the names {\tt next i} and
{\tt next sum} at these values, and make them write-only.
Then MEX will execute 5 loop iterations.  In each the
write-only values get updated.  At the end of each
iteration, the 2 write-only locations are copied to the
2 read-only locations in preparation for the next
iteration, and any values pushed into the stack by
code inside the loop block (there are no such vallues
in the example) are popped from the stack.  The end of
the loop pops these values and the write-only values,
leaving the names {\tt i} and {\tt sum} pointing at the read-only values
in the stack.

\subsection{Nested Functions}
\label{NESTED-FUNCTIONS}

The \key{lexical nesting level}\label{LEXICAL-NESTING-LEVEL}
of a function is defined as follows.

If the function $F$ is not inside any other function, $F$ has
level 1.

If the function $F$ is inside a function and $F'$ is the smallest
function containing $F$, and if $F'$ has level $L'$, then $F$
has level $L=L'+1$.

If $E$ is the execution of a function $F$ of level $L$, we will
say that $E$ has level $L$.

If $F$ is a function inside another function $F'$, then $F$ can
reference the variables that $F'$ can reference when $F$ is
defined.  To locate these variables, knowing the frame pointer for the
execution of $F'$ is sufficient.  The frame pointer is defined as the
stack index of the last argument to $F'$, or equivalently, the stack
pointer when $F'$ is called.

MEX keeps track of the needed frame pointers using the following:%
\footnote{This method is the similar to that used in Ada.}
\begin{indpar}
{\bf Theorem}~~~If $F$ is a function of level $L$ and $1\le L'<L$,
and if $E$ is an execution of $F$, then there exists a smallest
execution $E'$ of some function of level $L'$ such that $E\subset E'$,
and $E'$ is an execution
of the unique function $F'$ of level $L'$ that lexically contains $F$.

{\bf Corollary}~~~During $E$ the frame pointer \TT{fp[$L'$]} is the
the frame pointer of $E'$.
\end{indpar}

\begin{indpar}
{\bf Proof of Theorem}:
The set of current \underline{in}completed function executions is a
list ordered by size (this order is the same as the order in the
return stack of the \TT{mex::ret} values created by the \TT{CALL}s
to the functions).

Suppose $E_1$ and $E_2$ are two consecutive
elements in this list with $E_2\subset E_1$, $E_1$ an execution of
$F_1$ of lexical level $L_1$, and $E_2$ and execution of
$F_2$ of lexical level $L_2$.  $E_2$ is initiated by a \TT{CALL}
in $E_1$.  This \TT{CALL}
\underline{cannot} be inside some function $F_3$ that is lexically
inside $F_1$, else the execution of $F_3$ would be between $E_1$
and $E_2$ in the list.  So in order for the \TT{CALL} to be in the
scope of the definition of $F_2$, we must have $L_2 = L_1+1$ or
$L_2\leq L_1$, or in short, $L_2\leq L_1+1$.

The first element of a list is an execution of a function of level
1, and $E$ has level $L$.  Since levels may increase by at most
+1 for each step from one element to the next, an execution of
every level in $[1,L)$ must exist in the list
before $E$.  Then there exists a smallest such execution $E'\supset E$ of
some function $F'$ of level $L'$.

Now we must prove that $F'$ is the unique function of level $L'$ that
lexically contains $F$.
It will be sufficient to just prove that $F'$ lexically contains $F$,
as the level $L'$ lexical container of $F$ is unique.

Consider the sublist of executions beginning with $E'$ and ending with
$E$.  All these executions but the first have level $\neq L'$.
If any had a level $<L'$, then by the proceeding argument there
would be a non-first element with level $L'$, which is not true,
so all these executions but the first have level $>L'$.

Consider two consective elements in this list, $E_1$ and $E_2$,
$E_2\subset E_1$, $E_1$ an execution of $F_1$ known to be lexically
inside $F'$, and $E_2$ and execution of
$F_2$ of lexical level $L_2>L'$.  $E_2$ is initiated by a \TT{CALL}
inside $F_1$ and therefore inside $F'$.
In order for this \TT{CALL}
to be in the scope of the definition of $F_2$, either $L_2\leq L'$,
or $F_2$ is lexically inside $F'$ and $L_2>L'$.
The first is not true,
so $F_2$ is lexically inside $F'$.  By recursion we get that all
elements of the sublist but the first are executions of functions
lexically inside $F'$, therefore $F$ is lexically inside $F'$.

QED

{\bf Proof of Corollary}:  By inspection of the actions of the \TT{CALL}
and \TT{RET} statements of Figure~\ref{FUNCTION-INSTRUCTIONS},
the frame pointer \TT{fp[$L'$]} is the frame pointer
of the \underline{last} \TT{CALL}ed \underline{in}complete execution
of any function of level $L'$, and is therefore the frame pointer
of the smallest execution of any function of level $L'$ that contains $E$.
\end{indpar}

If follows that during $E$ the variables of $F'$ can be accessed by
\TT{PUSHL} with \TT{immedB} = $L'$, the arguments of $F'$ can be
accessed by \TT{PUSHA} with \TT{immedB} = $L'$:
see Figure~\ref{FUNCTION-INSTRUCTIONS}.
The global variables can be accessed by \TT{PUSHM} or \TT{PUSHG}:
see Figure~\ref{HOUSEKEEPING-INSTRUCTIONS}.

\section{Code Vectors}
\label{CODE-VECTORS}

A \key{code vector} is a MIN packed vector of instructions.
The syntactic structure of a code vector is:

\begin{indpar}
\emkey{code-vector} ::= {\em code-item}\STAR{}
\\[0.5ex]
\emkey{code-item} \begin{tabular}[t]{@{}rl} 
		  ::= & {\em arithmetic-instruction} \\
		  $|$ & {\em housekeeping-instruction} \\
		  $|$ & {\em function-instruction} \\
		  $|$ & {\em normal-block} \\
		  $|$ & {\em loop-block} \\
		  $|$ & {\em function-block} \\
		  \end{tabular}
\\[0.5ex]
\emkey{arithmetic-instruction} ::=
    instructions in Figure \ref{ARITHMETIC-INSTRUCTIONS}
\\[0.5ex]
\emkey{housekeeping-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \ref{HOUSEKEEPING-INSTRUCTIONS}
     excepting \TT{BEG}, \TT{END}, \TT{BEGL}, and \TT{ENDL}
\\[0.5ex]
\emkey{function-instruction} ::= \\
\hspace*{3em}
     instructions in Figure \ref{FUNCTION-INSTRUCTIONS}
     excepting \TT{BEGF} and \TT{ENDF}
\\[0.5ex]
\emkey{normal-block} ::= \begin{tabular}[t]{@{}l}
			 \TT{BEG} \\
			 {\em code-item}\STAR{} \\
			 \TT{END} \\
			 \end{tabular}
\\[0.5ex]
\emkey{loop-block} ::= \begin{tabular}[t]{@{}l}
		       \TT{BEGL} \\
		       {\em code-item}\STAR{} \\
		       \TT{ENDL} \\
		       \end{tabular}
\\[0.5ex]
\emkey{function-block} ::= \begin{tabular}[t]{@{}l}
			   \TT{BEGF} \\
			   {\em code-item}\STAR{} \\
			   \TT{ENDF} \\
			   \end{tabular}
\end{indpar}

The interface to a MEX module and its code vector is:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{instr}
\LABEL{MEX::INSTR} \\
\verb|{                   | \\
\verb|    min::uns8 | & \TTMKEY{op\_code}{in {\tt mex::instr}} \\
\verb|    min::uns8 | & \TTMKEY{trace\_flags}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedA}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedB}{in {\tt mex::instr}} \\
\verb|    min::uns16 | & \TTMKEY{immedC}{in {\tt mex::instr}} \\
\verb|    min::gen | & \TTMKEY{immedD}{in {\tt mex::instr}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{~}l}
\verb|enum         mex::| & \MEXKEY{trace\_flag}
\LABEL{MEX::TRACE_FLAG} \\
\verb|{                   | \\
\verb|mex:|\TTMKEY{TRACE\_DEPTH}{in {\tt mex::trace\_flag}} & \tt = 7 <{}< 0
\label{MEX::TRACE_DEPTH} \\
\verb|mex:|\TTMKEY{TRACE\_LINES}{in {\tt mex::trace\_flag}} & \tt = 1 <{}< 3 \\
\verb|mex:|\TTMKEY{TRACE\_NOJMP}{in {\tt mex::trace\_flag}} & \tt = 1 <{}< 4 \\
\verb|mex:|\TTMKEY{TRACE}{in {\tt mex::trace\_flag}} & \tt = 1 <{}< 7 \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct                        mex::| & \MEXKEY{module\_header}
\LABEL{MEX::MODULE_HEADER} \\
\verb|{                                  | \\
\verb|    min::uns32 | & \TTMKEY{control}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{length}{in {\tt mex::code\_header}} \\
\verb|    min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::code\_header}} \\
\verb|    min::phrase_position_vec | & \TTMKEY{position}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{globals}
                                              {in {\tt mex::code\_header}} \\
\verb|    min::gen | & \TTMKEY{interface}{in {\tt mex::code\_header}} \\
\verb|    min::packed_vec_ptr<min::gen> | & \TTMKEY{trace\_info}
                                              {in {\tt mex::code\_header}} \\
\verb|}                                  | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<mex::instr,mex::module_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{module}

\end{indpar}

The \TT{module} vector is the module's code vector.

The \ttikey{position}{of module} member of the \TT{module} gives a
\TT{min::\EOL phrase\_\EOL position} for every \TT{mex::instr}
element of the \TT{module} vector, and also gives the
\TT{position->\EOL file->\EOL file\_\EOL name} of the source
file of the \TT{module}.  This information can be used to
print trace and error messages.

The \ttikey{globals}{of module} member of the \TT{module}
is a copy of the stack created by executing the module code.
This stack contains global variables exported by the module.

The \ttikey{interface}{of module} member of the \TT{module} points
at the module's interface.  MEX does not itself specify or use
the interface -- this is up to the compiler.

The \ttikey{trace\_info}{of module} member of the \TT{module} points
at a vector of \TT{min::gen} values such that for module \TT{m},
\TT{m->\EOL trace\_\EOL info[i]} gives information that can be used
to print trace messages for instruction \TT{m[i]}.  See
Tracing and Exceptions, \itemref{TRACING-AND-EXCEPTIONS}.

\section{Processes}
\label{PROCESSES}

A \key{process} is a stack, a program counter, a stack pointer,
a return stack, and other parameters.  Specifically:

\begin{indpar}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{pc}%
\LABEL{MEX::PC} \\
\verb|{                   | \\
\verb|mex::module | & \TTMKEY{module}{in {\tt mex::pc}} \\
\verb|min::uns32 | & \TTMKEY{index}{in {\tt mex::pc}} \\
\verb|}                   | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|struct         mex::| & \MEXKEY{ret}%
\LABEL{MEX::ret} \\
\verb|{                   | \\
\verb|mex::pc | & \TTMKEY{saved\_pc}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{saved\_fp}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{nargs}{in {\tt mex::ret}} \\
\verb|min::uns32 | & \TTMKEY{nresults}{in {\tt mex::ret}} \\
\verb|}                   | \\
\end{tabular}
\\[1ex]
\verb|const unsigned mex::|\MEXKEY{max\_lexical\_level}\verb| = 16|%
\LABEL{MEX::MAX_LEXICAL_DEPTH}
\\[1ex]
\begin{tabular}{@{}r@{}l}
\verb|struct                         mex::| & \MEXKEY{process\_header}%
\LABEL{MEX::PROCESS_HEADER} \\
\verb|{                                   | \\
\verb|min::uns32 | & \TTMKEY{control}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{length}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{max\_length}{in {\tt mex::process\_header}} \\
\verb|mex::pc | & \TTMKEY{pc}{in {\tt mex::process\_header}} \\
\verb|min::packed_vec_insptr<mex::ret> | & \TTMKEY{return\_stack}%
                                              {in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{rp}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{fp}{in {\tt mex::process\_header}}%
                     \TT{[mex::max\_lexical\_level+1]} \\
\verb|min::uns32 | & \TTMKEY{trace\_depth}{in {\tt mex::process\_header}} \\
\verb|min::uns8 | & \TTMKEY{trace\_flags}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts}{in {\tt mex::process\_header}} \\
\verb|int | & \TTMKEY{excepts\_accumulator}%
                         {in {\tt mex::process\_header}} \\
\verb|bool | & \TTMKEY{optimize}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{counter}{in {\tt mex::process\_header}} \\
\verb|min::uns32 | & \TTMKEY{limit}{in {\tt mex::process\_header}} \\
\verb|mex::state | & \TTMKEY{state}%
                                   {in {\tt mex::process\_header}} \\
\verb|}                                    | \\
\end{tabular}

\begin{tabular}{@{}r@{}l}
\verb|enum         mex::| & \MEXKEY{state}%
\LABEL{MEX::STATE} \\
\verb|{                 | \\
\verb|mex::| & \TTMKEY{NEVER\_STARTED}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{RUNNING}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{MODULE\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{CALL\_END}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{LIMIT\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{ERROR\_STOP}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{JMP\_ERROR}{in {\tt mex::state}} \\
\verb|mex::| & \TTMKEY{FORM\_ERROR}{in {\tt mex::state}} \\
\verb|}                 | \\
\end{tabular}

\verb|typedef min::packed_vec_insptr<min::gen,mex::process_header>| \\
\hspace*{3em}\verb|mex::|\MEXKEY{process}

\end{indpar}

A \TT{mex::process} is a vector of \TT{min::gen} elements which
is the process \key{stack}, with the last element being the top
of the stack (\TT{process[sp]}) and the first element
being the bottom of the stack (\TT{process[0]}).

The value of \TT{p->length},
a.k.a.~the \key{stack pointer}, is the index of an element of
the process vector which is just beyond the top of the stack,
and is also the length of the stack.  If the stack is not empty,
\TT{process[p->length-1]} is the top of the stack.
To push a value into the stack,
you store the value in the element \TT{p->length}
indexes, and then +1 to \TT{p->length}.
To pop a value, you add -1 to \TT{p->length}, and then
read the value indexed by \TT{p->length}.
We require that \TT{0 <= p->length <= p->max\_length} at all times,
and \underline{never} increase \TT{p->max\_length} during execution.

A \ttkey{pc}, or \key{program counter}, is a pointer to a module,
which is a code vector, and an index in that vector of an instruction.
Thus a \TT{pc} points at an instruction.  The \TT{pc} member of a
process is the \key{current program counter} of that process.

The \ttkey{return\_stack} is used by \TT{CALL} and \TT{RET}
instructions.  The value of \TT{return\_stack->\EOL length},
a.k.a.~the \key{return stack pointer}, is the index of the element of
the return stack which is just beyond the top of the stack,
and is also the length of the stack.  If the stack is not empty,
\TT{p->return\_stack[return\_stack->length-1]} is the top of the stack.
A \TT{CALL} instruction pushes a \TT{mex::ret} value
into the return stack.  This contains a \TT{saved\_pc} member
pointing at the instruction after the \TT{CALL} into the
\TT{return\_stack}.  A \TT{RET} instruction pops a \TT{mex::ret} value from
the \TT{return\_stack} and stores its \TT{saved\_pc}
in the current program counter
of the process (the \TT{pc} member of the \TT{process}).
The \TT{nargs} member is the number of function arguments,
and the \TT{nresults} member is the number of function results.
See the \TT{CALL} instruction in Figure~\ref{FUNCTION-INSTRUCTIONS}
for more details.

The process's frame pointer member, \TT{fp[\ldots]} and the \TT{met::ret}
value's \TT{saved\_fp} member are explained in Nested Functions,
\itemref{NESTED-FUNCTIONS}.  The value of \TT{fp[0]}, the frame pointer
for lexical level \TT{0} (outside all functions), is always \TT{0}.

The process's \TT{counter} is incremented once every time an instruction
finishes execution.  The process stops when \TT{counter >= limit}. 
When the process terminates, \TT{state} is set.  For details
see \TT{mex::run\_process}, \pagref{MEX::RUN_PROCESS},

The \TT{trace\_depth}, \TT{trace\_flags}, \TT{excepts},
\TT{excepts\_accumuator}, and \TT{optimize}
members of a process
are explained in Tracing and Exceptions, \itemref{TRACING-AND-EXCEPTIONS}.


\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{ADD}/\TT{MUL}
    & Pop 2 values, then push their sum/product.
\\\hline
\TT{ADDI}
    & Adds \TT{immedD} to the top value.
\\\hline
\TT{MULI}
    & Multiplies the top value by \TT{immedD}.
\\\hline
\TT{SUB}/\TT{SUBR}
    & Pop 2 values, then push second/first popped minus \\
    & first/second popped.
\\\hline
\TT{SUBI}
    & Subtract \TT{immedD} from top value.
\\\hline
\TT{SUBRI}
    & Replace top value by \TT{immedD} minus top value.
\\\hline
\TT{DIV}/\TT{DIVR}
    & Pop 2 values, then push second/first popped divided by\\
    & first/second popped.
\\\hline
\TT{DIVI}
    & Divide top value by \TT{immedD}.
\\\hline
\TT{DIVRI}
    & Replace top value by \TT{immedD} divided by top value.
\\\hline
\TT{MOD}/\TT{MODR}
    & Pop 2 values, then push the round-toward-minus-infinity \\
    & remainder of the second/first popped divided by \\
    & the first/second popped.
\\\hline
\TT{MODI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of the top value divided by \TT{immedD}.
\\\hline
\TT{MODRI}
    & Replace the top value by the round-toward-minus-infinity \\
    & remainder of \TT{immedD} divided by the top value.
\\\hline
\TT{FLOOR}/\TT{CEIL}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward minus/plus infinity.
\\\hline
\TT{TRUNC}/\TT{ROUND}
    & Replace the top value by the an integer equal to the \\
    & top value rounded toward zero/the-nearest-integer, \\
    & with nearest halfway cases rounded to the even integer.
\\\hline
\TT{NEG}/\TT{ABS}
    & Replace the top value by its negation/absolute-value.
\\\hline
\TT{LOG}/\TT{LOG10}
    & Replace the top value by its log base e/10.
\\\hline
\TT{EXP}/\TT{EXP10}
    & Replace the top value by e/10 to the top value power.
\\\hline
\TT{SIN}/\TT{COS}/\TT{TAN}
    & Replace the top value by its sin/cos/tan.
\\\hline
\TT{ASIN}/\TT{ACOS}/\TT{TAN}
    & Replace the top value by its arc- sin/cos/tan.
\\\hline
\TT{ATAN2}/\TT{ATAN2R}
    & Pop 2 values, then push the arc-tangent of the \\
    & second/first popped divided by the first/second popped.
\\\hline
\TT{POWI}
    & Replace the top value by the top value to the \TT{immedA} power.
\\\hline
\end{tabular}
\end{center}
\caption{Arithmetic Instructions}
\label{ARITHMETIC-INSTRUCTIONS}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{PUSHS}
    & Push the \TT{immedA}'th value in the stack below the top value \\
    & into the stack (i.e., \TT{sp[- immedA - 1]},
      so \TT{immedA} = 0 \\
    & duplicates the top value).
\\\hline
\TT{PUSHL}
    & Push the stack vector value with index \TT{fp[immedB] + immedA}. \\
    & But if \TT{immedB == 0} and \TT{m->globals} is not \TT{min::NULL\_STUB} \\
    & for the module \TT{m} of the current program counter, push \\
    & \TT{m->globals[immedA]} instead.
\\\hline
\TT{PUSHI}
    & Push \TT{immedD} into the stack.
\\\hline
\TT{PUSHG}
    & Push into the stack the \TT{immedA}+1'st value of the \\
    & global value stack of the module pointed at by \TT{immedD} \\
    & (i.e., \TT{m->globals[immedA]} where \TT{m} is the module)
\\\hline
\TT{POPS}
    & Pop 1 value and store it in the \TT{immedA}'th value in the stack \\
    & below the value popped (i.e., store to \TT{sp[- immedA - 1]}, \\
    & so \TT{immedA} = 0 discards the top value).
\\\hline
\TT{JMP}
    & Subtract \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times),
      then \\
    & add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
      It is \\
    & illegal for \TT{immedC} = 0 (\TT{JMP} would jump to itself).
\\\hline
\TT{JMPEQ/JMPNE}
    & Pop 2 values and compare them.  If they are equal/not-equal \\
    & continue as per the \TT{JMP} instruction.  Otherwise do nothing.
\\\hline
\TT{JMPLT/JMPLEQ}
    & Ditto, but \TT{JMP} if the second popped is \\
    & less-than/less-than-or-equal-to the first popped.
\\\hline
\TT{JMPGT/JMPGEQ}
    & Ditto, but \TT{JMP} if the second popped is \\
    & greater-than/greater-than-or-equal-to the first popped.
\\\hline
\TT{BEG}/\TT{NOP}/\TT{END}
    & Subtract \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.
\\\hline
\TT{BEGL}
    & Subtract \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times). \\
    & The values popped are always trace values.  Then \\
    & take the top \TT{immedB} values in the stack and push a copy of \\
    & them all into the stack, preserving stack ordering.
\\\hline
\TT{ENDL}/\TT{CONT}
    & First subtract \TT{immedA} to \TT{sp}
      (popping the stack \TT{immedA} times), \\
    & then take the top \TT{immedB} values in the stack and copy them \\
    & to the next lower \TT{immedB} values in the stack, then subtract \\
    & \TT{immedC} from the \TT{pc} (jumping backwards to just after \\
    & the associated \TT{BEGL}).
\\\hline
\TT{SET\_TRACE}
    & The process \TT{trace\_flags} member is set from the low order \\
    & 8 bits of \TT{immedA}.
\\\hline
\TT{ERROR}
    & This instruction is always traced.  If \TT{immedB} is not zero, \\
    & the process terminates.
      Otherwise \TT{immedA} is subtracted \\
    & from \TT{sp} (popping the stack \TT{immedA} times).
      See \itemref{ERROR-INSTRUCTION}.
\\\hline
\end{tabular}
\end{center}
\vspace*{-3ex}
\caption{Housekeeping Instructions}
\label{HOUSEKEEPING-INSTRUCTIONS}
\end{boxedfigure}

\begin{boxedfigure}

\begin{center}
\begin{tabular}{|l|l|}
\hline
\TT{BEGF}
    & Add \TT{immedC} to the \TT{pc} (skipping \TT{immedC} instructions).
    \\[0.5ex]
    & Also used to provided data for \TT{CALL} as follows: \TT{immedB} is the \\
    & target function's lexical nesting level (\pagref{LEXICAL-NESTING-LEVEL}),
      and \TT{immedA} is the \\
    & minimum number of arguments expected.
\\\hline
\TT{ENDF}
    & Pop element $e$ from the return stack and check that \TT{$e$.level}
      equals \\
    & \TT{immedB} and \TT{$e$.nresults} equals zero.  Set the process's
       \TT{sp} member \\
    & to \TT{fp[immedB] - $e$.nargs}.  Then set the process's \TT{fp[immedB]} \\
    & and \TT{pc} members to \TT{$e$.saved\_fp} and \TT{$e$.saved\_pc}
      respectively.
\\\hline
\TT{CALLM}
    & Push a \TT{mex::ret} value into the return stack, setting its
      \TT{saved\_pc} \\
    & member to point to the instruction after the \TT{CALLM},
      and setting its \\
    & \TT{nargs} member to \TT{immedA} and its \TT{nresults} member
      to \TT{immedB}.  \\
    & Then set the \TT{index} of the process's \TT{pc} member to \TT{immedC}, \\
    & which must reference a \TT{BEGF} instruction.
    \\[0.5ex]
    & Check that the \TT{nargs} value is at least as great as the \TT{BEGF}
      \TT{immedC}, \\
    & the minimum number of expected arguments.  Then take the target \\
    & function's lexical level $L$ from the \TT{BEGF} \TT{immedB} value,
      set the \\
    & \TT{mex:ret} value's \TT{saved\_fp} member to the process's
      \TT{fp[$L$]} member, \\
    & and set the process's \TT{fp[$L$]} member to the process's
      \TT{sp} member.
    \\[0.5ex]
    & Lastly add +1 to the process current \TT{pc} to skip the \TT{BEGF}.
\\\hline
\TT{CALLG}
    & Same as \TT{CALLM} but also set the process's \TT{pc} member's 
                                                           \TT{module} \\
    & member from \TT{immedD} (which must convert to a \TT{mex::module}).
\\\hline
\TT{RET}
    & Subtract \TT{immedA} to \TT{sp} (popping the stack \TT{immedA} times).
      The \\
    & values popped are always trace values.  Pop element $e$ from the \\
    & return stack and check that \TT{immedB} and \TT{immedC} equal
      \TT{$e$.level} \\
    & and \TT{$e$.nresults}, respectively.  Pop \TT{immedC} values from
      the stack \\
    & and save them.  Set \TT{sp} to \TT{fp[immedB] - $e$.nargs} and then push \\
    & the saved values into the stack.  Set the process's \TT{fp[immedB]} and \\
    & \TT{pc} members to \TT{$e$.saved\_fp} and \TT{$e$.saved\_pc}
      respectively.
\\\hline
\TT{PUSHA}
    & Push the stack vector value with index \TT{fp[immedB] - immedA}.
\\\hline
\TT{PUSHNARGS}
    & Push the \TT{nargs} member of the top value of the \TT{return\_stack} \\
    & (which is a natural number) converted to IEEE 64-bit floating \\
    & point.
\\\hline
\TT{PUSHV}
    & Replace the top stack value \TT{V} with the value of the stack vector \\
    & element with index \TT{fp[immedB] - V}.  \TT{V} must convert to an \\
    & integer in a suitable range, else an invalid exception is raised \\
    & and the result is a \TT{NaN}.
\\\hline
\end{tabular}
\end{center}
\caption{Function Instructions}
\label{FUNCTION-INSTRUCTIONS}
\end{boxedfigure}

\clearpage

\section{Instructions}
\label{INSTRUCTIONS}

A MEX instruction (a \TT{mex::instr}, see \pagref{MEX::INSTR})
consists of an \TT{op\_code}, \TT{trace\_flags},
and up to 4 immediate values,
\TT{immedA}, \TT{immedB}, \TT{immedC}, and \TT{immedD}.
The \TT{trace\_flags} are explained in Tracing and Exceptions,
\itemref{TRACING-AND-EXCEPTIONS}.

Some examples:
\begin{indpar}\begin{verbatim}
mex::instr an_add_instruction = {mex::ADD};
    // Pop 2 values and push their sum.
mex::instr an_add_immediate_instruction = {mex::ADDI,,,,,3.14159};
    // Add 3.14159 to top value.
mex::instr a_begin_instruction = {mex::BEG};
    // Do nothing.
mex::instr an_end_instruction = {mex::END,,10};
    // Pop 10 values and discard them.
mex::instr a_jump_instruction = {mex::JMP,,10,5,32,min::MISSING()};
    // Pop 10 values and discard them, then push min::MISSING()
    // 5 times, then add 32 to program counter to skip 32 instructions.
\end{verbatim}\end{indpar}

The arithmetic instruction set is in Figure~\ref{ARITHMETIC-INSTRUCTIONS}.
IEEE 64-bit floating point operations and the C \TT{math.h}
library are used.  See Tracing and Exceptions,
\itemref{TRACING-AND-EXCEPTIONS} for error
handling.

The housekeeping instruction set is in
Figure~\ref{HOUSEKEEPING-INSTRUCTIONS}.
See Stacks, \itemref{STACKS}, for an overview of stack handling.

The function instruction set is in
Figure~\ref{FUNCTION-INSTRUCTIONS}.
See Nested Functions, \itemref{NESTED-FUNCTIONS},
for details concerning nested functions.

\section{Tracing and Exceptions}
\label{TRACING-AND-EXCEPTIONS}

A process has two modes: \key{normal} and \key{optimized}, as
determined by the \TT{optimize} member of the process.
The default setting of the \TT{optimize} member of a process
is \TT{false}.

In normal mode, tracing of an instruction
is controlled by the \key{trace class} $C$ of the instruction
and the \key{trace flags} $F$ of the process.  If
\TT{$F$ \& ( 1 <{}< $C$ ) != 0} the instruction is traced.

In optimized mode, instructions are \underline{not} traced.

As an exception, \TT{ERROR} instructions are traced in all cases.

When an instruction is traced and the process
trace flag's \TT{TRACE\_LINES} flag is on,
the instruction source lines are output
using \TT{min::\EOL print\_\EOL phrase\_\EOL lines} and the
instruction's \TT{min::\EOL phrase\_\EOL position} value from its module's
\TT{min::phrase\_\EOL position\_\EOL vec}.  This is then followed by
the instruction specific trace message.

Arithmetic instructions that have errors raise exception flags.
In normal mode, an error message is also produced.  In both
normal and optimized modes, an error message is produced
when the process terminates if any exception flags have been raised.

\subsection{Arithmetic Tracing}
\label{ARITHMETIC-TRACING}

The trace message of an arithmetic instruction has the form:
\begin{center}
{\em new-variable-name} \TT{=} {\em value} \TT{<=} {\em value}\QMARK{}
             {\em operator} {\em value}
\end{center}
If {\em new-variable-name} is not given in the instruction,
\TT{*} is used instead.
If the \TT{TRACE\_LINES} flag is off, the message is preceeded by
`\TT{Line} {\em line-number}\TT{:}'.
Note that arithmetic instructions are usually not traced.

\subsection{Arithmetic Exceptions}
\label{ARITHMETIC-EXCEPTIONS}

Arithmetic instructions (Figure~\ref{ARITHMETIC-INSTRUCTIONS})
may raise the following exceptions, each
associated with a flag bit defined in \TT{fenv.h}
(see fenv(3) in the unix manual):
\begin{center}
\begin{tabular}{|l|l|}
\hline
\ttkey{FE\_DIVBYZERO} &  An operation on finite numbers produces infinity \\
                      &  as a result (e.g., {\tt 5/+0}).
\\\hline
\ttkey{FE\_INVALID} & An operation has no well defined result
                      (e.g., {\tt 0/0}). \\
		    & \TT{NaN} becomes the result.
\\\hline
\ttkey{FE\_OVERFLOW} & An operation produces a finite result too large to
                       store. \\
		     & An infinity becomes the result.
\\\hline
\ttkey{FE\_UNDERFLOW} & An operation produces a finite result too small to
                        store. \\
	              & {\tt +0} or {\tt -0} becomes the result.
\\\hline
\ttkey{FE\_INEXACT} & An operation produces a finite result that cannot
                      be stored exactly. \\
		    & The result is rounded to the nearest value.
\\\hline
\end{tabular}
\end{center}

In normal mode, an instruction that raises an exception prints
an error message if the instruction raises any exception whose bit
is on in the process's \TT{excepts} member.
This error message is always followed by a trace of the instruction
(regardless of the process trace flag settings).

In optimized mode, instructions do not print error messages
involving exceptions.

In both modes, if any instruction raised an exception whose bit
is on in the process's \TT{excepts} member, a notice message is
printed when the process terminates.

The default setting of a process's \TT{excepts} member
is:
\begin{center}
\TT{FE\_DIVBYZERO|FE\_INVALID|FE\_OVERFLOW}
\end{center}

The process has a register that is the logical OR of the flag bits
of all exceptions
raised during the process.  This is stored partly in hardware
and partly in the process's \TT{excepts\_\EOL accumulator} member.
When the process is not running, it is stored in the latter.  When
a process is optimized and is running and has not been interrupted,
it is store in the hardware register.

\subsection{Jump Tracing}
\label{JUMP-TRACING}

TBD

\subsection{Non-Arithmetic Tracing}
\label{NON-ARITHMETIC-TRACING}

TBD

The trace message of the non-arithmetic instruction
\TT{module[i]} uses
$I$ = \TT{module->trace\_info[i]}.  If this is missing
or equals \TT{min::MISSING()}, a minimal message
is produced, such as:
\begin{center}
\tt POP 1.527 to sp[-6]
\end{center}
Otherwise $I$ is used to produce the message as follows.

For instructions that reference a single stack or global location,
namely \TT{PUSH\ldots} and \TT{POP\ldots} instructions,
$I$ should be a MIN string, and a message such
as:
\begin{center}
\tt $I$ 1.527
\end{center}
is produced.  Here $I$ would be expected to something
like `{\tt my variable =}' or `{\tt POP: my variable =}'.
Note that \TT{PUSH\ldots} instructions are usually
\underline{not} traced.

For other functions $I$ needs to be a \TT{min::object}
whose vector elements are MIN strings naming of stack
elements.  Specifically, $I$\TT{[i]} names \TT{sp[-i]}.
If this name is a \underline{non-empty} MIN string,
then the message contains `$I$\TT{[i]} = <value of \TT{sp[-i]}'.
These stack value parts of the message, if they exist, are separated
by commas and are all appended to the message prefix followed by a `\TT{:}'.

The message prefix $P$ is the value of the \TT{"prefix"} attribute
of $I$.  For \TT{JMP\ldots} instructions, the prefix is modified as
follows.  For a successful jump, the prefix is like
`$P$ because 5.8 < 7.2'.  For an unsuccessful jump the prefix
is like `no $P$ because not 5.8 < 7.2'.

The following are examples.

For the \TT{BEGF} instruction of a function names {\tt sum} with
two arguments, {\tt X} and {\tt Y}, if
\begin{center}
$I$ = {\tt \{"": prefix = "ENTRY TO SUM"|"X","Y"|\}}
\end{center}
the message would be something like:
\begin{center}
\tt ENTRY TO SUM: X = 5.89, Y = 12
\end{center}

For a \TT{JMPGEQ} instruction used to break out of a loop
at a time when the only variables were two loop variables,
{\tt i} and {\tt sum}, as in the example on \pagref{EXAMPLE-LOOP}, if
\begin{center}
$I$ = {\tt \{"": prefix = "BREAK"|"", "", "", "", "i","sum"|\}}
\end{center}
the message would be something like:
\begin{center}
\tt BREAK because 5 > 4: i = 5, sum = 10
\end{center}
The 4 {\tt ""}'s skip the two values being compared and the two \TT{next}
values in the stack.

Trace messages are indented by the process's \TT{trace\_depth} member
times the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{trace\_indent}\verb|    // Default == 2.|
\end{indpar}
In addition, in the first line of a message all the indent spaces but
the last are replaced by the value of the global variable:
\begin{indpar}
\verb|char mex::|\MEXKEY{trace\_mark}\verb|    // Default == '*'.|
\end{indpar}

A process's \TT{trace\_depth} is initialized to \TT{0} and maintained
by the following instructions:
\begin{center}
\begin{tabular}{l@{~~~~}l}
\TT{BEG} ~ \TT{BEGL} ~ \TT{CALL}+\TT{BEGF} & Increment by 1. \\
\TT{END} ~ \TT{ENDL} ~ \TT{ENDF} ~ \TT{RET} & Decrement by 1. \\
\TT{JMP\ldots} & Decrement by low order 3 bits of instruction's \\
               & \TT{trace\_flags} member (the bits masked by \\
               & \TT{mex::TRACE\_DEPTH}: \pagref{MEX::TRACE_DEPTH}). \\
\end{tabular}
\end{center}

\subsection{ERROR Instruction}
\label{ERROR-INSTRUCTION}

The \TT{ERROR} instruction is always traced, even in optimized mode.
The effective trace flags for this instruction are just the
\TT{trace\_flags} member of the instruction with the \TT{TRACE} flag forced on.

The trace message for the \TT{ERROR} instruction is thus in effect an
error message.

\subsection{Fatal Errors}
\label{FATAL-ERRORS}

\ikey{Fatal errors}{fatal error} are errors that terminate the current
process.  A fatal error produces an error message that describes the
error.  If a \TT{min::phrase\_position} is available for the instruction
that had the fatal error, it will be used to specify the location
of the error in source code.

The following is a complete list of fatal errors;
\begin{enumerate}
\item \TT{ERROR} instruction with non-zero \TT{immedB}.
\item A \TT{JMP\ldots} instruction comparing values
(A) one of which is not a number or an infinity, or
(B) both of which are infinities with the same sign.
\item Attempting to increase stack size to above the \TT{max\_length}
member of the process.
\item Attempting to increase the \TT{return\_stack}
size to above the \TT{max\_length} member of the process \TT{return\_stack}.
\item Attempt to pop a value off an empty stack.
\item Setting the process \TT{pc} to \TT{\{min::NULL\_STUB,$I$\}} where
$I$ is \underline{not} \TT{0}.
\item Attempt to decrement \TT{trace\_depth} when that is \TT{0}.

\end{enumerate}

Note that arithmetic exceptions (see \itemref{ARITHMETIC-EXCEPTIONS})
are \underline{not} fatal errors.

\section{MEX Functions}
\label{MEX Functions}

{\tt mex::module mex::}\MEXKEY{create\_module}
    \verb|( min::file f )|
\begin{indpar}
A \TT{mex::module} is created and returned.  The code vector is empty.
Empty \TT{position} and \TT{trace\_info} vectors are created.
The \TT{globals} member is set to \TT{min::NULL\_STUB} and the
\TT{interface} member is set to \TT{min::MISSING()}.

The \TT{max\_length} of the three empty vectors is intially set to:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{module\_length}\verb|    // Default == 1 << 12.|
\end{indpar}

Note that \TT{mex::module} and its components are read-only, so that
to push intructions, positions, and info into the vectors the module type
must be converted to \TT{mex::module\_ins}.  The following inline
functions can be used to push elements into these vectors and
call \TT{min::acc\_write\_update} as necessary:
\begin{indpar}
{\tt void mex::}\MEXKEY{push\_instr} \\
\hspace*{2em}
    \begin{tabular}[t]{@{}l@{}}
    \verb|( mex::module_ins m, mex::op_code op_code,| \\
    \verb|                     min::uns8 trace_flags = 0,| \\
    \verb|                     min::uns16 immedA = 0,| \\
    \verb|                     min::uns16 immedB = 0,| \\
    \verb|                     min::uns16 immedC = 0,| \\
    \verb|                     min::gen   immedD = min::MISSING() )| \\
    \end{tabular}
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_position}
    \verb|( mex::module, min::phrase_position pp )|
\\[0.5ex]
{\tt void mex::}\MEXKEY{push\_trace\_info}
    \verb|( mex::module, min::gen info )|
\end{indpar}

These functions will increase the \TT{max\_length} of the vectors
automatically if necessary.

\end{indpar}

{\tt mex::process mex::}\MEXKEY{create\_process} \\
\hspace*{10em}\verb|( min::printer printer = mex::default_printer )|
\begin{indpar}
A \TT{mex::process} is created and returned.
The process \TT{length} member (stack size) is set to \TT{0}
and its \TT{max\_length} member (maximum stack size) is set to the
value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{stack\_limit}\verb|    // Default == 16384.|
\end{indpar}

An empty \TT{return\_stack} vector is created and its \TT{max\_size}
is set to the value of the global variable:
\begin{indpar}
\verb|min::uns32 mex::|\MEXKEY{return\_stack\_limit}%
            \verb|    // Default == 4096.|
\end{indpar}

Note: the stack's \TT{max\_length} members are \underline{not} permitted
to change during process execution.

The \TT{printer} member is set to the \TT{printer} argument.
The \TT{pc} member is set to \TT{\{min::NULL\_STUB,0\}}.
The \TT{optimize} member is set to \TT{false}.
The \TT{fp[\ldots]}, \TT{trace\_\EOL depth},
\TT{trace\_flags}, \TT{excepts}, \TT{excepts\_\EOL accumulator},
\TT{counter}, and \TT{limit}
members are set to \TT{0}.
The \TT{state} is set to \TT{NEVER\_\EOL STARTED}.

The \TT{trace\_function} member is set to \TT{mex::default\_trace}.
\end{indpar}

{\tt min::locatable\_var<min::printer> mex::}\MEXKEY{default\_printer}
\begin{indpar}
See \TT{mex::create\_process}.
\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::module m, mex::process p = min:NULL_STUB )|
\begin{indpar}
Initialize \TT{p} (which is created by \TT{mex::create\_process}
if that is \TT{NULL\_STUB}) to run the code in \TT{m}.
Return the process.

The process members are set as they would be by \TT{mex::create\_process},
except:
\begin{itemize}
\item The \TT{pc} member is set to \TT{\{m,0\}}.
\item The following members are not set: \\
\hspace*{2em}
\TT{printer}, \TT{optimze}, \TT{trace\_flags}, \TT{trace\_function},
\TT{excepts}
\end{itemize}

\end{indpar}

{\tt mex::process mex::}\MEXKEY{init\_process} \\
\hspace*{10em}\verb|( mex::pc pc, mex::process p = min:NULL_STUB )|
\begin{indpar}
Ditto, but does not set the process \TT{pc} member.

Then emulates a \TT{CALL} to the \TT{pc} argument
value, which must point at a \TT{BEGF} instruction with \TT{immedB == 1}
(i.e., lexical level = 1).
This creates a \TT{return\_stack} entry whose
\TT{saved\_pc} is \TT{\{min::NULL\_STUB,0\}}, so a return
will terminate the process normally.  The \TT{nargs} and \TT{nresults} members
are set to \TT{0}.

If there is an error in pointing at a \TT{BEGF} instruction of level 1,
then instead the process \TT{pc} member is set to the illegal value
\TT{\{ min::NULL\_STUB, 1 \}} and \TT{min::NULL\_STUB} is returned.
\end{indpar}

{\tt bool mex::}\MEXKEY{run\_process} \verb|( mex::process p )|%
\label{MEX::RUN_PROCESS}
\begin{indpar}
Execute \TT{p} until it terminates.
Returns \TT{true} on normal termination
and \TT{false} otherwise.  The process \TT{state} is
set as follows to indicate cause of termination:
\begin{center}
\begin{tabular}{lp{3.0in}l}
\verb|mex::|\MEXKEY{MODULE\_END}
    & \raggedright \TT{pc} equals \TT{\{m,index\}} with \TT{index == m->length}
    & returns \TT{true} \\
\verb|mex::|\MEXKEY{CALL\_END}
    & \TT{pc} equals \TT{\{min::NULL\_STUB,0\}}
    & returns \TT{true} \\
\verb|mex::|\MEXKEY{LIMIT\_STOP}
    & \TT{p->counter >= p->limit}
    & returns \TT{false} \\
\verb|mex::|\MEXKEY{ERROR\_STOP}
    & \TT{ERROR} instruction with \TT{immedB != 0}
    & returns \TT{false} \\
\verb|mex::|\MEXKEY{JMP\_ERROR}
    & \raggedright conditional \TT{JMP\ldots}~instruction with
      invalid operand(s)
      (either a \TT{NaN} or both infinities of the same sign)
    & returns \TT{false} \\
\verb|mex::|\MEXKEY{FORM\_ERROR}
    & \raggedright program formatting error (likely a compiler
      error)
    & returns \TT{false} \\
\end{tabular}
\end{center}
\end{indpar}

Notes:
\begin{enumerate}
\item On \TT{LIMIT\_STOP}, you can increase \TT{p->limit}
and call \TT{run\_process} again to continue execution.
\item You can use \TT{init\_process ( m )} followed by \TT{run\_process}
to run the code of \TT{m}.  Then after \TT{MODULE\_END},
you can add to the end of \TT{m}
and call \TT{run\_process} again to continue the execution of the code
of \TT{m} (i.e., execute the added code).
\end{enumerate}

\section{MEXAS Language}
\label{MEXAS Language}

\key{MEXAS} is an assembly language for MEX.  The \ttkey{mexas}
assembler can be use as a MEX compiler.

MEXAS is a tool for debugging MEX and a prototype for more
advanced MEX compilers.

\subsection{MEXAS Syntax}
\label{MEXAS-SYNTAX}

MEXAS programs are written in ASCII.  Control characters other
than whitespace are forbidden.

A MEXAS program consists of statements which are instructions
or declarations, each encoded as a sequence of lexemes.

 A line ending with the `\ttkey{\textbackslash}' lexeme
is \key{continued} on the next line (the `\TT{\textbackslash}' is
otherwise ignored).
If the first lexeme on a line is `\ttkey{//}', the entire line
is a \key{comment line} and is ignored (comment lines cannot
be continued).  Blank lines are ignored.

A \key{statement} is a sequence of lines beginning with a non-blank
line and ending with a non-blank, non-comment line that is
\underline{not} continued.  Statements are either instructions or
declarations.

Instructions begin with an op code lexeme, and the program syntax
of all the instructions taken together
is that of a code vector: see Code Vectors,
\itemref{CODE-VECTORS}.

Declarations define jump instruction targets and instruction
trace flags.

When `\key{::=}' is used in a syntax equation, the
items of the equation are lexemes and \underline{not}
characters.

\subsection{Lexemes}

A MEXAS \key{lexeme} is a sequence of non-whitespace characters
surrounded by whitespace, or a single quote (\TT{'}) followed
by a sequence of non-single-quote characters followed by a
single quote, or a double quote (\TT{"}) followed by a 
sequence of non-double-quote characters followed by a
double quote.

A \key{number}\label{NUMBER} is a lexeme acceptable as an IEEE floating point
number to the POSIX \TT{strtod} function.

A \key{name}\label{NAME} is a lexeme beginning with a letter that is
\underline{not} a number (\TT{nan}, \TT{InF}, etc. are numbers
and not names).

A \key{string}\label{STRING} is a lexeme beginning with quote and ending
with the same kind of quote.

All lexemes must be on a single line: they cannot be continued to the
next line.  Strings not terminated by an end of line are automatically
terminated with an error message.

The comment beginning lexeme (\TT{//}) and the continuation
lexeme (\TT{\textbackslash}) must be lexemes surrounded by whitespace.

Illegal characters are replaced by \TT{\#} and become part of the
current lexeme.  An error message accompanies such replacement.

\subsection{Lexical Level and Depth}
\label{LEXICAL-LEVEL-AND-DEPTH}

Functions are bracketted with \TT{BEGF} and \TT{ENDF}
and have a \key{lexical level}.  The lexical level of a function
that is \underline{not} inside any other function is \TT{1}.
The lexical level of any other function $F$ is one plus the lexical
level of the smallest function containing $F$.
The lexical level of an instruction
is that of the smallest function containing the instruction.
The lexical level of instrucions
that are \underline{not} inside any function is \TT{0}.

Code also contains (non-function) \skey{block}s that are
bracketted with either \TT{BEG} and \TT{END} or with
\TT{BEGL} and \TT{ENDL}.  A blocks has a \key{container}
and within the container a \key{depth}.
A block not inside a function has the module as its container.
The container of a block inside a function is the smallest
function containing the block.

The depth of a block that is not inside any other block with
the same container is \TT{1}.  The depth of any other block $B$
is one plus the depth of the smallest block containing $B$.
The dept of an instruction
is that of the smallest block containing the instruction.
The depth of instrucions in a container
that are \underline{not} inside any block that is in the container
is \TT{0}.

\subsection{Assembler Stacks}
\label{ASSEMBLER-STACKS}

The assembler maintains several stacks during assembly.

The assembler's \key{variable stack} mirrors the stack of
the process during execution.  Each variable stack
element specifies the lexical level and depth of the
instruction that created the stack element, and optionally
assigns a name to the stack element.  These names are the
variable names of the assembly, and can be used in
push and pop instructions to name stack elements read or
written.

When assembled, most instructions manipulate the variable
stack just as they will manipulate the process stack
when executed.  The \TT{BEG} instruction does nothing
but when the \TT{END} instruction is assembled, it pops
from the end of the variable stack all elements with
the same lexical level and depth as the \TT{END} instruction.
\TT{BEGL} and \TT{ENDL} behave similarly, except that
\TT{BEGL} pushes next variables (see Next Variables and Loops,
\itemref{NEXT-VARIABLES-AND-LOOPS}) into the variable stack.
\TT{BEGF} and \TT{ENDF} behave similarly except that \TT{BEGF}
pushes arguments into the variable stack.

Two instructions that treat the variable stack very differently
from a process stack are \TT{CALL\ldots} and \TT{JMP}.  \TT{CALL\ldots}
pops arguments from the variable stack and pushes returned values.
\TT{JMP} does nothing to the variable stack, and the conditional
jumps \TT{JMP\ldots} just pops two elements.

In order to locate arguments in the variable stack, the assembler variable
\TT{fp[$L$]} is maintained when a \TT{BEGF} is assembled as the
variable stack size after argument elements are pushed into the
variable stack by \TT{BEGF}: see \TT{BEGF}, \pagref{BEGF}.

The assembler's \key{function stack} specifies the functions that
can be called by a \TT{CALL\ldots} instruction.  \TT{BEGF} pushs
a element with a name, lexical level, and depth, and behaves
for the function stack like \TT{PUSH\ldots} does for the variable stack.
\TT{END\ldots} instructions pop the function stack in the same manner as
they pop the variable stack.

At the end of assembly, the variable and function stacks hold
elements of lexical level 0 and depth 0.  These stacks are then
saved as the module's interface that allows global variables
and lexical level 1 functions of the module to be accessed by
other modules.

Lastly the assembler maintains a \key{block stack} whose only
purpose is to check that \TT{BEG\ldots} and \TT{END\ldots} instructions
occur in matching pairs.

\subsection{JMP Targets}
\label{JMP-TARGETS}

A {\em jmp-target} is a name\pagnote{NAME} that identifies
a code vector index value which can be used by \TT{JMP\ldots}
instructions as the point in the code vector to jump to.

{\em Jmp-targets} are defined by \TT{LABEL} declarations
of the form:
\begin{center}
\ttkey{LABEL} {\em jmp-target}
\end{center}

\TT{JMP\ldots} instructions are forward-referencing: their
{\em jmp-targets} are defined by \TT{LABEL} declaratios that
occur in source code \underline{after} the \TT{JMP\ldots} instruction.
To manage \TT{JMP\ldots} instructions and their targets,
the assembler maintains a list of \skey{pending jumps}:
that is, jumps whose {\em jmp-target} has not yet been
declared.  When a \TT{LABEL} declaration is processed,
the pending jump list is searched for matching jumps,
and those that are found are resolved and removed from
the list.  Resolving involves calculating the distance
between the jump and its target, and the number of
process stack elements the jump should pop.  Jump instructions
are allowed to pop stack elements, but cannot push them.

To allow this, an element of the pending jump list contains:
\begin{enumerate}
\item The location of the jump instruction so it can be updated
when its target is found.
\item The {\em jmp-target} name.
\item The lexical level $L$ of the jump instruction.
\item The maximum depth $D$ allowed for the target.
\item The length $S$ of the variable stack when the jump instruction
      was encountered.
\item The minimum $M$ of $S$ and all the variable stack lengths that have
      occured after \TT{END} or \TT{ENDL} instructions encountered
      since the jump instruction was encountered.
      $M\le S$.
\end{enumerate}

A \TT{JMP\ldots} instruction for which a legal target exists
is called \key{resolvable}.  Other \TT{JMP\ldots} instructions
are \key{unresolvable} and are in error.

The following instructions/declarations act on the pending jump list:

\ttkey{JMP\dots} {\em jmp-target}
\begin{indpar}
Add an element to the pending jmp list with $L$, $D$,
$S$ set to their current values and $M=S$.
\end{indpar}

\ttkey{END}/\ttkey{ENDL}
\begin{indpar}
For all pending jumps whose $D$ is equal to that
of the \TT{END}/\TT{ENDL}, decrement that $D$ by 1.

For all pending jumps whose $M$ is greater than the
variable stack length $s$ will be after the \TT{END}/\TT{ENDL},
decrease their $M$ to $s$.
\end{indpar}

\ttkey{LABEL} {\em jmp-target}\label{LABEL}
\begin{indpar}
Search the pending jump list for matching elements with $L$ equal
to the current lexical level and $D$ not less than the current
depth, resolve these, and remove them from
the pending jmp list.
\end{indpar}

\ttkey{ENDF}
\begin{indpar}
Search the pending jump list for elements with $L$ equal to the
lexical level of the \TT{ENDF} and remove them as being unresolvabl,
and therefore in error.
\end{indpar}

{\bf Stack Jump Rule}: When a jump list element is resolved, its $M$
must equal the length of the stack when the resolving \TT{LABEL}
is resolved.

In other words, the code jumped over by a \TT{JMP\ldots} must
have the same stack length at its beginning and at its end.


\subsection{MEXAS Instructions}
\label{MEXAS-INSTRUCTIONS}

In the following decription of MEXAS instruction syntax and
assembly actions:

\begin{enumerate}
\item When an instruction pushes an
element into the variable or function stacks, the element is given
the lexical level and depth of the instruction.
\item A \emkey{variable-name} is a name of a variable stack element.
If two elements have the same {\em variable-name}, the element nearer
the top of the stack hides the element lower down.
\item A \emkey{function-name} is a name of a function stack element.
If two elements have the same {\em function-name}, the element nearer
the top of the stack hides the element lower down.
\item Stack searches always proceed from the topmost stack element
the bottommost, and accept the first element found with the desired name.
\item Modules are named by the name of the file assembled to produce
the module, with the suffix \TT{.mex} deleted.  Such a name is
a \emkey{module-name}.
\item When a {\em variable-name} is assigned to a new variable stack
element, `\TT{*}' is used as the {\em variable-name} to indicate
that the element has no name.
\item When an instruction assigns a {\em new-variable-name}
to a newly created variable stack element, the {\em new-variable-name}
must \underline{not} be the same as the name of any variable of
less lexical level or depth than the instruction, or the same name
as that of an argument of a function (see \TT{BEGF}), or the same name as a
\TT{next-} variable of a loop (see \TT{BEGL}).
\item A variable cannot be written if it has a lexical level less than
that of the writting instruction, or is a function argument variable.
\item The operands that take integer values must have values in the
range $[0,2^{32})$ (so they will fit into \TT{immedA}, \TT{immedB},
or \TT{immedC} instruction
members).
\item Some instructions have a {\em trace-message} argument
and some have {\em trace-info} arguments, where:
\begin{indpar}
\emkey{trace-message} ::= {\em string}
\\[0.5ex]
\emkey{trace-info} ::= {\em trace-message} {\em variable}\STAR{}
\end{indpar}
See Instruction Tracing\pagnote{INSTRUCTION-TRACING} for details.
\end{enumerate}

{\em aop} {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em aop} is any arithmetic operation code from
Figure~\itemref{ARITHMETIC-INSTRUCTIONS}, and the run-time
action of the instruction is specified in that figure.

At assembly-time the same number of elements are popped from the variable stack
as are popped from the process stack during run-time.
Then one element is pushed to the variable stack.
If {\em variable-name} is given, it becomes
the name of the pushed element; otherwise the element has no name.
\end{indpar}

\ttkey{PUSHM} {\em variable-name}
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
lexical level 0 variable.
At assembly time, pushes into the variable stack an
element with the {\em new-variable-name} if given, or 
with no name otherwise.

The variable stack search for {\em variable-name} is restricted to
elements with the lexical level \TT{0}.
\end{indpar}

\ttkey{PUSHG} {\em module-name} {\em variable-name}
              {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the named
global variable in the named module.
At assembly time, pushes into the variable stack an
element with the {\em new-variable-name} if given, or 
with no name otherwise.

The variable stack searched for {\em variable-name} is the variable
stack of the previously assembled module named.
\end{indpar}

\ttkey{PUSH} {\em variable-name}
             {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of the variable
named in the variable stack or global variable vector.
At assembly time, pushes into the variable stack an
element with the {\em new-variable-name} if given, or
with no name otherwise.

The search for {\em variable-name} begins with the entire variable
stack and proceeds through the variable stacks of previously assembled modules
in the order that the modules were assembled.  \TT{PUSH} assembles
to the runtime instruction \TT{PUSHS}, \TT{PUSHL}, \TT{PUSHG},
or \TT{PUSHA}, depending on the location of the variable.
\end{indpar}

\ttkey{PUSHI} {\em number} {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time, pushes into the process stack a copy of
the {\em number}\pagnote{NUMBER}.
At assembly time, pushes into the variable stack an element
with the given {\em new-variable-name}, if given, or
with no name otherwise.
\end{indpar}

\ttkey{POP} {\em variable-name}\QMARK{}
\begin{indpar}
At run-time, pops the process stack and stores the value popped
into the variable named in the variable stack.  Or if the
variable name is not given or is `\TT{*}', discards the value popped.

At assembly time, pops the variable stack.

The variable stack search for {\em variable-name} is restricted to
elements with the same lexical level as the \TT{POP} instruction
that are not arguments to that lexical level.

\ttkey{POP} assembles to the run-time instruction \TT{POPS}.
Note that \TT{POPL}, \TT{POPG}, and \TT{POPA} do
\underline{not} exist as you cannot write
variables that are arguments, or at a different lexical level,
or in a different module.
\end{indpar}

\ttkey{JMP} {\em jmp-target}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
this instruction adds an element to the pending jump
list (see \itemref{JMP-TARGETS}).

The statement following a \TT{JMP} must
be a \TT{LABEL} declaration or an \TT{END\ldots} instruction.
\end{indpar}

\ttkey{JMP\ldots} {\em jmp-target}
\begin{indpar}
Here \ldots~denotes one of \TT{EQ}, \TT{NE}, etc.

At run-time these instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
these instructions pop two elements from the variable stack
and then add an element to the pending jump list.

Note that
the pending jump list element
$S$ value is the length of the variable stack \underline{after}
the two elements were popped.
\end{indpar}

\ttkey{BEG} {\em trace-info}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
\TT{BEG} just increments the depth.
\end{indpar}

\ttkey{END} {\em trace-info}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
it pops from the variable and function stacks all elements with the
same lexical level and depth as the \TT{END} instruction, then
decrements the depth, then updates the jump list (see
JMP Targets\pagnote{JMP-TARGETS}).
\end{indpar}

\ttkey{BEGL} {\em nnext} {\em trace-info}\QMARK{}
\begin{indpar}
Here {\em nnext} is the number of next variables
(see Next Variables and Loops, \itemref{NEXT-VARIABLES-AND-LOOPS}).
At run-time this instruction's action is as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS} with \TT{immedB} equal
to {\em nnext}.

At assembly-time, this instruction first increments the depth,
and then pushes {\em nnext} variable
stack elements.  For each of these, its name is derived from
the name of the {\em nnext}'th predecessor in the variable
stack by adding the prefix `\TT{next-}.'

Thus for example, if the top two stack elements have names
\TT{X} and \TT{Y} and {\em nnext} is \TT{2}, the two elements
pushed would have names \TT{next-X} and \TT{next-Y}.
\end{indpar}

\ttkey{ENDL} {\em trace-info}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
\TT{ENDL} does the same thing as \TT{END}.
\end{indpar}

\ttkey{CONT} {\em trace-info}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}.  At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{NOP} {\em trace-info}\QMARK{}
\begin{indpar}
At run-time this instruction does nothing
(see Figure~\itemref{HOUSEKEEPING-INSTRUCTIONS}).  At assembly-time,
this instruction does nothing.  This instruction is usually
used for tracing.
\end{indpar}

\ttkey{SET\_TRACE} {\em trace-class}\STAR{}
\begin{indpar}
At run-time set the process \TT{trace\_flags} parameter so as
to have a flag for each {\em trace-class} given.
See Instruction Tracing\pagnote{INSTRUCTION-TRACING} for details.

At assembly-time,
this instruction does nothing.
\end{indpar}

\ttkey{ERROR} {\em error-code} {\em trace-info}\QMARK{}
\begin{indpar}
If {\em error-code} is non-zero, this instruction terminates
the process at run-time.
This instruction is \underline{always} traced, regardless
of the setting of compile options and the process
\TT{trace\_flags}.

At assembly time this instruction does nothing.
\end{indpar}

\ttkey{BEGF}\label{BEGF} {\em function-name} {\em variable-name}\STAR{}
	{\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction pushes an element with the {\em function-name}
into the function stack and pushes one element with each
of the {\em variable-names} into the variable stack (they
represent the arguments to the function).
The number of {\em variable-names} can be less than,
but may \underline{not} be greater than, the number of actual
arguments.

Lastly the instruction saves the current variable stack size
in the assembly-time variable fp[$L$],
where $L$ is the lexical level of the \TT{BEGF}
instruction.  This is used to implement \TT{PUSHA}.
\end{indpar}

\ttkey{ENDF} {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
it pops from the variable and function stacks all elements with the
same lexical level as the \TT{ENDF} instruction.
\end{indpar}

\ttkey{CALLM} {\em function-name} {\em nargs} {\em variable-name}\STAR{}
	{\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
it pops from the variable variable stack {\em nargs} values
and pushes into the stack one element for each {\em variable-name}
(representing the results of the function execution).
The number of {\em variable-names} \underline{must} equal
the number of actual results.

The {\em function-name} is searched for in the function stack.
\end{indpar}

\ttkey{CALLG} {\em module-name} {\em function-name}
              {\em nargs} {\em variable-name}\STAR{}
	      {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
the actions are the same as for \TT{CALL}.

The {\em function-name} is searched for in the function stack of
the previously assembled module named.
\end{indpar}

\ttkey{CALL} {\em function-name}
             {\em nargs} {\em variable-name}\STAR{}
	      {\em trace-message}\QMARK{}
\begin{indpar}
This instruction searches for the {\em function-name} first in the function
stack and then in the function stacks of the previously assembled
modules in the order in which they were assembled.  It then
assembles to \TT{CALLM} or \TT{CALLG}.
\end{indpar}

\ttkey{RET} {\em nresults} {\em trace-message}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction pops {\em nresults} elements from the
variables stack.
\end{indpar}

\ttkey{PUSHNARGS} {\em new-variable-name}\QMARK{}
\begin{indpar}
At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction pushes into the variable stack an element
with the given {\em variable-name}.
\end{indpar}

\ttkey{PUSHV} {\em level}\QMARK{} {\em new-variable-name}\QMARK{}
\begin{indpar}
Here {\em level} is an integer specifing the lexical level
$L$ used as the \TT{immedB} parameter of the run-time
\TT{PUSHV} instruction.  If {\em level} > 0, then $L$ = {\em level}.
If {\em level} $\leq$ 0, $L$ = $K$ + {\em level} where
$K$ is the lexical level of the \TT{PUSHV} instruction.
If {\em level} is missing, $L$ = $K$.

At run-time this instruction's actions are as described in
Figure~\itemref{FUNCTION-INSTRUCTIONS}.  At assembly-time,
this instruction does nothing if {\em variable-name} is
not given, and otherwise changes the name of the top
variable stack element to {\em variable-name}.
\end{indpar}

\subsection{MEXAS Declarations}
\label{MEXAS-DECLARATIONS}

\ttkey{LABEL} {\em jmp-target}
\begin{indpar}
See \pagref{LABEL}.
\end{indpar}

\ttkey{INSTRUCTION\_TRACE} {\em trace-option}\STAR{}
\begin{indpar}
Set the \TT{trace\_flags} of the next instruction to those
given by the options (i.e., \TT{TRACE},
\TT{TRACE\_LINES}, \TT{TRACE\_NOJMP}).
\end{indpar}

\ttkey{DEFAULT\_TRACE} {\em trace-option}\STAR{}
\begin{indpar}
Set the default trace flags to those
given by the options (i.e., \TT{TRACE},
\TT{TRACE\_LINES}, \TT{TRACE\_NOJMP}).
In the absence of an immediately preceding \TT{INSTRUCTION\_TRACE}
declaration, an instruction's \TT{trace\_flags} are set to the
default trace flags.
\end{indpar}

\subsection{Instruction Tracing}
\label{INSTRUCTION-TRACING}

Instruction tracing is controlled by \skey{trace class}{es}
which are part of each instruction and \skey{trace flag}s which
are part of each process.  For example, all \TT{PUSH\ldots}
instructions have the \TT{PUSH} trace class, and a process
has a \TT{PUSH} trace flag which if on causes all instructions
with the \TT{PUSH} trace class to be traced.

The trace classes are given in Figure \ref{TRACE-CLASSES-AND-GROUPS}.

\begin{boxedfigure}[t]

\begin{center}

\bigskip

{\Large \bf Trace Classes}
\\[2ex]
\begin{tabular}{|l|p{5in}|}
\hline
\ttikey{NEVER}{trace class} & Instruction is never traced.
\\\hline
\ttikey{ALWAYS}{trace class} & Instruction is always traced.
    Only the \TT{ERROR} instruction has this class.
\\\hline
\ttikey{AOP}{trace class} & Arithmetic instructions in Figure
    \ref{ARITHMETIC-INSTRUCTIONS}.
\\\hline
\ttikey{PUSH}{trace class} & All \TT{PUSH\ldots} instructions in Figures
    \ref{HOUSEKEEPING-INSTRUCTIONS} and
    \ref{FUNCTION-INSTRUCTIONS}.
\\\hline
\ttikey{POP}{trace class} & The \TT{POP} instruction in Figure
    \ref{HOUSEKEEPING-INSTRUCTIONS}.
\\\hline
\ttikey{JMP}{trace class} & The \TT{JMP} instruction.
\\\hline
\begin{tabular}[t]{@{}l@{}}
\ttikey{JMPS}{trace class} \\
\ttikey{JMPF}{trace class}
\end{tabular} & \TT{JMP\ldots} instructions in
	        Figure \ref{HOUSEKEEPING-INSTRUCTIONS}.
		When compiled the instruction is given the \TT{JMPS}
		class.  When executed, if the jump test succeeds
		(jump is taken),
		the instruction trace class is left unchanged, but if
		the jump test fails (there is no actual jump),
		the trace class is changed
		to \TT{JMPF}.
\\\hline
\ttikey{XXX}{trace class} & Instruction with operation code \TT{XXX},
                            for instructions not mentioned above
			    (e.g., for \TT{NOP}, \TT{BEG}, etc.,
			    but \underline{not} for \TT{ADD},
			    \TT{PUSH}, \TT{JMPEQ}, \TT{ERROR}, etc.).
\\\hline
\end{tabular}
\end{center}

\bigskip

\begin{center}
{\Large \bf Trace Class Groups}
\\[2ex]
\begin{tabular}{|l|l|}
\hline
\ttmkey{ALL}{trace class group} &  All trace classes.
\\\hline
\ttmkey{NONE}{trace class group} &  No trace classes.
\\\hline
\ttmkey{FUNC}{trace class group} &  \TT{CALLM} \TT{CALLG} \TT{BEGF}
\\\hline
\ttmkey{LOOP}{trace class group} &  \TT{BEGL} \TT{CONT} \TT{ENDL}
\\\hline
\end{tabular}
\end{center}
\caption{Trace Classes and Groups}
\label{TRACE-CLASSES-AND-GROUPS}
\end{boxedfigure}

If a module is compiled with the \TT{-tcn} (trace class never)
flag (see The MEXAS Program, \itemref{THE-MEXAS-PROGRAM}),
all instructions that do not normally have the \TT{ALWAYS}
class are given the \TT{NEVER} class instead of their normal
class, thus providing that they will never be traced.  Note
that the \TT{ERROR} instruction is not affected by this flag.

Whether or not an instruction is actually traced depends on
the instruction's trace class and on the setting of the
process's \TT{trace\_flags}.  A trace class \TT{XX} has a
numeric code \TT{mex::T\_XX} and a trace flag
\TT{1<<mex::T\_XX}.  An instruction is traced if and only
if the flag of its trace class is set in the process's
\TT{trace\_flags}.

Note that the trace flag for \TT{ALWAYS} is always set
and the trace flag for \TT{NEVER} is always clear.

The MEXAS program \TT{-t:\ldots} flag sets trace flags
which then become the initial trace flags of any process.
The \TT{SET\_TRACE} instruction sets the process trace
flags.  Both take a list of trace class names, as in
\begin{center}
\tt SET\_TRACE POP CALL BEGF
\end{center}
and also the trace class group names in
Figure \ref{TRACE-CLASSES-AND-GROUPS}.

Note that when a function is called, it is the \TT{BEGF}
instruction that is traced, and the \TT{CALL} instruction
is not traced.  Similarly when the function returns,
it is the \TT{CALL} instruction that is traced, and the
\TT{ENDF} or \TT{RET} instruction is not traced.  Also,
jumping out of blocks prevents the block ending instruction
from being traced.

Tracing an instruction with a {\em trace-message} causes
the {\em trace-message} to be printed.

Tracing an instruction with a {\em trace-info} in addition causes
the names and values of the {\em variable}s named in the
{\em trace-info} to be printed.  In the cases of instructions
like \TT{BEGF} and \TT{CALL} that have a list of {\em variable}s
as part of the instruction proper, and not as part of a
{\em trace-info}, the list of variables in the instruction proper
is used as the {\em trace-info} variables list.

When an instruction has a {\em trace-info}, \TT{PUSH\ldots}
instructions are generated just before the instruction to
push the variable values onto the stack.  The values are then
printed from the stack if the instruction is traced.  Then
when the instruction executes, it begins by popping these
variable values from the stack.  This is why instructions
like \TT{BEG} can pop the stack; it is only because the
instruction may have to pop trace variable values.


\subsection{The MEXAS Program}
\label{THE-MEXAS-PROGRAM}


\clearpage

\printindex

\end{document}
